<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Dart Programming Language Basic Syntax | yl's blog</title><meta name="author" content="yl"><meta name="copyright" content="yl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Introduction to Dart Programming Language including basic syntax, data types, functions, OOP and asynchronous programming.">
<meta property="og:type" content="article">
<meta property="og:title" content="Dart Programming Language Basic Syntax">
<meta property="og:url" content="https://futureyl3.github.io/2025/03/02/Dart-Programming-Language-Basic-Syntax/">
<meta property="og:site_name" content="yl&#39;s blog">
<meta property="og:description" content="Introduction to Dart Programming Language including basic syntax, data types, functions, OOP and asynchronous programming.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://futureyl3.github.io/img/kano.JPG">
<meta property="article:published_time" content="2025-03-02T07:53:07.000Z">
<meta property="article:modified_time" content="2025-03-02T07:53:07.000Z">
<meta property="article:author" content="yl">
<meta property="article:tag" content="Dart">
<meta property="article:tag" content="Basic Syntax">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://futureyl3.github.io/img/kano.JPG"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Dart Programming Language Basic Syntax",
  "url": "https://futureyl3.github.io/2025/03/02/Dart-Programming-Language-Basic-Syntax/",
  "image": "https://futureyl3.github.io/img/kano.JPG",
  "datePublished": "2025-03-02T07:53:07.000Z",
  "dateModified": "2025-03-02T07:53:07.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "yl",
      "url": "https://futureyl3.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://futureyl3.github.io/2025/03/02/Dart-Programming-Language-Basic-Syntax/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Dart Programming Language Basic Syntax',
  isHighlightShrink: undefined,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/kano.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(to right, rgb(198, 255, 221), rgb(251, 215, 134), rgb(247, 121, 125));"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yl's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Dart Programming Language Basic Syntax</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Dart Programming Language Basic Syntax</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-02T07:53:07.000Z" title="Created 2025-03-02 15:53:07">2025-03-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-02T07:53:07.000Z" title="Updated 2025-03-02 15:53:07">2025-03-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Programming-Language/">Programming Language</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Programming-Language/Dart/">Dart</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">8.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>30mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>Dart</h1>
<h2 id="概述">概述</h2>
<h3 id="简介">简介</h3>
<ul>
<li>Dart 是谷歌开发的、类型安全的、面向对象的编程语言，被应用与 Web、服务器、移动应用和物联网等领域</li>
<li>Dart 诞生于 2011 年</li>
<li>Dart 是类似 TypeScript 的强类型语言</li>
<li>Dart 的运行方式
<ul>
<li>原生虚拟机（类似 JVM，Dart 代码可以运行在 Windows、Mac、Linux上）</li>
<li>JavaScrpit 引擎（Dart 代码可以转成 JS 代码，然后运行在浏览器上）</li>
</ul>
</li>
</ul>
<h3 id="Dart-与-JavaScript">Dart 与 JavaScript</h3>
<p>以下是 Dart 各方面与 JavaScript 的比较</p>
<img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/Dart%E4%B8%8EJavaScript.png" class="">
<!-- ![image-20240406170813634](./assets/Dart与JavaScript.png) -->
<h2 id="Dart-基础语法">Dart 基础语法</h2>
<h3 id="引例">引例</h3>
<p>以下入门程序告诉了我们 Dart 的基本语法内容</p>
<ul>
<li>
<p>用 <code>//</code> 来注释语句</p>
</li>
<li>
<p>声明函数不需要关键字</p>
</li>
<li>
<p>函数和参数前面都有类型声明</p>
</li>
<li>
<p>打印使用 <code>print</code></p>
</li>
<li>
<p>每行代码结束时，必须以分号结束</p>
</li>
<li>
<p>字符串通过引号包起来，支持模板字符串（$+变量名）</p>
</li>
<li>
<p><code>main</code> 是入口函数，Dart 应用程序总是从 <code>main</code> 函数开始执行</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="keyword">void</span> printInteger(<span class="built_in">int</span> aNumber) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;The number is <span class="subst">$aNumber</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口文件-应用从这里开始执行</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">42</span>;</span><br><span class="line">  printInteger(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="运行">运行</h3>
<p>在命令行中输入 <code>dart xxx.dart</code> 来运行 Dart 程序</p>
<h3 id="注释">注释</h3>
<ul>
<li>单行注释 —— // xxx</li>
<li>多行注释 —— /*xxx*/</li>
<li>文档注释 —— ///
<ul>
<li>可通过 dartdoc 命令将文档注释转成文档（文档注释支持 markdown 语法）</li>
</ul>
</li>
</ul>
<h3 id="变量">变量</h3>
<ul>
<li>变量是一个引用，Dart 中万物皆对象，变量存储的是对象的引用</li>
<li>声明变量的方式
<ul>
<li>明确指定类型声明</li>
<li>自动类型推断 <code>var</code></li>
<li>动态类型 <code>dynamic</code></li>
</ul>
</li>
<li>变量名大小写敏感</li>
<li>变量默认值是 <code>null</code></li>
<li>Dart 变量的值不会进行隐式转换（null 不会转成 false，0 不会转成 false 等等）</li>
</ul>
<h3 id="常量">常量</h3>
<ul>
<li>
<p>常量就是值不可变的变量（一旦声明，其值不能修改）</p>
</li>
<li>
<p>声明常量方式</p>
<ul>
<li>使用 <code>const</code> 关键字</li>
<li>使用 <code>final</code> 关键字</li>
</ul>
</li>
<li>
<p>const 和 final 的区别</p>
<ul>
<li>
<p><code>const</code> 是编译期不可变</p>
</li>
<li>
<p><code>final</code> 是运行时不可变</p>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="built_in">DateTime</span>.now(); <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">final</span> time = <span class="built_in">DateTime</span>.now()l <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数据类型">数据类型</h2>
<h3 id="Number">Number</h3>
<h4 id="Dart-中的数字由三个关键字描述">Dart 中的数字由三个关键字描述</h4>
<ul>
<li><code>num</code> 数字类型（既可以是整数，也可以是小数）
<ul>
<li><code>int</code> 整数</li>
<li><code>double</code> 浮点数</li>
</ul>
</li>
<li><code>num</code> 可以在赋值的时候进行类型推断，推断为 <code>int</code> 或 <code>double</code></li>
<li><code>int</code> 和 <code>double</code> 必须在赋值时给定正确的值</li>
<li>当不确定赋值的值是整数还是小数时，就可以用 <code>num</code></li>
</ul>
<h4 id="常用-API：在官方文档中查阅">常用 API：在官方文档中查阅</h4>
<p>常用：</p>
<ul>
<li>类型转换：toxxx()</li>
<li>四舍五入：round()</li>
<li>返回余数：remainder()</li>
<li>数字比较：compareTo()</li>
<li>返回最大公因数：gcd()</li>
<li>科学计数法：toStringAsExponential()</li>
</ul>
<h3 id="String">String</h3>
<h4 id="使用-String-声明字符串">使用 String 声明字符串</h4>
<ul>
<li>单引号，双引号均可</li>
<li>三个引号可以声明包含换行符的字符串（多行字符串）</li>
</ul>
<h4 id="常用-API：官方文档查阅">常用 API：官方文档查阅</h4>
<p>常用：</p>
<ul>
<li>字符串分割：split()</li>
<li>字符串拼接： + 运算符</li>
<li>字符串裁切：trim()</li>
<li>判断字符串是否为空：isEmpty（是属性，不要括号）</li>
<li>字符串替换：replaceAll() （支持正则替换）</li>
<li>字符串匹配：hasMatch()</li>
<li>查找子串：contains()</li>
<li>定位子串：indexOf()</li>
</ul>
<h4 id="正则表达式">正则表达式</h4>
<ul>
<li>语法：<code>RegExp(r'正则表达式')</code></li>
<li>例子：匹配一到多个数字：<code>RegExp(r'\d+')</code></li>
</ul>
<h3 id="Boolean">Boolean</h3>
<ul>
<li>Dart 通过 <code>bool</code> 关键字来表示布尔类型</li>
<li>布尔类型只有两个值：<code>true</code> 和 <code>false</code></li>
<li>对变量进行判断时，要显式地检查布尔值，即写表达式来判断</li>
<li>一些特殊的判断
<ul>
<li>字符串：isEmpty, isNotEmpty</li>
<li>数字：isNaN, isFinite …</li>
</ul>
</li>
</ul>
<h3 id="List">List</h3>
<h4 id="Dart-中的数组，由-List-对象表示。List-有两种声明方式">Dart 中的数组，由 List 对象表示。List 有两种声明方式</h4>
<ul>
<li>
<p>字面量方式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span> list = []; <span class="comment">// 不限定元素的数据类型</span></span><br><span class="line"><span class="built_in">List</span> list = &lt;<span class="built_in">int</span>&gt;[]; <span class="comment">// 限定元素的类型为int，&lt;&gt;内的称为泛型</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>构造函数方式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span> list = <span class="keyword">new</span> <span class="built_in">List</span>.empty(growable: <span class="keyword">true</span>); <span class="comment">// 不限制长度的空列表</span></span><br><span class="line"><span class="built_in">List</span> list = <span class="keyword">new</span> <span class="built_in">List</span>.filled(<span class="number">3</span>, <span class="number">0</span>); <span class="comment">// 声明指定长度的填充列表</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="扩展操作符（…）">扩展操作符（…）</h4>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> list2 = [<span class="number">0</span>, ...list1]; <span class="comment">// [0, 1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list3;</span><br><span class="line"><span class="keyword">var</span> list4 = [<span class="number">0</span>, ...?list3]; <span class="comment">// 空安全的扩展运算符，list3为null时不会报错，list4为[0]</span></span><br></pre></td></tr></table></figure>
<h4 id="常用-API：查阅官方文档">常用 API：查阅官方文档</h4>
<p>常用：</p>
<ul>
<li>列表长度：length（属性）</li>
<li>列表翻转：reversed（属性，且得到的是一个可迭代对象，不是List）</li>
<li>转为列表：toList()</li>
<li>添加元素：add(), addAll()</li>
<li>删除元素：remove(), removeAt()</li>
<li>在指定位置添加元素：insert()</li>
<li>清空：clear()</li>
<li>合并列表中的元素：join()（返回字符串）</li>
</ul>
<h4 id="遍历列表">遍历列表</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>forEach()</td>
<td>遍历列表</td>
</tr>
<tr>
<td>map()</td>
<td>遍历并处理元素，然后生成新的列表</td>
</tr>
<tr>
<td>where()</td>
<td>返回满足条件的数据，传布尔函数</td>
</tr>
<tr>
<td>any()</td>
<td>只要有一项满足条件，即返回 true，传布尔函数</td>
</tr>
<tr>
<td>every()</td>
<td>判断是否每一项都满足条件，都满足才返回 true，传布尔函数</td>
</tr>
<tr>
<td>expand()</td>
<td>将二维数组降维为一维数组</td>
</tr>
<tr>
<td>fold()</td>
<td>对列表中的每一个元素，做一个累计操作（类似于归约）</td>
</tr>
</tbody>
</table>
<p>同样可以用 for 循环来遍历</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Set">Set</h3>
<h4 id="简介-2">简介</h4>
<ul>
<li>Set 是一个无序的、元素唯一的集合</li>
<li>Set 有字面量和构造函数两种声明方式（字面量用大括号包裹）
<ul>
<li><code>var set1 = &lt;int&gt;&#123;1, 2, 3&#125;;</code></li>
<li><code>var set2 = new Set();</code></li>
</ul>
</li>
<li>无法通过下标取值</li>
<li>具有集合特有的操作
<ul>
<li>如求交并差等</li>
</ul>
</li>
</ul>
<h4 id="常用-API-查阅官方文档">常用 API 查阅官方文档</h4>
<p>常用：</p>
<ul>
<li>列表转换成集合：toSet()（可以过滤掉列表中重复的元素）</li>
<li>批量添加：addAll()，参数可以是列表，也可以是集合</li>
<li>求交集：intersection()</li>
<li>求并集：union()</li>
<li>求差集：difference()</li>
<li>返回第一个元素：first（属性）</li>
<li>返回最后一个元素：last（属性）</li>
</ul>
<h3 id="Map">Map</h3>
<h4 id="简介-3">简介</h4>
<ul>
<li>
<p>Map 是一个无序的<strong>键值对映射</strong>，通常被称作<strong>哈希</strong>或<strong>字典</strong></p>
</li>
<li>
<p>声明方式</p>
<ul>
<li><code>var map = &#123;key1:value1, key2:value2&#125;;</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map[<span class="string">&#x27;key&#x27;</span>] = value;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="常用-API-查阅官方文档-2">常用 API 查阅官方文档</h4>
<p>常用：</p>
<ul>
<li>访问属性：map[‘key’]</li>
<li>判断 Map 中的 key 是否存在：containsKey(‘key’)</li>
<li>如果 key 不存在，才赋值：putIfAbsent()</li>
<li>获取 Map 中所有的 key：keys（属性）</li>
<li>获取 Map 中所有的 value：values（属性）</li>
<li>根据条件进行删除：removeWhere()</li>
</ul>
<h3 id="其他">其他</h3>
<h4 id="Runes">Runes</h4>
<ul>
<li>Runes 对象是一个 32 位字符对象。它可以把文字转换成符号表情或特定的文字（使用 UTF32编码）</li>
<li>参考网站：<a target="_blank" rel="noopener" href="https://copychar.cc/">https://copychar.cc/</a></li>
</ul>
<h4 id="Symbol">Symbol</h4>
<ul>
<li>在 Dart 中符号用 # 开头来表示的标识符</li>
<li>用于反射</li>
</ul>
<h4 id="dynamic">dynamic</h4>
<ul>
<li>动态数据类型，即弱类型，此类型的变量可以被赋值为任意数据类型</li>
</ul>
<h2 id="运算符">运算符</h2>
<h3 id="地板除（-）">地板除（~/）</h3>
<p>用于得到除法结果的向下取整的整数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> ~/ <span class="number">4</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="类型判断运算符（is-和-is-）">类型判断运算符（is 和 is!）</h3>
<p>判断类型，类似 Java 中的  instanceOf()</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [];</span><br><span class="line">list <span class="keyword">is</span> <span class="built_in">List</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="避空运算符（-和-）">避空运算符（?? 和 ??=）</h3>
<p>?? 是三元运算符的语法糖，??= 用于赋值语句</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ??前面的不为空，则值为前面的，为空则值为后面的</span></span><br><span class="line"><span class="number">1</span> ?? <span class="number">3</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">null</span> ?? <span class="number">12</span>; <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量为空，则赋值，不为空则不赋值</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a ??= <span class="number">3</span>; <span class="comment">// a为3</span></span><br><span class="line">a ??= <span class="number">5</span>; <span class="comment">// 赋值失败</span></span><br></pre></td></tr></table></figure>
<h3 id="条件属性访问（-）">条件属性访问（?.）</h3>
<p>判断属性是否存在，存在才访问，否则不访问，返回 null，避免报错</p>
<h3 id="级联运算符（…）">级联运算符（…）</h3>
<p>用于连续调用对象的方法，链式调用，每次方法返回的不是方法返回值，而是当前对象的引用</p>
<h2 id="函数">函数</h2>
<h3 id="声明函数">声明函数</h3>
<h4 id="直接声明">直接声明</h4>
<ul>
<li>
<p>Dart 中声明函数不需要 function 关键字</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> printInfo() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="箭头函数">箭头函数</h4>
<ul>
<li>
<p>Dart 中的箭头函数中，<strong>函数体只能写一行且不能带有结束的分号</strong></p>
</li>
<li>
<p>Dart 中的箭头函数，只是函数的一种简写形式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">list.forEach((element) =&gt; <span class="built_in">print</span>(element));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="匿名函数">匿名函数</h4>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = (value) &#123;</span><br><span class="line">  <span class="built_in">print</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="立即执行函数">立即执行函数</h4>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当语句执行到此时，该函数会立即执行，打印17</span></span><br><span class="line">((<span class="built_in">int</span> n) &#123;</span><br><span class="line">  <span class="built_in">print</span>(n);</span><br><span class="line">&#125;) (<span class="number">17</span>);</span><br></pre></td></tr></table></figure>
<h3 id="函数参数">函数参数</h3>
<h4 id="必填参数">必填参数</h4>
<p>用法：数据类型 参数名称</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> userInfo(<span class="built_in">String</span> name) &#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可选参数">可选参数</h4>
<p>语法：[数据类型 参数名称, …]</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可选参数如果不给dynamic类型的话，必须赋初值</span></span><br><span class="line"><span class="built_in">String</span> userInfo(<span class="built_in">String</span> name, [<span class="built_in">int</span> age = <span class="number">0</span>]) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;<span class="subst">$name</span>, <span class="subst">$age</span>&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用，可选参数按顺序赋值</span></span><br><span class="line">userInfo(<span class="string">&#x27;tom&#x27;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<h4 id="命名参数">命名参数</h4>
<p>语法：{数据类型 参数名称, …}</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命名参数调用时，需要与声明时的形参名一致</span></span><br><span class="line"><span class="comment">// 同理，命名参数如果不给dynamic类型的话，必须赋初值</span></span><br><span class="line"><span class="built_in">String</span> userInfo(<span class="built_in">String</span> name, &#123;<span class="built_in">int</span> age = <span class="number">0</span>&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;<span class="subst">$name</span>, <span class="subst">$age</span>&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">userInfo(<span class="string">&#x27;tom&#x27;</span>, age: <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<h4 id="函数参数-2">函数参数</h4>
<p>将函数当作参数传递，传参的函数也叫回调函数</p>
<h3 id="作用域与闭包">作用域与闭包</h3>
<h4 id="作用域">作用域</h4>
<p><strong>内层作用域可以访问外层的变量内容</strong>，但外层不能访问内层的变量内容，即 Java 中作用域的内容。</p>
<h4 id="闭包">闭包</h4>
<ul>
<li>
<p>Dart 中闭包的实现方式与 JavaScript 中完全一致</p>
</li>
<li>
<p>使用时机：<strong>既能重用变量，又保护变量不被全局污染</strong></p>
</li>
<li>
<p>实现原理：外层函数被调用后，外层函数的作用域对象（AO）被内层函数引用着，导致外层函数的作用域对象无法释放，从而形成闭包</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包可以持久化外层函数的变量，避免函数调用后内部变量被清除</span></span><br><span class="line">parent() &#123;</span><br><span class="line">  <span class="keyword">var</span> money = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> () &#123;</span><br><span class="line">    money -= <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">print</span>(money);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = parent();</span><br><span class="line">p(); <span class="comment">// 900</span></span><br><span class="line">p(); <span class="comment">// 800</span></span><br><span class="line">p(); <span class="comment">// 700</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="异步函数">异步函数</h3>
<h4 id="简介-4">简介</h4>
<ul>
<li>Dart 中，异步调用通过 Future 来实现</li>
<li>async 函数返回一个 Future，await 用于等待 Future</li>
<li>关于 Future 的详情可到官网文档查看</li>
</ul>
<h4 id="接收处理异步结果">接收处理异步结果</h4>
<h5 id="使用-then">使用 then</h5>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future getIpAddress() &#123;</span><br><span class="line">  <span class="keyword">final</span> url = <span class="string">&#x27;https://httpbin.org/ip&#x27;</span>;</span><br><span class="line">  <span class="comment">// then中的函数需要返回某些值，不然外部调用getIPAddress函数得到的返回值是null</span></span><br><span class="line">  <span class="comment">// then中的函数返回的值会被包装成Future类型</span></span><br><span class="line">  <span class="keyword">return</span> http.<span class="keyword">get</span>(url).then( (response) &#123;</span><br><span class="line">    <span class="built_in">print</span>(response.body);</span><br><span class="line">    <span class="keyword">return</span> response.body</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用-async-和-await">使用 async 和 await</h5>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future getIpAddress() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> url = <span class="string">&#x27;https://httpbin.org/ip&#x27;</span>;</span><br><span class="line">  <span class="keyword">final</span> response = <span class="keyword">await</span> http.<span class="keyword">get</span>(url);</span><br><span class="line">  <span class="built_in">print</span>(response.body);</span><br><span class="line">  <span class="keyword">return</span> response.body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类与对象">类与对象</h2>
<h3 id="类">类</h3>
<h4 id="简介-5">简介</h4>
<ul>
<li>类是通过 class 声明的代码段，包含属性和方法</li>
<li>对象是类的实例化结果</li>
</ul>
<h4 id="构造器">构造器</h4>
<h5 id="普通构造函数">普通构造函数</h5>
<p>默认构造函数，与类同名，在实例化时自动被调用</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  Point (<span class="built_in">num</span> x, <span class="built_in">num</span> y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 上面的构造器可以简写为下面这样</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="命名构造函数">命名构造函数</h5>
<p>在类中使用命名构造器（类型.函数名）可以实现多个构造器，可以提供额外的<strong>清晰度</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  <span class="comment">// 默认构造函数</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Point.fromJson(&#123;<span class="built_in">num</span> x = <span class="number">0</span>, <span class="built_in">num</span> y = <span class="number">0</span>&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="常量构造函数">常量构造函数</h5>
<p>如果类生成的对象<strong>不会改变</strong>（类中的属性都为常量），则可以通过常量构造函数使这些对象称为编译时常量，可以提高性能。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>() </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="comment">// 常量构造函数不能有函数体</span></span><br><span class="line">  <span class="keyword">const</span> Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 使用const关键字来通过常量构造函数构造不可变对象</span></span><br><span class="line">  <span class="keyword">var</span> p1 = <span class="keyword">const</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = <span class="keyword">const</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(p1 == p2); <span class="comment">// true</span></span><br><span class="line">  <span class="comment">// 不用const关键字，则使用的是普通构造函数</span></span><br><span class="line">  <span class="comment">// new可省略</span></span><br><span class="line">  <span class="keyword">var</span> p3 = Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> p4 = Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(p3 == p4); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="工厂构造函数">工厂构造函数</h5>
<p>工厂构造函数<strong>形式上是普通构造函数</strong>，但是通过 <code>factory</code> 声明，调用工厂构造函数不会返回自动实例对象，而是通过代码来决定返回的实例，主要用于配合实现类的<strong>单例模式</strong>，避免多次创建对象造成资源浪费，提高性能。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">static</span> Person instance; <span class="comment">// 单例</span></span><br><span class="line">  <span class="comment">// 工厂构造函数</span></span><br><span class="line">  <span class="keyword">factory</span> Person([<span class="built_in">String</span> name = <span class="string">&#x27;tom&#x27;</span>]) &#123;</span><br><span class="line">    <span class="comment">// 工厂构造函数中，不能使用this关键字</span></span><br><span class="line">    <span class="comment">// print(this.name);</span></span><br><span class="line">    <span class="comment">// 第一次实例化</span></span><br><span class="line">    <span class="keyword">if</span> (Person.name == <span class="keyword">null</span>) &#123;</span><br><span class="line">      Person.instance = <span class="keyword">new</span> Person.newSelf(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非第二次实例化</span></span><br><span class="line">    <span class="keyword">return</span> Person.instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Person.newSelf(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="访问修饰">访问修饰</h4>
<ul>
<li>Dart 与 TypeScript 不同，没有访问修饰符</li>
<li>Dart 类中，默认的访问修饰符（即不加任何内容）是公开的（public）</li>
<li>如果属性或方法以 <code>_</code> 开头，则表示为私有（private）</li>
<li><strong>只有把类单独抽离出去，私有属性和方法才起作用</strong>（即如果类写在主函数所在的文件中，私有属性和方法是不起作用的）（方法为写在另一个文件中，然后在主函数所在的文件中引用）</li>
</ul>
<h4 id="Getter-和-Setter">Getter 和 Setter</h4>
<p>Getter 是通过 <code>get</code> 关键字修饰的方法</p>
<ul>
<li>该函数不能有括号，访问时也不用加括号（即<strong>像访问属性一样访问方法</strong>）</li>
</ul>
<p>Setter 是通过 <code>set</code> 关键字修饰的方法</p>
<ul>
<li>
<p>访问时，<strong>像设置属性一样给函数传参</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> PI = <span class="number">3.1415</span>;</span><br><span class="line">  <span class="built_in">num</span> r;</span><br><span class="line">  </span><br><span class="line">  Circle(<span class="keyword">this</span>.r);</span><br><span class="line">  <span class="comment">// 使用get声明的方法不能有括号</span></span><br><span class="line">  <span class="comment">// Getter</span></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> area &#123;</span><br><span class="line">    <span class="keyword">return</span> PI * r * r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Setter</span></span><br><span class="line">  <span class="keyword">set</span> setR(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.r = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> c = Circle(<span class="number">10</span>);</span><br><span class="line">  <span class="comment">// getter调用</span></span><br><span class="line">  <span class="built_in">print</span>(c.area);</span><br><span class="line">  <span class="comment">// setter调用</span></span><br><span class="line">  c.setR = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="初始化列表">初始化列表</h4>
<ul>
<li>
<p>作用：在构造函数中设置属性的默认值</p>
</li>
<li>
<p>时机：在构造函数体执行之前执行</p>
</li>
<li>
<p>语法：使用逗号分隔初始化表达式</p>
</li>
<li>
<p>场景：常用于<strong>设置 final 常量的值</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> height;</span><br><span class="line">  <span class="built_in">int</span> width;</span><br><span class="line">  <span class="comment">// 初始化列表</span></span><br><span class="line">  Rect() : height = <span class="number">4</span>, width = <span class="number">12</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表的特殊用法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y, z;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="keyword">this</span>.z);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化列表特殊用法：重定向构造函数</span></span><br><span class="line">  Point.twoDimentionPoint(<span class="built_in">num</span> x, <span class="built_in">num</span> y) : <span class="keyword">this</span>.(x, y, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="static">static</h4>
<p><strong>与 Java 一致</strong></p>
<p><code>static</code> 关键字用来指定静态成员</p>
<ul>
<li>通过 static 修饰的属性是静态属性</li>
<li>通过 static 修饰的方法是静态方法</li>
</ul>
<p>静态成员可以通过类名直接访问（不需要实例化）</p>
<ul>
<li>实例化是比较消耗资源的，声明静态成员，可以提高程序性能</li>
</ul>
<p>静态方法不能访问非静态成员，非静态方法可以访问静态成员</p>
<ul>
<li>静态方法中不能使用 this 关键字</li>
<li>不能使用 this 关键字来访问静态属性</li>
</ul>
<h4 id="元数据">元数据</h4>
<p><strong>类似 Java 中的注解</strong></p>
<p>元数据以 @ 开头，可以给代码标记一些额外的信息</p>
<ul>
<li>元数据可以用在库、类、构造器、函数、字段、参数或变量声明的前面</li>
</ul>
<p>一些元数据</p>
<ul>
<li><code>@override</code>：表示方法重写</li>
<li><code>@required</code>：指示某个命名参数是必填的</li>
<li><code>@deprecated</code>：表示方法或类不建议使用</li>
</ul>
<h3 id="继承">继承</h3>
<p>根据类的先后顺序，可以将类分成父类和子类</p>
<p>子类通过 <code>extends</code> 关键字继承父类</p>
<ul>
<li>继承后，子类可以使用父类中可见的属性和方法</li>
</ul>
<p>子类中，可以通过 <code>@override</code> 元数据来标记 ”重写“ 的方法</p>
<ul>
<li>重写方法：子类中与父类中同名的方法</li>
</ul>
<p>子类中，可以通过 <code>super</code> 关键字来引用父类中可见的属性和方法（包括各种构造器）</p>
<h3 id="抽象类">抽象类</h3>
<p>抽象类是用 <code>abstract</code> 关键字修饰的类</p>
<p>抽象类的作用是充当普通类的<strong>模板</strong>，约定一些必要的属性和方法</p>
<p><strong>抽象方法</strong>是指<strong>没有方法体</strong>的方法</p>
<ul>
<li>抽象类中一般都有抽象方法，也可以没有抽象方法，还可以有普通方法</li>
<li>普通类中，不能有抽象方法</li>
</ul>
<p>抽象类不能被实例化</p>
<p>抽象类可以被普通类继承</p>
<ul>
<li>如果普通类继承抽象类，必须实现抽象类中<strong>所有的抽象方法</strong></li>
</ul>
<p>抽象类还可以<strong>充当接口被实现</strong></p>
<ul>
<li>如果把抽象类当作接口实现的话，普通类必须得实现抽象类里面定义的<strong>所有属性和方法</strong></li>
</ul>
<h3 id="接口">接口</h3>
<p>接口在 Dart 中就是一个类（只是用法不同）</p>
<ul>
<li>与 Java 不同，Java 中的接口需要用 interface 关键字声明，Dart 中不需要</li>
<li>接口可以是任意类，但一般使用抽象类做接口</li>
</ul>
<p>一个类可以实现（implements）多个接口，多个接口用逗号分隔</p>
<ul>
<li>接口可以看成一个个小零件。类实现接口就相当于组装零件</li>
</ul>
<p>普通类实现接口后，必须重写接口中<strong>所有的属性和方法</strong></p>
<h3 id="混入">混入</h3>
<p>混入（Mixin）是一段公共代码。混入的声明方式：</p>
<ul>
<li>使用 mixin 关键字声明 mixin MixinB {…}</li>
</ul>
<p>混入（Mixin）可以提高代码复用的效率，普通类可以通过 <code>with</code> 来使用混入</p>
<p>使用多个混入时，后引入的混入会覆盖之前混入中的重复的内容</p>
<p>混入后，可以使用混入的类中的属性和方法（Dart 单继承的补充）</p>
<h3 id="泛型">泛型</h3>
<p>泛型是在函数、类、接口中指定<strong>宽泛数据类型</strong>的语法</p>
<ul>
<li>泛型函数</li>
<li>泛型类</li>
<li>泛型接口</li>
</ul>
<p>通常，在尖括号中，使用一个字母来代表类型</p>
<p>作用：提高代码的复用性，还可以限制集合类的元素数据类型</p>
<p>除了可以指定单一数据类型外，泛型还可以<strong>限定传入的数据类型必须是某个类的子类或其本身</strong>，语法：<code>class name&lt;T extends xxx&gt; &#123;&#125;</code></p>
<h3 id="枚举">枚举</h3>
<p>枚举是数量固定的常量值，通过 <code>enum</code> 关键字声明</p>
<ul>
<li><code>enum Color &#123; red, green, blue &#125;</code></li>
</ul>
<p>枚举的 values 常量，可以获取所有枚举值列表</p>
<ul>
<li><code>List&lt;Color&gt; colors = Color.values;</code></li>
</ul>
<p>可以通过 index 获取值的索引（索引的值从 0 开始，与枚举常量声明的顺序有关）</p>
<ul>
<li><code>assert(Color.green.index == 1);</code></li>
</ul>
<h3 id="扩展（extension）">扩展（extension）</h3>
<ul>
<li>extension 关键字在 Dart 2.7 及其以上才支持</li>
<li>extension 可以扩展对象的内容
<ul>
<li>如：<code>extension StringExtension on String &#123;// 扩展内容&#125;</code></li>
<li>扩展不仅可以定义方法，还可以定义 setter, getter, operator</li>
</ul>
</li>
<li>使用
<ul>
<li>声明扩展，即上面的 <code>extension ... on ...</code> 语法</li>
<li>引入扩展，即 dart 引入包的语法，可以用相对路径，也可以用绝对路径</li>
<li>使用扩展（String.扩展内容）</li>
</ul>
</li>
</ul>
<h3 id="call-方法">call 方法</h3>
<p>在类中可以声明 call 方法（方法名不能变）</p>
<p>当我们将类的实例，当作函数来调用时，会自动调用 call 方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOSPhone</span> </span>&#123;</span><br><span class="line">  call(<span class="built_in">String</span> <span class="built_in">num</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;phone number is <span class="subst">$num</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> phone = IOSPhone();</span><br><span class="line">  <span class="comment">// 将类的实例当作函数一样调用</span></span><br><span class="line">  phone(<span class="string">&#x27;911&#x27;</span>); <span class="comment">// phone number is 911</span></span><br><span class="line">  <span class="comment">// 上面的可以简写为下面这样</span></span><br><span class="line">  IOSPhone()(<span class="string">&#x27;911&#x27;</span>); <span class="comment">// phone number is 911</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="noSuchMethod-方法">noSuchMethod 方法</h3>
<p>当我们调用了一个类的，未定义的方法时，Dart 会自动调用 noSuchMethod 方法</p>
<p>使用前提</p>
<ul>
<li>类中声明了 noSuchMethod （否则会调用默认的 noSuchMethod）</li>
<li>实例化对象必须用 dynamic 来修饰
<ul>
<li><code>dynamic p = Person();</code></li>
</ul>
</li>
<li>调用的是未定义的方法（<code>p.undefinedMethod()</code>）</li>
</ul>
<p>作用</p>
<ul>
<li>防止调用不存在的方法时报错</li>
</ul>
<h3 id="hashCode-属性">hashCode 属性</h3>
<p><strong>同 Java 中的 hashCode 方法</strong></p>
<p>hashCode 是 Dart 对象的唯一标识</p>
<p>hashCode 表现为一串数字</p>
<p>Dart 中每个对象都有 hashCode</p>
<p>我们可以通过 hashCode 来判断两个对象是否相等</p>
<h3 id="typedef">typedef</h3>
<p>typedef 可以用来自定义类型（别名），目的是让程序的可读性更强</p>
<ul>
<li>我们可以在声明泛型时，使用自定义的类型</li>
</ul>
<p>语法</p>
<ul>
<li><code>typedef function_name(parameters);</code></li>
<li><code>typedef variable_name = List&lt;int&gt;;</code></li>
</ul>
<p>版本要求</p>
<ul>
<li>
<p>Dart 版本 2.13 之前，typedef 仅限于函数类型</p>
</li>
<li>
<p>2.13 之后，typedef 可以定义非函数类型</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> MathOperation(<span class="built_in">int</span> a, <span class="built_in">int</span> b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法运算</span></span><br><span class="line">add(<span class="built_in">int</span> a, <span class="built_in">int</span> b) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;加法运算：&#x27;</span> + (a+b).toString());</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法运算</span></span><br><span class="line">sub(<span class="built_in">int</span> a, <span class="built_in">int</span> b) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;减法运算：&#x27;</span> + (a-b).toString());</span><br><span class="line">  <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个数加法</span></span><br><span class="line">add3(<span class="built_in">int</span> a, <span class="built_in">int</span> b, <span class="built_in">int</span> c) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;加法运算：&#x27;</span> + (a+b+c).toString());</span><br><span class="line">  <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(add <span class="keyword">is</span> MathOperation); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">print</span>(sub <span class="keyword">is</span> MathOperation); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">print</span>(add3 <span class="keyword">is</span> MathOperation); <span class="comment">// false</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(add <span class="keyword">is</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">print</span>(sub <span class="keyword">is</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">print</span>(add3 <span class="keyword">is</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line">  </span><br><span class="line">  MathOperation op = add;</span><br><span class="line">  op(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> MathOperation(<span class="built_in">int</span> a, <span class="built_in">int</span> b);</span><br><span class="line"></span><br><span class="line">calculator(<span class="built_in">int</span> a, <span class="built_in">int</span> b, MathOperation op) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;计算器&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> op(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  calculator(<span class="number">8</span>, <span class="number">5</span>, add); <span class="comment">// 13</span></span><br><span class="line">  calculator(<span class="number">9</span> ,<span class="number">6</span>, sub); <span class="comment">// 3</span></span><br><span class="line">  calculator(a, b, (a, b) =&gt; <span class="keyword">null</span>); <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="异步编程">异步编程</h2>
<h3 id="单线程（EventLoop）">单线程（EventLoop）</h3>
<p>Dart <strong>单线程的核心</strong>包括</p>
<ul>
<li>主线程</li>
<li>微任务</li>
<li>宏任务</li>
</ul>
<p>Dart 中的<strong>同步操作都在主线程中</strong>完成，遇到异步任务时，会将异步任务放到<strong>两个地方</strong>来完成</p>
<ul>
<li>微任务队列
<ul>
<li>微任务队列包含微任务，主要通过 scheduleMicrotask 来调度</li>
</ul>
</li>
<li>事件队列
<ul>
<li>事件队列包含外部事件，例如 I/O、Timer、绘制事件等，对应宏任务</li>
</ul>
</li>
</ul>
<p>同步与异步</p>
<ul>
<li>同步是指任务之间有<strong>强依赖关系</strong>，后一个任务依赖于前一个任务的结果，例子：4x100 米</li>
<li>异步是同步的反义词，任务之间<strong>没有明确的依赖关系</strong>，例子：100 米中有 8 个跑道</li>
</ul>
<p>Dart <strong>单线程执行流程</strong>图示：</p>
<img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/Dart%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" class="">
<p>要点：</p>
<ol>
<li>异步任务会在同步任务<strong>全部执行完</strong>（主线程结束）之后再执行</li>
<li><strong>微任务先于宏任务</strong>（事件任务）执行</li>
<li>宏任务（事件任务）中可能含有微任务（加入到微任务队列中）</li>
</ol>
<p>Dart 中的<strong>事件轮询机制</strong></p>
<ol>
<li>
<p><strong>同步任务全部执行完毕之后</strong>，事件轮询机制开始起作用</p>
</li>
<li>
<p>事件轮询机制每次会<strong>先询问微任务队列</strong>是否有任务，有的话就执行队头的微任务，没有的话就询问事件队列</p>
</li>
<li>
<p>事件队列有任务，则执行队头的事件任务，没有的话表明异步任务全部已经执行完毕，此时程序就结束了</p>
</li>
<li>
<p>可以自己对着下图推导一遍任务的执行顺序：</p>
<img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6.png" class="">
</li>
</ol>
<h3 id="Isolate-多线程">Isolate 多线程</h3>
<h4 id="介绍">介绍</h4>
<p>Isolate 是 Dart 中的现成</p>
<ul>
<li>Dart 中的线程是以**隔离（Isolate）**的方式存在的</li>
<li>每个 Isolate 都有自己独立的私有内存块（<strong>即多个线程不共享内存</strong>）</li>
<li>没有共享内存，就<strong>不需要竞争资源，就不需要锁</strong>（不用担心死锁问题）</li>
</ul>
<p>所有的 Dart 代码，都运行在 Isolate 中</p>
<ul>
<li>Isolate 提供了 Dart | Flutter 的运行环境</li>
<li>微任务队列、事件队列、事件轮询（EventLoop）都在 Isolate 中进行</li>
</ul>
<p>多线程经常用来解决耗时较长的异步任务</p>
<p>Isolate 相对于整体的位置图示：</p>
<img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/Isolate%E7%9A%84%E4%BD%8D%E7%BD%AE.png" class="">
<p>Isolate 中的内容图示：</p>
<img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/Isolate%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9.png" class="">
<p>内容包括：</p>
<ol>
<li>各种对象</li>
<li>微任务队列</li>
<li>事件队列</li>
<li>事件轮询</li>
</ol>
<h4 id="创建多线程">创建多线程</h4>
<p><strong>Isolate 类</strong>用来管理（创建、暂停、杀死）线程，常用函数有：</p>
<ul>
<li>Isolate.spawn()</li>
<li>Isolate.spawnUri()</li>
<li>Isolate.pause()</li>
<li>Isolate.kill()</li>
</ul>
<p>Isolate.spawn()</p>
<ul>
<li>
<p>函数签名：<code>Future&lt;Isolate&gt; Isolate.spawn(entryPoint, message)</code></p>
</li>
<li>
<p>使用：<code>import 'dart:isolate';</code></p>
</li>
<li>
<p><code>entryPoint</code>：进入点，是一个回调函数，必须是一个顶层方法或静态方法，必须能被访问到</p>
</li>
<li>
<p><code>message</code></p>
<ol>
<li>Dart 原始数据类型，如 null、bool、int、double、String 等</li>
<li>SendPort 实例 - ReceivePort().sendPort</li>
<li>包含 1 和 2 的 list 和 map，也可以嵌套</li>
</ol>
</li>
<li>
<p>示例程序：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:isolate&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  MultipleThread();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MultipleThread() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;MultiThread start&quot;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;当前线程名：&quot;</span> + Isolate.current.debugName);</span><br><span class="line">  </span><br><span class="line">  Isolate.spawn(newThread, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;MultiThread end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> newThread(<span class="built_in">String</span> message) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;当前线程名：&quot;</span> + Isolate.current.debugName);</span><br><span class="line">  <span class="built_in">print</span>(massage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">MultiThread start</span></span><br><span class="line"><span class="comment">当前线程名：main</span></span><br><span class="line"><span class="comment">MultiThread end</span></span><br><span class="line"><span class="comment">当前线程名：newThread</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的创建和执行也是一个异步过程，会在同步任务结束后再执行</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Isolate.spawnUri()</p>
<ul>
<li>参数：
<ul>
<li>uri：创建的新的线程的代码逻辑所在的 uri 路径</li>
<li>args：创建新的线程时要传递的参数</li>
<li>msg：创建新的线程时要传递的消息，可以是 SendPort</li>
</ul>
</li>
</ul>
<p>Isolate.compute()</p>
<ul>
<li>是对 Isolate.spawn() 的一个封装</li>
<li>使用：<code>import 'package:flutter/foundation.dart';</code></li>
</ul>
<h4 id="多线程之间的通信机制">多线程之间的通信机制</h4>
<p>Isolate 多线程之间，通信的唯一方式是 Port，有两个类可以用来实现线程间的通信</p>
<ul>
<li><strong>ReceivePort 类</strong>
<ul>
<li>初始化接收端口，创建发送端口，接收消息，监听消息，关闭端口</li>
</ul>
</li>
<li><strong>SendPort 类</strong>
<ul>
<li>将消息发送给 ReceivePort</li>
</ul>
</li>
</ul>
<p>线程之间的通信方式</p>
<ul>
<li>
<p>单向通信 （A -&gt; B）</p>
<img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/%E5%8D%95%E5%90%91%E9%80%9A%E4%BF%A1.png" class="">
<ol>
<li>发送端口是通过接收端口的 sendPort getter 方法创建的</li>
<li>创建新线程时传递的消息为发送端口实例，这样新线程就可以向根线程发送消息了</li>
</ol>
</li>
<li>
<p>双向通信（A &lt;-&gt; B）</p>
<img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1.png" class="">
<ol>
<li>创建新线程时传递的消息为发送端口实例，这样新线程就可以向根线程发送消息了</li>
<li>新线程可以自己实例化一个接收端口，然后创建这个接收端口的发送端口实例，通过根线程提供的发送端口实例<strong>将自己的发送端口实例发送给根线程</strong>，这样就建立了线程之间的双向通信了</li>
</ol>
</li>
</ul>
<h3 id="Future">Future</h3>
<h4 id="什么是-Future">什么是 Future</h4>
<p>Future 是 Dart 中的类，我们可以通过 Future 实例，封装一些异步任务</p>
<p>Future 的含义是未来，未来要执行的一些任务，我们可以放到 Future 中</p>
<p>Future 有三种状态</p>
<ul>
<li>
<p>未完成（Uncompleted）</p>
</li>
<li>
<p>已完成，并返回数据（Completed with data）</p>
</li>
<li>
<p>已完成，但返回报错（Completed with error）</p>
</li>
<li>
<p>图示：</p>
<img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/Future%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81%E5%9B%BE%E7%A4%BA.png" class="">
<p><strong>Future 相当于是一个黑盒，打开前状态不确定，打开后才确定</strong></p>
</li>
</ul>
<h4 id="获取-Future-实例">获取 Future 实例</h4>
<p>自动返回，一些 API 会返回 Future 实例</p>
<ul>
<li><code>final myFuture = http.get('https://my.image.url');</code></li>
<li><code>final myFuture = SharedPreferences.getInstance;</code></li>
</ul>
<p>手动创建，调用 Future 的 API</p>
<ul>
<li><code>final myFuture = Future( () &#123; return 123; &#125;);</code></li>
<li><code>final myFuture = Future.error(Exception());</code></li>
<li><code>final myFuture = Future.delayed(Duration(seconds: 5), () =&gt; 123);</code> 延迟一段时间后才开始执行该异步任务</li>
</ul>
<p>与 Future 的方法相关的状态</p>
<ul>
<li>
<p>创建：Uncompleted</p>
</li>
<li>
<p>then()：Completed with data，该方法拿返回数据</p>
</li>
<li>
<p>catchError()：Completed with error，该方法捕获错误</p>
</li>
<li>
<p>whenCompleted()：Completed with data + Completed with error，该方法用于做一些收尾工作</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 创建 Future 实例</span></span><br><span class="line">  <span class="keyword">final</span> f = Future( () &#123;</span><br><span class="line">    <span class="comment">// 创建该异步任务时会执行这个函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Create the future&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(f); <span class="comment">// instance of &#x27;Future&lt;int&gt;&#x27;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 接收异步任务返回的数据</span></span><br><span class="line">  f.then( (value) =&gt; <span class="built_in">print</span>(value)); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Future-执行顺序">Future 执行顺序</h4>
<p>Future 默认是异步任务，会被丢到事件队列（Event queue）中</p>
<p>Future.sync()</p>
<ul>
<li>同步任务，同步执行（不会被丢到异步队列中）</li>
</ul>
<p>Future.microtask()</p>
<ul>
<li>异步任务中的微任务，会被丢到微任务队列中，优先级比事件任务高</li>
</ul>
<p>Future.value(val)</p>
<ul>
<li>适用于可以直接拿到结果的异步操作</li>
<li>val 是常量，则创建微任务</li>
<li>val 是异步任务（如一个 Future），如果异步任务是微任务，则丢到微任务队列，如果异步任务是宏任务，则丢到事件队列</li>
</ul>
<h4 id="Future-多任务">Future 多任务</h4>
<p><code>Future.any(futures)</code></p>
<ul>
<li>返回最先完成的 Future 结果，futures 是一组 Future 任务</li>
</ul>
<p><code>Future.wait(futures)</code></p>
<ul>
<li>等待所有 Future 任务执行完成，并收集所有 Future 任务的返回结果</li>
</ul>
<p><code>Future.doWhile(action)</code></p>
<ul>
<li>按照条件遍历执行多个 Future 任务</li>
</ul>
<p><code>Future.forEach(elements, action)</code></p>
<ul>
<li>
<p>遍历一个给定的集合，根据集合元素执行多个 Future</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// doWhile方法将根据传入回调函数的返回值是ture还是false来决定是否要继续下一次循环</span></span><br><span class="line">  Future.doWhile( () &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">return</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>), () &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Future.doWhile() <span class="subst">$i</span>&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> i &lt; <span class="number">6</span>;</span><br><span class="line">    &#125;).then( (value) &#123;</span><br><span class="line">      <span class="comment">// 返回延时Future任务的布尔值，这样doWhile才可以拿到这个值判断是否还要继续</span></span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  Future.forEach([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (element) &#123;</span><br><span class="line">    <span class="keyword">return</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>), () &#123;</span><br><span class="line">      <span class="built_in">print</span>(element);</span><br><span class="line">      <span class="keyword">return</span> element;</span><br><span class="line">    &#125;).then( (value) =&gt; <span class="built_in">print</span>(element));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="FutureBuilder">FutureBuilder</h4>
<p><code>FutureBuilder</code> 是 Flutter SDK 中提供的异步组件</p>
<ul>
<li><code>FutureBuilder</code> 是一个类，可以接收 Future 任务的数据，并将数据渲染成界面</li>
<li>使用：<code>import 'package:flutter/material.dart';</code></li>
</ul>
<p><code>FutureBuilder</code> 中，有三个属性</p>
<ul>
<li>future：要完成的任务</li>
<li>initialData：初始数据</li>
<li>builder(context, <strong>snapshot</strong>)：构造器
<ul>
<li>snapshot 三种状态：
<ul>
<li><code>snapshot.connectionState</code>
<ul>
<li>ConnectionState.none（未连接异步任务）</li>
<li>ConnectionState.waiting（连接异步任务，等待交互）</li>
<li>ConnectionState.active（正在交互）</li>
<li>ConnectionState.done（异步任务完成）</li>
</ul>
</li>
<li><code>snapshot.hasData</code> (Completed with data)
<ul>
<li>snapshot.data 获取数据</li>
</ul>
</li>
<li><code>snapshot.hasError</code> (Completed with error)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Stream">Stream</h3>
<h4 id="什么是-Stream">什么是 Stream</h4>
<p>Stream 是 Dart 中的异步数据流，可以连续不断地返回多个数据</p>
<ul>
<li>Future 是异步，但只能返回一个值</li>
<li>Stream 也是异步，但可以返回多个值（数据流）</li>
</ul>
<p>Stream 相关的 API</p>
<ul>
<li>通过 listen 进行数据监听（最常用）</li>
<li>通过 error 接收失败状态</li>
<li>通过 done 接收结束状态</li>
</ul>
<p>Stream 类型</p>
<ul>
<li>
<p>Single-Subscription（单一订阅）</p>
<ul>
<li>数据流只能被 listen 一次（listen 多次会报错）</li>
<li>StreamController().stream</li>
<li>Stream stream = Stream.fromIterable(data)</li>
</ul>
</li>
<li>
<p>Broadcast（广播）</p>
<ul>
<li>数据流可以被 listen 多次</li>
<li>StreamController&lt;int&gt;.broadcast()</li>
<li>stream.asBroadcastStream()</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 单一订阅数据流</span></span><br><span class="line">  <span class="keyword">final</span> StreamController controller = StreamController();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第一次监听</span></span><br><span class="line">  controller.stream.listen( (event) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Data is <span class="subst">$event</span>&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  // 第二次监听 —— 会报错</span></span><br><span class="line"><span class="comment">  controller.stream.listen( (event) &#123;</span></span><br><span class="line"><span class="comment">    print(&quot;Data is $event&quot;);</span></span><br><span class="line"><span class="comment">  &#125;);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送数据</span></span><br><span class="line">  controller.sink.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">  controller.sink.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">Data is 123</span></span><br><span class="line"><span class="comment">Data is abc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 广播数据流</span></span><br><span class="line">  <span class="keyword">final</span> StreamController controller = StreamController.broadcast();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第一次监听</span></span><br><span class="line">  controller.stream.listen( (event) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Data1 is <span class="subst">$event</span>&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送数据</span></span><br><span class="line">  controller.sink.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第二次监听 —— 不会报错</span></span><br><span class="line">  controller.stream.listen( (event) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Data2 is <span class="subst">$event</span>&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送数据</span></span><br><span class="line">  controller.sink.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">Data1 is 123</span></span><br><span class="line"><span class="comment">Data2 is abc</span></span><br><span class="line"><span class="comment">Data1 is abc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="创建-Stream">创建 Stream</h4>
<p>StreamController 类</p>
<ul>
<li>sink：槽，用于添加数据</li>
<li>stream：流，用于取出数据</li>
<li>
<img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/StreamController.png" class="">
</li>
</ul>
<p>Stream 类</p>
<ul>
<li>Stream.fromFuture()，从单个 Future 任务中获取数据并可以读取</li>
<li>Stream.fromFutures()，从多个 Future 任务中获取数据并可以读取</li>
<li>Stream.fromIterable()，从一个可迭代的对象中获取数据并可以读取</li>
<li>Stream.periodic(Duration, computation)，周期性地获取数据并可以读取</li>
</ul>
<h4 id="操作-Stream">操作 Stream</h4>
<p>take() | takeWhile()</p>
<ul>
<li>限制获取的数据的数量，或当满足条件时才获取数据</li>
</ul>
<p>where()</p>
<ul>
<li>只获取满足条件的数据</li>
</ul>
<p>distinct()</p>
<ul>
<li>去掉数据流中<strong>连续重复</strong>的值</li>
</ul>
<p>skip() | skipWhile()</p>
<ul>
<li>跳过数据中的前几个数据，或跳过满足条件的数据</li>
</ul>
<p>map()</p>
<ul>
<li>对数据流中的每一个数据加工</li>
</ul>
<p>expand()</p>
<ul>
<li>对数据流中的每一个数据扩展为自定义的数组</li>
</ul>
<p>toSet() | toList() | toString()</p>
<p>length | first | last | isEmpty</p>
<p>firstWhere() | lastWhere()</p>
<h4 id="StreamBuilder">StreamBuilder</h4>
<p><code>StreamBuilder</code> 是 Flutter SDK 中提供的异步组件</p>
<ul>
<li><code>StreamBuilder</code> 是一个类，接收 Stream 数据，并将数据渲染成界面</li>
<li>引入：<code>import 'package:flutter/material.dart';</code></li>
</ul>
<p><code>StreamBuilder</code> 中，有三个属性，类似于 <code>FutureBuilder</code></p>
<ul>
<li>stream</li>
<li>initialData</li>
<li>builder(context, <code>snapshot</code>)</li>
</ul>
<p>作用图示：</p>
<img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/StreamBuilder%E4%BD%9C%E7%94%A8.png" class="">
<h3 id="总结">总结</h3>
<img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/Future%E4%B8%8EIsolate%E9%80%89%E6%8B%A9.png" class="">
<img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/%E5%BC%82%E6%AD%A5%E4%B8%89%E8%80%85%E6%AF%94%E8%BE%83.png" class="">
<h3 id="Async-Await">Async / Await</h3>
<p>async：标记函数是一个异步函数，其返回值类型是 Future</p>
<p>await：等待某个异步方法执行完毕</p>
<ul>
<li>用来等待耗时操作的返回结果，这个操作会<strong>阻塞到后面的代码</strong></li>
</ul>
<p>作用</p>
<ul>
<li>await 会等待异步任务执行（相当于<strong>将异步转成同步</strong>）</li>
<li>async-await 简化代码，防止回调地狱的产生</li>
</ul>
<h3 id="Generator（生成器）">Generator（生成器）</h3>
<p>什么是生成器</p>
<ul>
<li>生成器是是一种<strong>特殊的函数</strong>，返回值通过 <code>yield</code> 关键字来指定</li>
</ul>
<p>生成器的分类</p>
<ul>
<li>
<p>同步生成器（sync + yield）</p>
<ul>
<li>
<p>使用 sync*，返回的是 Iterable 对象</p>
</li>
<li>
<p>yield 会返回 moveNext 为 true，并等待 moveNext 指令</p>
</li>
<li>
<img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/image-20240407225432130.png" class="">
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> res = getNumber(<span class="number">5</span>).iterator;</span><br><span class="line">  <span class="comment">// 最终moveNext的指针指向-1位置</span></span><br><span class="line">  <span class="keyword">while</span> (res.moveNext()) &#123;</span><br><span class="line">    <span class="built_in">print</span>(res.current);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同步生成器</span></span><br><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; getNumber(<span class="built_in">int</span> n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">start</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>异步生成器（async + yield）</p>
<ul>
<li>
<p>使用 async*，返回的是 Stream 对象</p>
</li>
<li>
<p>yield 不用暂停，数据以流的方式一次性推送</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> Stream&lt;<span class="built_in">int</span>&gt; s = asyncCountDown(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">  s.listen( (event) =&gt; <span class="built_in">print</span>(event))</span><br><span class="line">    .onDone( () =&gt; <span class="built_in">print</span>(<span class="string">&quot;Done&quot;</span>));</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步生成器</span></span><br><span class="line">Stream&lt;<span class="built_in">int</span>&gt; asyncCountDown(<span class="built_in">int</span> n) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> n--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">start</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">Done</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>递归生成器（yield*）</p>
<ul>
<li>
<p>yield* 是指针，指向递归函数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; s = getRange(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">  s.forEach( (element) =&gt; <span class="built_in">print</span>(element));</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步递归生成器</span></span><br><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; getRange(<span class="built_in">int</span> start, <span class="built_in">int</span> end) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">if</span> (start &lt;= end) &#123;</span><br><span class="line">    <span class="keyword">yield</span> start;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 递归调用</span></span><br><span class="line"><span class="comment">    for (final val in getRange(start + 1, end)) &#123;</span></span><br><span class="line"><span class="comment">      yield val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面的递归调用可以简写为以下形式 </span></span><br><span class="line">    <span class="keyword">yield</span>* getRange(start + <span class="number">1</span>, end);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">start</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="库与生态">库与生态</h2>
<h3 id="简介-6">简介</h3>
<p>Dart 中的库就是具有特定功能的模块</p>
<ul>
<li>可能包含单个文件，也可能包含多个文件</li>
</ul>
<p>按照库的作者进行划分，库可以分成三类</p>
<ul>
<li>自定义库（工程师自己写的）</li>
<li>系统库（Dart 中自带的）</li>
<li>第三方库（Dart 生态中的）</li>
</ul>
<p>Dart 生态</p>
<ul>
<li>生态仓库：<a target="_blank" rel="noopener" href="https://pub.dev/">https://pub.dev/</a></li>
<li>使用 pub 命令从仓库中下载包</li>
</ul>
<h3 id="自定义库">自定义库</h3>
<h4 id="通过-library-来声明库">通过 library 来声明库</h4>
<p>每个 Dart 文件默认都是一个库，只是没有使用 library 来显式声明</p>
<p>Dart 使用 <code>_</code> 开头的标识符来表示库内访问可见（私有）</p>
<p>library 关键字声明的库名建议使用：小写字母 + 下划线</p>
<h4 id="通过-import-来引入库">通过 import 来引入库</h4>
<p>不同类型的库，引入方式不同</p>
<ul>
<li>自定义库：<code>import '库所处目录/库名称.dart'</code></li>
<li>系统库：<code>import 'dart:库名称'</code></li>
<li>第三方库：之后单独阐述</li>
</ul>
<p>引入部分库（仅引入需要的内容）</p>
<ul>
<li>包含引入（show）：跟在 show 后面的是仅引入的内容</li>
<li>排除引入（hide）：跟在 hide 后面的是不引入的内容</li>
</ul>
<p>通过指定库的前缀来避免命名冲突</p>
<ul>
<li>当库内的属性、函数名等冲突时，可以通过 <code>as</code> 关键字，给库声明一个前缀</li>
</ul>
<p>延迟引入（懒加载）</p>
<ul>
<li>
<p>使用 <code>deferred as</code> 关键字来标识需要延时加载的库</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lib/function.dart&#x27;</span> <span class="keyword">deferred</span> <span class="keyword">as</span> func;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>);</span><br><span class="line">  greet();</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future greet() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> func.loadLibrary()</span><br><span class="line">  func.hello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">hello world</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="通过-part-和-part-of-来组装库">通过 part 和 part of 来组装库</h4>
<p>图示：</p>
<img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/part%E5%92%8Cpart%20of.png" class="">
<h3 id="系统库">系统库</h3>
<h4 id="介绍-2">介绍</h4>
<p>系统库（也叫核心库）是 Dart 提供的常用内置库</p>
<ul>
<li>不需要单独下载，就可以直接使用</li>
</ul>
<p>引入</p>
<ul>
<li><code>import 'dart:库名'</code></li>
<li><code>dart:core</code> 会自动引入，无需手动引入</li>
</ul>
<p>系统库列表</p>
<ul>
<li>async</li>
<li>collection</li>
<li>convert</li>
<li>core</li>
<li>developer</li>
<li>math</li>
<li>…</li>
</ul>
<h3 id="第三方库">第三方库</h3>
<p>来源</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://pub.dev">https://pub.dev</a></li>
<li><a target="_blank" rel="noopener" href="https://pub.flutter-io.cn/packages">https://pub.flutter-io.cn/packages</a></li>
<li><a target="_blank" rel="noopener" href="https://pub.dartlang.org/flutter">https://pub.dartlang.org/flutter</a></li>
</ul>
<p>使用</p>
<ul>
<li>在项目目录下创建 <code>pubspec.yaml</code></li>
<li>在 <code>pubspec.yaml</code> 中声明第三方库（依赖）</li>
<li>在命令行中进入 <code>pubspec.yaml</code> 所在目录，执行 <code>pub get</code> 进行安装</li>
<li>在项目中引入第三方库 <code>import 'package:xxx/xxx.dart'</code></li>
</ul>
<p>第三方库的结构</p>
<ul>
<li>
<p>一个第三方库，必须包含一个 <code>pubspec.yaml</code></p>
<img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/dart%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" class=""></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://FutureYL3.github.io">yl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://futureyl3.github.io/2025/03/02/Dart-Programming-Language-Basic-Syntax/">https://futureyl3.github.io/2025/03/02/Dart-Programming-Language-Basic-Syntax/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Dart/">Dart</a><a class="post-meta__tags" href="/tags/Basic-Syntax/">Basic Syntax</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/02/JSR-380-Java-Bean-Validation/" title="JSR 380 Java Bean Validation"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">JSR 380 Java Bean Validation</div></div><div class="info-2"><div class="info-item-1">Introduce how to add and use "Hibernate-Validator" Bean Validation Framework in Java Spring Boot Web Project.</div></div></div></a><a class="pagination-related" href="/2025/03/02/Java-Programming-Language/" title="Java Programming Language"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Java Programming Language</div></div><div class="info-2"><div class="info-item-1">To lay great foundation for programming in Java.</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/kano.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yl</div><div class="author-info-description">Student at Harbin Institute of Technology (HIT) / Major in Software Engineering</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/FutureYL3" target="_blank" title="My GitHub Profile"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/310715755" target="_blank" title="My Bilibili Space"><i class="fa-brands fa-bilibili" style="color: #00a1d6;"></i></a><a class="social-icon" href="/future_yl@outlook.com" target="_blank" title="My Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Dart</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dart-%E4%B8%8E-JavaScript"><span class="toc-text">Dart 与 JavaScript</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dart-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">Dart 基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E4%BE%8B"><span class="toc-text">引例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C"><span class="toc-text">运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-text">常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Number"><span class="toc-text">Number</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dart-%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E7%94%B1%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E6%8F%8F%E8%BF%B0"><span class="toc-text">Dart 中的数字由三个关键字描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-API%EF%BC%9A%E5%9C%A8%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%9F%A5%E9%98%85"><span class="toc-text">常用 API：在官方文档中查阅</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-String-%E5%A3%B0%E6%98%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">使用 String 声明字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-API%EF%BC%9A%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%9F%A5%E9%98%85"><span class="toc-text">常用 API：官方文档查阅</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">正则表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boolean"><span class="toc-text">Boolean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dart-%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E7%94%B1-List-%E5%AF%B9%E8%B1%A1%E8%A1%A8%E7%A4%BA%E3%80%82List-%E6%9C%89%E4%B8%A4%E7%A7%8D%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F"><span class="toc-text">Dart 中的数组，由 List 对象表示。List 有两种声明方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E2%80%A6%EF%BC%89"><span class="toc-text">扩展操作符（…）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-API%EF%BC%9A%E6%9F%A5%E9%98%85%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3"><span class="toc-text">常用 API：查阅官方文档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8"><span class="toc-text">遍历列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-API-%E6%9F%A5%E9%98%85%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3"><span class="toc-text">常用 API 查阅官方文档</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-API-%E6%9F%A5%E9%98%85%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-2"><span class="toc-text">常用 API 查阅官方文档</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Runes"><span class="toc-text">Runes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol"><span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dynamic"><span class="toc-text">dynamic</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E6%9D%BF%E9%99%A4%EF%BC%88-%EF%BC%89"><span class="toc-text">地板除（~&#x2F;）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88is-%E5%92%8C-is-%EF%BC%89"><span class="toc-text">类型判断运算符（is 和 is!）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E7%A9%BA%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%E5%92%8C-%EF%BC%89"><span class="toc-text">避空运算符（?? 和 ??&#x3D;）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%EF%BC%88-%EF%BC%89"><span class="toc-text">条件属性访问（?.）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A7%E8%81%94%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E2%80%A6%EF%BC%89"><span class="toc-text">级联运算符（…）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%87%BD%E6%95%B0"><span class="toc-text">声明函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%A3%B0%E6%98%8E"><span class="toc-text">直接声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-text">立即执行函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%85%E5%A1%AB%E5%8F%82%E6%95%B0"><span class="toc-text">必填参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-text">可选参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="toc-text">命名参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-2"><span class="toc-text">函数参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85"><span class="toc-text">作用域与闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0"><span class="toc-text">异步函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%9C"><span class="toc-text">接收处理异步结果</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-then"><span class="toc-text">使用 then</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-async-%E5%92%8C-await"><span class="toc-text">使用 async 和 await</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-text">类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">普通构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">命名构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">常量构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">工厂构造函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0"><span class="toc-text">访问修饰</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Getter-%E5%92%8C-Setter"><span class="toc-text">Getter 和 Setter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static"><span class="toc-text">static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-text">元数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%85%A5"><span class="toc-text">混入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%88extension%EF%BC%89"><span class="toc-text">扩展（extension）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-%E6%96%B9%E6%B3%95"><span class="toc-text">call 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#noSuchMethod-%E6%96%B9%E6%B3%95"><span class="toc-text">noSuchMethod 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode-%E5%B1%9E%E6%80%A7"><span class="toc-text">hashCode 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typedef"><span class="toc-text">typedef</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-text">异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%88EventLoop%EF%BC%89"><span class="toc-text">单线程（EventLoop）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Isolate-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">Isolate 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">创建多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="toc-text">多线程之间的通信机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future"><span class="toc-text">Future</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Future"><span class="toc-text">什么是 Future</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-Future-%E5%AE%9E%E4%BE%8B"><span class="toc-text">获取 Future 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Future-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">Future 执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Future-%E5%A4%9A%E4%BB%BB%E5%8A%A1"><span class="toc-text">Future 多任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FutureBuilder"><span class="toc-text">FutureBuilder</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream"><span class="toc-text">Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Stream"><span class="toc-text">什么是 Stream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Stream"><span class="toc-text">创建 Stream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C-Stream"><span class="toc-text">操作 Stream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StreamBuilder"><span class="toc-text">StreamBuilder</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Async-Await"><span class="toc-text">Async &#x2F; Await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generator%EF%BC%88%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%89"><span class="toc-text">Generator（生成器）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E4%B8%8E%E7%94%9F%E6%80%81"><span class="toc-text">库与生态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-6"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%93"><span class="toc-text">自定义库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-library-%E6%9D%A5%E5%A3%B0%E6%98%8E%E5%BA%93"><span class="toc-text">通过 library 来声明库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-import-%E6%9D%A5%E5%BC%95%E5%85%A5%E5%BA%93"><span class="toc-text">通过 import 来引入库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-part-%E5%92%8C-part-of-%E6%9D%A5%E7%BB%84%E8%A3%85%E5%BA%93"><span class="toc-text">通过 part 和 part of 来组装库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%BA%93"><span class="toc-text">系统库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><span class="toc-text">第三方库</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/Web-Development-Sky-Takeout/" title="Web Development -- Sky Takeout">Web Development -- Sky Takeout</a><time datetime="2025-03-02T10:51:57.000Z" title="Created 2025-03-02 18:51:57">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/Springfox-Swagger/" title="Springfox Swagger">Springfox Swagger</a><time datetime="2025-03-02T10:42:33.000Z" title="Created 2025-03-02 18:42:33">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/Database-and-SQL-Basic-Concepts-and-Usage/" title="Database and SQL: Basic Concepts and Usage">Database and SQL: Basic Concepts and Usage</a><time datetime="2025-03-02T10:29:51.000Z" title="Created 2025-03-02 18:29:51">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/MyBatis-Plus-Basic-Usage/" title="MyBatis Plus Basic Usage">MyBatis Plus Basic Usage</a><time datetime="2025-03-02T10:19:09.000Z" title="Created 2025-03-02 18:19:09">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/MIT-The-Missing-Semester-Lec10-Potpourri/" title="[MIT The Missing Semester] Lec10: Potpourri">[MIT The Missing Semester] Lec10: Potpourri</a><time datetime="2025-03-02T10:10:46.000Z" title="Created 2025-03-02 18:10:46">2025-03-02</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(to right, rgb(198, 255, 221), rgb(251, 215, 134), rgb(247, 121, 125));"><div id="footer-wrap"><div class="copyright">&copy;2025 By yl</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search through all posts and pages" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>