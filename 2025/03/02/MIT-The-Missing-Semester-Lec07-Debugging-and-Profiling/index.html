<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>[MIT The Missing Semester] Lec07: Debugging and Profiling | yl's blog</title><meta name="author" content="yl"><meta name="copyright" content="yl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Teach how to debug a program including print, log and gdb and how to profile a program using various tools and approaches.">
<meta property="og:type" content="article">
<meta property="og:title" content="[MIT The Missing Semester] Lec07: Debugging and Profiling">
<meta property="og:url" content="https://futureyl3.github.io/2025/03/02/MIT-The-Missing-Semester-Lec07-Debugging-and-Profiling/">
<meta property="og:site_name" content="yl&#39;s blog">
<meta property="og:description" content="Teach how to debug a program including print, log and gdb and how to profile a program using various tools and approaches.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://futureyl3.github.io/img/kano.JPG">
<meta property="article:published_time" content="2025-03-02T09:58:00.000Z">
<meta property="article:modified_time" content="2025-03-02T09:58:00.000Z">
<meta property="article:author" content="yl">
<meta property="article:tag" content="Debug">
<meta property="article:tag" content="Profile">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://futureyl3.github.io/img/kano.JPG"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[MIT The Missing Semester] Lec07: Debugging and Profiling",
  "url": "https://futureyl3.github.io/2025/03/02/MIT-The-Missing-Semester-Lec07-Debugging-and-Profiling/",
  "image": "https://futureyl3.github.io/img/kano.JPG",
  "datePublished": "2025-03-02T09:58:00.000Z",
  "dateModified": "2025-03-02T09:58:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "yl",
      "url": "https://futureyl3.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://futureyl3.github.io/2025/03/02/MIT-The-Missing-Semester-Lec07-Debugging-and-Profiling/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '[MIT The Missing Semester] Lec07: Debugging and Profiling',
  isHighlightShrink: undefined,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/kano.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(to right, rgb(198, 255, 221), rgb(251, 215, 134), rgb(247, 121, 125));"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yl's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">[MIT The Missing Semester] Lec07: Debugging and Profiling</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">[MIT The Missing Semester] Lec07: Debugging and Profiling</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-02T09:58:00.000Z" title="Created 2025-03-02 17:58:00">2025-03-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-02T09:58:00.000Z" title="Updated 2025-03-02 17:58:00">2025-03-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/The-Missing-Semester/">The Missing Semester</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">6.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>21mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>Lec07：调试及性能分析</h1>
<p>本 Lec 的主要内容：</p>
<ul>
<li>学习如何在命令行中调试代码
<ul>
<li>打印调试法</li>
<li>日志调试法</li>
<li>调试器调试法
<ul>
<li>源代码调试</li>
<li>二进制代码调试</li>
</ul>
</li>
<li>静态分析工具调试</li>
</ul>
</li>
<li>如何进行性能分析
<ul>
<li>计时分析性能</li>
<li>CPU、内存、事件性能分析</li>
<li>一系列资源监控工具</li>
</ul>
</li>
</ul>
<h2 id="调试代码">调试代码</h2>
<h3 id="打印调试法与日志">打印调试法与日志</h3>
<p>“最有效的 debug 工具就是细致的分析，配合恰当位置的打印语句” — Brian Kernighan, <em>Unix 新手入门</em>。</p>
<p>调试代码的第一种方法往往是在你发现问题的地方添加一些打印语句，然后不断重复此过程直到你获取了足够的信息并找到问题的根本原因。</p>
<p>另外一个方法是使用日志，而不是临时添加打印语句。日志较普通的打印语句有如下的一些优势：</p>
<ul>
<li>你可以将<strong>日志写入文件、socket 或者甚至是发送到远端服务器</strong>而不仅仅是标准输出；</li>
<li>日志可以<strong>支持严重等级</strong>（例如 INFO, DEBUG, WARN, ERROR 等），这使你可以根据需要过滤日志；</li>
<li>对于<strong>新发现的问题</strong>，很可能你的日志中已经包含了可以帮助你定位问题的足够的信息。</li>
</ul>
<p>有很多技巧可以使日志的可读性变得更好，一个技巧是对其进行==着色==。到目前为止，你应该已经知道，以彩色文本显示终端信息时可读性更好。但是应该如何设置呢？</p>
<p><code>ls</code> 和 <code>grep</code> 这样的程序会使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape codes</a>，它是一系列的特殊字符，可以使你的 shell 改变输出结果的颜色。例如，执行 <code>echo -e &quot;\e[38;2;255;0;0mThis is red\e[0m&quot;</code> 会打印红色的字符串：<code>This is red</code> ，只要你的终端支持<a target="_blank" rel="noopener" href="https://gist.github.com/XVilka/8346728#terminals--true-color">真彩色</a>。如果你的终端不支持真彩色（例如 MacOS 的 Terminal.app），你可以使用支持更加广泛的 16 色，例如：<code>\e[31;1mThis is red\e[0m</code>。</p>
<p>下面这个脚本向你展示了如何在终端中打印多种颜色（只要你的终端支持真彩色）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="keyword">for</span> R <span class="keyword">in</span> $(<span class="built_in">seq</span> 0 20 255); <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> G <span class="keyword">in</span> $(<span class="built_in">seq</span> 0 20 255); <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> B <span class="keyword">in</span> $(<span class="built_in">seq</span> 0 20 255); <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">printf</span> <span class="string">&quot;\e[38;2;<span class="variable">$&#123;R&#125;</span>;<span class="variable">$&#123;G&#125;</span>;<span class="variable">$&#123;B&#125;</span>m█\e[0m&quot;</span>;</span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="第三方日志系统">第三方日志系统</h3>
<p>如果你正在构建大型软件系统，你很可能会使用到一些依赖，有些依赖会作为程序单独运行。如 Web 服务器、数据库或消息代理都是此类常见的第三方依赖。</p>
<p>和这些系统交互的时候，阅读它们的日志是非常必要的，因为仅靠客户端侧的错误信息可能并不足以定位问题。</p>
<p>幸运的是，大多数的程序都会将日志保存在你的系统中的某个地方。**对于 UNIX 系统来说，程序的日志通常存放在 <code>/var/log</code>。**例如， <a target="_blank" rel="noopener" href="https://www.nginx.com/">NGINX</a> web 服务器就将其日志存放于<code>/var/log/nginx</code>。</p>
<p>目前，系统开始使用 <strong>system log</strong>，你所有的日志都会保存在这里。**大多数（但不是全部的）Linux 系统都会使用 <code>systemd</code>，**这是一个系统守护进程，它会控制你系统中的很多东西，例如哪些服务应该启动并运行。<code>systemd</code> 会将日志以某种特殊格式存放于<code>/var/log/journal</code>，你可以使用 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man1/journalctl.1.html"><code>journalctl</code></a> 命令显示这些消息。</p>
<p>类似地，在 macOS 系统中是 <code>/var/log/system.log</code>，但是有更多的工具会使用系统日志，它的内容可以使用 <a target="_blank" rel="noopener" href="https://www.manpagez.com/man/1/log/"><code>log show</code></a> 显示。</p>
<p>对于大多数的 UNIX 系统，你也可以使用 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man1/dmesg.1.html"><code>dmesg</code></a> 命令来读取内核的日志。</p>
<p>如果你希望将日志加入到系统日志中，你可以使用 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man1/logger.1.html"><code>logger</code></a> 这个 shell 程序。下面这个例子显示了如何使用  <code>logger</code> 并且如何找到能够将其存入系统日志的条目。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">logger <span class="string">&quot;Hello Logs&quot;</span></span><br><span class="line"><span class="comment"># On macOS</span></span><br><span class="line"><span class="built_in">log</span> show --last 1m | grep Hello</span><br><span class="line"><span class="comment"># On Linux</span></span><br><span class="line">journalctl --since <span class="string">&quot;1m ago&quot;</span> | grep Hello</span><br></pre></td></tr></table></figure>
<p>不仅如此，大多数的编程语言都支持向系统日志中写日志。</p>
<p>正如我们在数据整理那节课上看到的那样，日志的内容可以非常的多，我们需要对其进行处理和过滤才能得到我们想要的信息。</p>
<p>如果你发现你需要对 <code>journalctl</code> 和 <code>log show</code> 的结果进行大量的过滤，那么此时可以考虑使用它们自带的选项对其结果先过滤一遍再输出。还有一些像 <a target="_blank" rel="noopener" href="http://lnav.org/"><code>lnav</code></a> 这样的工具，它为日志文件提供了更好的展现和浏览方式。</p>
<h3 id="调试器">调试器</h3>
<p><strong>当通过打印已经不能满足你的调试需求时，你应该使用调试器。</strong></p>
<p>调试器是一种可以允许我们<strong>和正在执行的程序进行交互的程序</strong>，它可以做到：</p>
<ul>
<li>当到达某一行时将程序暂停；</li>
<li>一次一条指令地逐步执行程序；</li>
<li>程序崩溃后查看变量的值；</li>
<li>满足特定条件时暂停程序；</li>
<li>其他高级功能。</li>
</ul>
<p>很多编程语言都有自己的调试器。Python 的调试器是 <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/pdb.html"><code>pdb</code></a>.</p>
<p>下面对 <code>pdb</code> 支持的命令进行简单的介绍：</p>
<ul>
<li><strong>l</strong>(ist) - 显示当前行附近的 11 行或继续执行之前的显示；
<ul>
<li><strong>ll</strong> - 显示当前所在函数的整个函数体</li>
</ul>
</li>
<li><strong>s</strong>(tep) - 执行当前行，并在第一个可能的地方停止（也可以理解为进入函数内部）；</li>
<li><strong>n</strong>(ext) - 继续执行直到当前函数的下一条语句或者 return 语句（就是执行当前语句，然后到下一条语句）；</li>
<li><strong>b</strong>(reak) - 设置断点（基于传入的参数）；
<ul>
<li><strong>cl &lt;断点id&gt;</strong> - 清除断点</li>
<li><strong>c</strong>(ontinue) - 继续执行直到下一个端点</li>
</ul>
</li>
<li><strong>p</strong>(rint) - 在当前上下文对表达式求值并打印结果。还有一个命令是 <strong>pp</strong> ，它使用 <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/pprint.html"><code>pprint</code></a> 打印；</li>
<li><strong>r</strong>(eturn) - 继续执行直到当前函数返回；</li>
<li><strong>!</strong> - 后面接 <code>python</code> 语句，可以直接像在 <code>python</code> 命令行界面一样执行语句；</li>
<li><strong>q</strong>(uit) - 退出调试器。</li>
</ul>
<p>注意，因为 Python 是一种解释型语言，所以我们可以通过 <code>pdb</code> shell 执行命令。 <a target="_blank" rel="noopener" href="https://pypi.org/project/ipdb/"><code>ipdb</code></a> 是一种增强型的 <code>pdb</code> ，它使用 <a target="_blank" rel="noopener" href="https://ipython.org/"><code>IPython</code></a> 作为 REPL并开启了 tab 补全、语法高亮、更好的回溯和更好的内省，同时还保留了 <code>pdb</code> 模块相同的接口。</p>
<p>对于更底层的编程语言，你可能需要了解一下 <a target="_blank" rel="noopener" href="https://www.gnu.org/software/gdb/"><code>gdb</code></a> ( 以及它的改进版 <a target="_blank" rel="noopener" href="https://github.com/pwndbg/pwndbg"><code>pwndbg</code></a>) 和 <a target="_blank" rel="noopener" href="https://lldb.llvm.org/"><code>lldb</code></a>。</p>
<p>它们都对类 C 语言的调试进行了优化，它允许你探索任意进程及其机器状态：寄存器、堆栈、程序计数器等。</p>
<blockquote>
<p>截至目前（2024.07.18），<code>gdb</code> 仅支持 x86 平台。</p>
</blockquote>
<h3 id="二进制程序调试">二进制程序调试</h3>
<p>即使你需要调试的程序是一个二进制的黑盒程序，仍然有一些工具可以帮助到你。当你的程序需要执行一些只有操作系统内核才能完成的操作时，它需要使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/System_call">系统调用</a>。有一些命令可以帮助你追踪你的程序执行的系统调用。在 Linux 中可以使用 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man1/strace.1.html"><code>strace</code></a> ，在 macOS 和 BSD 中可以使用 <a target="_blank" rel="noopener" href="http://dtrace.org/blogs/about/"><code>dtrace</code></a>。<code>dtrace</code> 用起来可能有些别扭，因为它使用的是它自有的 <code>D</code> 语言，但是我们可以使用一个叫做 <a target="_blank" rel="noopener" href="https://www.manpagez.com/man/1/dtruss/"><code>dtruss</code></a> 的封装使其具有和 <code>strace</code> （更多信息参考 <a target="_blank" rel="noopener" href="https://8thlight.com/blog/colin-jones/2015/11/06/dtrace-even-better-than-strace-for-osx.html">这里</a>）类似的接口</p>
<p>下面的例子展现来如何使用 <code>strace</code> 或 <code>dtruss</code> 来显示 <code>ls</code> 执行时，对 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/stat.2.html"><code>stat</code></a> 系统调用进行追踪对结果。若需要深入了解 <code>strace</code>，<a target="_blank" rel="noopener" href="https://blogs.oracle.com/linux/strace-the-sysadmins-microscope-v2">这篇文章</a> 值得一读。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># On Linux</span></span><br><span class="line"><span class="built_in">sudo</span> strace -e lstat <span class="built_in">ls</span> -l &gt; /dev/null</span><br><span class="line">4</span><br><span class="line"><span class="comment"># On macOS</span></span><br><span class="line"><span class="built_in">sudo</span> dtruss -t lstat64_extended <span class="built_in">ls</span> -l &gt; /dev/null</span><br></pre></td></tr></table></figure>
<h3 id="网络调试">网络调试</h3>
<p>有些情况下，我们需要查看网络数据包才能定位问题。像 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man1/tcpdump.1.html"><code>tcpdump</code></a> 和 <a target="_blank" rel="noopener" href="https://www.wireshark.org/">Wireshark</a> 这样的网络数据包分析工具可以帮助你获取网络数据包的内容并基于不同的条件进行过滤。</p>
<p>对于 web 开发， Chrome/Firefox 的开发者工具非常方便，功能也很强大：</p>
<ul>
<li>源码 -查看任意站点的 HTML/CSS/JS 源码；</li>
<li>实时地修改 HTML, CSS, JS 代码 - 修改网站的内容、样式和行为用于测试（从这一点你也能看出来，网页截图是不可靠的）；</li>
<li>Javascript shell - 在 JS REPL中执行命令；</li>
<li>网络 - 分析请求的时间线；</li>
<li>存储 - 查看 Cookies 和本地应用存储。</li>
</ul>
<h3 id="代码静态分析工具">代码静态分析工具</h3>
<p>有些问题是你不需要执行代码就能发现的。例如，仔细观察一段代码，你就能发现某个循环变量覆盖了某个已经存在的变量或函数名；或是有个变量在被读取之前并没有被定义。 这种情况下 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Static_program_analysis">静态分析</a> 工具就可以帮我们找到问题。<strong>静态分析会将程序的源码作为输入然后基于编码规则对其进行分析并对代码的正确性进行推理。</strong></p>
<p>下面这段 Python 代码中存在几个问题。 首先，我们的循环变量 <code>foo</code> 覆盖了之前定义的函数 <code>foo</code>。最后一行，我们还把 <code>bar</code> 错写成了 <code>baz</code>，因此当程序完成 <code>sleep</code> （一分钟）后，执行到这一行的时候便会崩溃。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> foo <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(foo)</span><br><span class="line">bar = <span class="number">1</span></span><br><span class="line">bar *= <span class="number">0.2</span></span><br><span class="line">time.sleep(<span class="number">60</span>)</span><br><span class="line"><span class="built_in">print</span>(baz)</span><br></pre></td></tr></table></figure>
<p>静态分析工具可以发现此类的问题。当我们使用 <a target="_blank" rel="noopener" href="https://pypi.org/project/pyflakes"><code>pyflakes</code></a> 分析代码的时候，我们会得到与这两处 bug 相关的错误信息。<a target="_blank" rel="noopener" href="http://mypy-lang.org/"><code>mypy</code></a> 则是另外一个工具，它可以对代码进行类型检查。这里，<code>mypy</code> 会警告我们 <code>bar</code> 起初是一个 <code>int</code> ，然后变成了 <code>float</code>。这些问题都可以在不运行代码的情况下被发现。</p>
<p>在 shell 工具那一节课的时候，我们介绍了 <a target="_blank" rel="noopener" href="https://www.shellcheck.net/"><code>shellcheck</code></a>，这是一个类似的工具，但它是应用于 shell 脚本的。</p>
<p>大多数的编辑器和 IDE 都支持<strong>在编辑界面显示这些工具的分析结果、高亮有警告和错误的位置</strong>。 这个过程通常称为 <strong>code linting</strong> 。<em>风格检查或安全检查</em> 的结果同样也可以进行相应的显示。</p>
<p>在 vim 中，有 <a target="_blank" rel="noopener" href="https://vimawesome.com/plugin/ale"><code>ale</code></a> 或 <a target="_blank" rel="noopener" href="https://vimawesome.com/plugin/syntastic"><code>syntastic</code></a> 可以帮助你做同样的事情。 在 Python 中， <a target="_blank" rel="noopener" href="https://www.pylint.org/"><code>pylint</code></a> 和 <a target="_blank" rel="noopener" href="https://pypi.org/project/pep8/"><code>pep8</code></a> 是两种用于进行风格检查的工具，而 <a target="_blank" rel="noopener" href="https://pypi.org/project/bandit/"><code>bandit</code></a> 工具则用于检查安全相关的问题。</p>
<p>对于其他语言的开发者来说，静态分析工具可以参考这个列表：<a target="_blank" rel="noopener" href="https://github.com/mre/awesome-static-analysis">Awesome Static Analysis</a> （你也许会对 <em>Writing</em> 一节感兴趣）。对于 linters 则可以参考这个列表： <a target="_blank" rel="noopener" href="https://github.com/caramelomartins/awesome-linters">Awesome Linters</a>。</p>
<p>对于风格检查和代码格式化，还有以下一些工具可以作为补充：</p>
<ul>
<li>用于 Python 的 <a target="_blank" rel="noopener" href="https://github.com/psf/black"><code>black</code></a>、</li>
<li>用于 Go 语言的 <code>gofmt</code>、</li>
<li>用于 Rust 的 <code>rustfmt</code> 或是</li>
<li>用于 JavaScript, HTML 和 CSS 的 <a target="_blank" rel="noopener" href="https://prettier.io/"><code>prettier</code></a> 。</li>
</ul>
<p>这些工具可以自动格式化你的代码，这样代码风格就可以与常见的风格保持一致。 尽管你可能并不想对代码进行风格控制，标准的代码风格有助于方便别人阅读你的代码，也可以方便你阅读它的代码。</p>
<h2 id="性能分析">性能分析</h2>
<p>即使你的代码能够像你期望的一样运行，但是如果它消耗了你全部的 CPU 和内存，那么它显然也不是个好程序。算法课上我们通常会介绍大O标记法，但却没教给我们如何找到程序中的热点（即最消耗资源的部分）。 鉴于 <a target="_blank" rel="noopener" href="http://wiki.c2.com/?PrematureOptimization">过早的优化是万恶之源</a>，你需要学习性能分析和监控工具，它们会帮助你找到程序中最耗时、最耗资源的部分，这样你就可以有针对性的进行性能优化。</p>
<h3 id="计时">计时</h3>
<p>计时和调试代码类似，大多数情况下我们只需要打印两处代码之间的时间即可发现问题。下面这个例子中，我们使用了 Python 的 <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/time.html"><code>time</code></a>模块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line">n = random.randint(<span class="number">1</span>, <span class="number">10</span>) * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间 </span></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一些操作</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sleeping for &#123;&#125; ms&quot;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">time.sleep(n/<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较当前时间和起始时间</span></span><br><span class="line"><span class="built_in">print</span>(time.time() - start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Sleeping for 500 ms</span></span><br><span class="line"><span class="comment"># 0.5713930130004883</span></span><br></pre></td></tr></table></figure>
<p>不过，执行时间（wall clock time）也可能会误导你，因为你的电脑可能也在同时运行其他进程，也可能在此期间发生了等待。 对于工具来说，需要区分真实时间、用户时间和系统时间。通常来说，用户时间+系统时间代表了你的进程所消耗的实际 CPU 时间（更详细的解释可以参照<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1">这篇文章</a>）。</p>
<ul>
<li>真实时间 - 从程序开始到结束流失掉的真实时间，包括其他进程的执行时间以及阻塞消耗的时间（例如等待  I/O 或网络）；</li>
<li><em>User</em> - CPU 执行用户代码所花费的时间；</li>
<li><em>Sys</em> - CPU 执行系统内核代码所花费的时间。</li>
</ul>
<p>例如，试着执行一个用于发起 HTTP 请求的命令并在其前面添加 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man1/time.1.html"><code>time</code></a> 前缀。网络不好的情况下你可能会看到下面的输出结果。请求花费了 2s 才完成，但是进程仅花费了 15ms 的 CPU 用户时间和 12ms 的 CPU 内核时间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">time</span> curl https://missing.csail.mit.edu &amp;&gt; /dev/null</span><br><span class="line">real    0m2.561s</span><br><span class="line">user    0m0.015s</span><br><span class="line">sys     0m0.012s</span><br></pre></td></tr></table></figure>
<h3 id="性能分析工具">性能分析工具</h3>
<h4 id="CPU">CPU</h4>
<p>大多数情况下，当人们提及性能分析工具的时候，通常指的是 CPU 性能分析工具。</p>
<p><strong>CPU 性能分析工具有两种： 追踪分析器（<em>tracing</em>）及采样分析器（<em>sampling</em>）</strong>。 追踪分析器 会记录程序的每一次函数调用，而采样分析器则只会周期性的监测（通常为每毫秒）你的程序并记录程序堆栈。它们使用这些记录来生成统计信息，显示程序在哪些事情上花费了最多的时间。如果你希望了解更多相关信息，可以参考 <a target="_blank" rel="noopener" href="https://jvns.ca/blog/2017/12/17/how-do-ruby---python-profilers-work-">这篇</a> 介绍性的文章。</p>
<p>大多数的编程语言都有一些基于命令行的分析器，我们可以使用它们来分析代码。它们通常可以集成在 IDE 中，但是本节课我们会专注于这些命令行工具本身。</p>
<p>在 Python 中，我们使用 <code>cProfile</code> 模块来分析每次函数调用所消耗的时间。 在下面的例子中，我们实现了一个基础的 grep 命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grep</span>(<span class="params">pattern, file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(file)</span><br><span class="line">        <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f.readlines()):</span><br><span class="line">            pattern = re.<span class="built_in">compile</span>(pattern)</span><br><span class="line">            <span class="keyword">match</span> = pattern.search(line)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">match</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, line), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    times = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    pattern = sys.argv[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> sys.argv[<span class="number">3</span>:]:</span><br><span class="line">            grep(pattern, file)</span><br></pre></td></tr></table></figure>
<p>我们可以使用下面的命令来对这段代码进行分析。通过它的输出我们可以知道，IO 消耗了大量的时间，编译正则表达式也比较耗费时间。因为正则表达式只需要编译一次，我们可以将其移动到 for 循环外面来改进性能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python -m cProfile -s tottime grep.py 1000 <span class="string">&#x27;^(import|\s*def)[^,]*$&#x27;</span> *.py</span><br><span class="line"></span><br><span class="line">[omitted program output]</span><br><span class="line"></span><br><span class="line"> ncalls  tottime  percall  cumtime  percall filename:lineno(<span class="keyword">function</span>)</span><br><span class="line">   8000    0.266    0.000    0.292    0.000 &#123;built-in method io.open&#125;</span><br><span class="line">   8000    0.153    0.000    0.894    0.000 grep.py:5(grep)</span><br><span class="line">  17000    0.101    0.000    0.101    0.000 &#123;built-in method builtins.print&#125;</span><br><span class="line">   8000    0.100    0.000    0.129    0.000 &#123;method <span class="string">&#x27;readlines&#x27;</span> of <span class="string">&#x27;_io._IOBase&#x27;</span> objects&#125;</span><br><span class="line">  93000    0.097    0.000    0.111    0.000 re.py:286(_compile)</span><br><span class="line">  93000    0.069    0.000    0.069    0.000 &#123;method <span class="string">&#x27;search&#x27;</span> of <span class="string">&#x27;_sre.SRE_Pattern&#x27;</span> objects&#125;</span><br><span class="line">  93000    0.030    0.000    0.141    0.000 re.py:231(compile)</span><br><span class="line">  17000    0.019    0.000    0.029    0.000 codecs.py:318(decode)</span><br><span class="line">      1    0.017    0.017    0.911    0.911 grep.py:3(&lt;module&gt;)</span><br><span class="line"></span><br><span class="line">[omitted lines]</span><br></pre></td></tr></table></figure>
<p>关于 Python 的 <code>cProfile</code> 分析器（以及其他一些类似的分析器），<strong>需要注意的是它显示的是每次函数调用的时间</strong>。看上去可能快到反直觉，尤其是如果你在代码里面使用了第三方的函数库，因为内部函数调用也会被看作函数调用。</p>
<p>更加符合直觉的显示分析信息的方式是包括<strong>每行代码的执行时间</strong>，这也是 <em>行分析器</em>（line profiler） 的工作。例如，下面这段 Python 代码会向本课程的网站发起一个请求，然后解析响应返回的页面中的全部 URL：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个装饰器会告诉行分析器 </span></span><br><span class="line"><span class="comment"># 我们想要分析这个函数</span></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_urls</span>():</span><br><span class="line">    response = requests.get(<span class="string">&#x27;https://missing.csail.mit.edu&#x27;</span>)</span><br><span class="line">    s = BeautifulSoup(response.content, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    urls = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> s.find_all(<span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">        urls.append(url[<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_urls()</span><br></pre></td></tr></table></figure>
<p>如果我们使用 Python 的 <code>cProfile</code> 分析器，我们会得到超过 2500 行的输出结果，即使对其进行排序，我仍然搞不懂时间到底都花在哪了。如果我们使用 <a target="_blank" rel="noopener" href="https://github.com/pyutils/line_profiler"><code>line_profiler</code></a>，它会基于行来显示时间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kernprof -l -v a.py</span><br><span class="line">Wrote profile results to urls.py.lprof</span><br><span class="line">Timer unit: 1e-06 s</span><br><span class="line"></span><br><span class="line">Total <span class="keyword">time</span>: 0.636188 s</span><br><span class="line">File: a.py</span><br><span class="line">Function: get_urls at line 5</span><br><span class="line"></span><br><span class="line">Line <span class="comment">#  Hits         Time  Per Hit   % Time  Line Contents</span></span><br><span class="line">==============================================================</span><br><span class="line"> 5                                           @profile</span><br><span class="line"> 6                                           def get_urls():</span><br><span class="line"> 7         1     613909.0 613909.0     96.5      response = requests.get(<span class="string">&#x27;https://missing.csail.mit.edu&#x27;</span>)</span><br><span class="line"> 8         1      21559.0  21559.0      3.4      s = BeautifulSoup(response.content, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"> 9         1          2.0      2.0      0.0      urls = []</span><br><span class="line">10        25        685.0     27.4      0.1      <span class="keyword">for</span> url <span class="keyword">in</span> s.find_all(<span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">11        24         33.0      1.4      0.0          urls.append(url[<span class="string">&#x27;href&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h4 id="内存">内存</h4>
<p>像 C 或者 C++ 这样的语言，内存泄漏会导致你的程序在使用完内存后不去释放它。为了应对内存类的 Bug，我们可以使用类似 <a target="_blank" rel="noopener" href="https://valgrind.org/">Valgrind</a> 这样的工具来检查内存泄漏问题。</p>
<p>对于 Python 这类具有垃圾回收机制的语言，内存分析器也是很有用的，因为对于某个对象来说，只要有指针还指向它，那它就不会被回收。</p>
<p>下面这个例子及其输出，展示了 <a target="_blank" rel="noopener" href="https://pypi.org/project/memory-profiler/">memory-profiler</a> 是如何工作的（注意装饰器和 <code>line-profiler</code> 类似）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>():</span><br><span class="line">    a = [<span class="number">1</span>] * (<span class="number">10</span> ** <span class="number">6</span>)</span><br><span class="line">    b = [<span class="number">2</span>] * (<span class="number">2</span> * <span class="number">10</span> ** <span class="number">7</span>)</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_func()</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python -m memory_profiler example.py</span><br><span class="line">Line <span class="comment">#    Mem usage  Increment   Line Contents</span></span><br><span class="line">==============================================</span><br><span class="line">     3                           @profile</span><br><span class="line">     4      5.97 MB    0.00 MB   def my_func():</span><br><span class="line">     5     13.61 MB    7.64 MB       a = [1] * (10 ** 6)</span><br><span class="line">     6    166.20 MB  152.59 MB       b = [2] * (2 * 10 ** 7)</span><br><span class="line">     7     13.61 MB -152.59 MB       del b</span><br><span class="line">     8     13.61 MB    0.00 MB       <span class="built_in">return</span> a</span><br></pre></td></tr></table></figure>
<h4 id="事件">事件</h4>
<p>在我们使用<code>strace</code>调试代码的时候，你可能会希望忽略一些特殊的代码并希望在分析时将其当作黑盒处理。<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man1/perf.1.html"><code>perf</code></a> 命令将 CPU 的区别进行了抽象，它<strong>不会报告时间和内存的消耗，而是报告与你的程序相关的系统事件</strong>。</p>
<p>例如，<code>perf</code> 可以报告<strong>不佳的缓存局部性（poor cache locality）、大量的页错误（page faults）或活锁（livelocks）</strong>。下面是关于常见命令的简介：</p>
<ul>
<li><code>perf list</code> - 列出可以被 pref 追踪的事件；</li>
<li><code>perf stat COMMAND ARG1 ARG2</code> - 收集与某个进程或指令相关的事件；</li>
<li><code>perf record COMMAND ARG1 ARG2</code> - 记录命令执行的采样信息并将统计数据储存在<code>perf.data</code>中；</li>
<li><code>perf report</code> - 格式化并打印 <code>perf.data</code> 中的数据。</li>
</ul>
<h4 id="性能分析可视化">性能分析可视化</h4>
<p>使用分析器来分析真实的程序时，由于软件的复杂性，其输出结果中将包含大量的信息。人类是一种视觉动物，非常不善于阅读大量的文字。因此很多工具都提供了可视化分析器输出结果的功能。</p>
<p>对于<strong>采样分析器</strong>来说，常见的显示 CPU 分析数据的形式是 <a target="_blank" rel="noopener" href="http://www.brendangregg.com/flamegraphs.html">火焰图</a>，火焰图会<strong>在 Y 轴显示函数调用关系，并在 X 轴显示其耗时的比例</strong>。火焰图同时还是可交互的，你可以深入程序的某一具体部分，并查看其栈追踪（你可以尝试点击下面的图片）。</p>
<p><a target="_blank" rel="noopener" href="http://www.brendangregg.com/FlameGraphs/cpu-bash-flamegraph.svg"><img src="http://www.brendangregg.com/FlameGraphs/cpu-bash-flamegraph.svg" alt="FlameGraph"></a></p>
<p><strong>调用图和控制流图可以显示子程序之间的关系，它将函数作为节点并把函数调用作为边</strong>。将它们和分析器的信息（例如调用次数、耗时等）放在一起使用时，调用图会变得非常有用，它可以帮助我们分析程序的流程。 在 Python 中你可以使用 <a target="_blank" rel="noopener" href="http://pycallgraph.slowchop.com/en/master/"><code>pycallgraph</code></a> 来生成这些图片。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/2/2f/A_Call_Graph_generated_by_pycallgraph.png" alt="Call Graph"></p>
<h4 id="资源监控">资源监控</h4>
<p>有时候，分析程序性能的<strong>第一步是搞清楚它所消耗的资源</strong>。程序变慢通常是因为它所需要的资源不够了。例如，没有足够的内存或者网络连接变慢的时候。</p>
<p>有很多很多的工具可以被用来显示不同的系统资源，例如 CPU 占用、内存使用、网络、磁盘使用等。</p>
<ul>
<li>
<p><strong>通用监控</strong> - 最流行的工具要数 <a target="_blank" rel="noopener" href="https://htop.dev/"><code>htop</code></a> 了，它是 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man1/top.1.html"><code>top</code></a> 的改进版。<code>htop</code> 可以显示当前运行进程的多种统计信息。<code>htop</code> 有很多选项和快捷键，常见的有：</p>
<ul>
<li><code>&lt;F6&gt;</code> 进程排序、</li>
<li><code>t</code> 显示树状结构和</li>
<li><code>h</code> 打开或折叠线程。</li>
</ul>
<p>还可以留意一下 <a target="_blank" rel="noopener" href="https://nicolargo.github.io/glances/"><code>glances</code></a> ，它的实现类似但是用户界面更好。如果需要合并测量全部的进程， <a target="_blank" rel="noopener" href="http://dag.wiee.rs/home-made/dstat/"><code>dstat</code></a> 也是一个非常好用的工具，它可以实时地计算不同子系统资源的度量数据，例如 I/O、网络、 CPU 利用率、上下文切换等等；</p>
</li>
<li>
<p><strong>I/O 操作</strong> - <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man8/iotop.8.html"><code>iotop</code></a> 可以显示实时 I/O 占用信息而且可以非常方便地检查某个进程是否正在执行大量的磁盘读写操作；</p>
</li>
<li>
<p><strong>磁盘使用</strong> - <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man1/df.1.html"><code>df</code></a> 可以显示每个分区的信息，而 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man1/du.1.html"><code>du</code></a> 则可以显示当前目录下每个文件的磁盘使用情况（ <strong>d</strong>isk <strong>u</strong>sage）。<code>-h</code> 选项可以使命令以对人类（<strong>h</strong>uman）更加友好的格式显示数据；<a target="_blank" rel="noopener" href="https://dev.yorhel.nl/ncdu"><code>ncdu</code></a>是一个交互性更好的 <code>du</code> ，它可以让你在不同目录下导航、删除文件和文件夹；</p>
</li>
<li>
<p><strong>内存使用</strong> - <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man1/free.1.html"><code>free</code></a> 可以显示系统当前空闲的内存。内存也可以使用 <code>htop</code> 这样的工具来显示；</p>
</li>
<li>
<p><strong>打开文件</strong> - <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man8/lsof.8.html"><code>lsof</code></a> 可以列出被进程打开的文件信息。 当我们需要查看某个文件是被哪个进程打开的时候，这个命令非常有用；</p>
</li>
<li>
<p><strong>网络连接和配置</strong> - <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man8/ss.8.html"><code>ss</code></a> 能帮助我们监控网络包的收发情况以及网络接口的显示信息。<strong><code>ss</code> 常见的一个使用场景是找到端口被进程占用的信息</strong>。<strong>如果要显示路由、网络设备和接口信息，你可以使用 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man8/ip.8.html"><code>ip</code></a> 命令</strong>。注意，<code>netstat</code> 和 <code>ifconfig</code> 这两个命令已经被前面那些工具所代替了。</p>
</li>
<li>
<p><strong>网络使用</strong> - <a target="_blank" rel="noopener" href="https://github.com/raboof/nethogs"><code>nethogs</code></a> 和 <a target="_blank" rel="noopener" href="http://www.ex-parrot.com/pdw/iftop/"><code>iftop</code></a> 是非常好的用于对<strong>网络占用进行监控</strong>的交互式命令行工具。</p>
</li>
</ul>
<p>如果你希望测试一下这些工具，你可以使用 <a target="_blank" rel="noopener" href="https://linux.die.net/man/1/stress"><code>stress</code></a> 命令来为系统人为地增加负载。</p>
<h4 id="基准比较测试">基准比较测试</h4>
<p>有时候，你只需要对黑盒程序进行基准测试，并依此对软件选择进行评估。 类似 <a target="_blank" rel="noopener" href="https://github.com/sharkdp/hyperfine"><code>hyperfine</code></a> 这样的命令行可以帮你快速进行基准测试。例如，我们在 shell 工具和脚本那一节课中我们推荐使用 <code>fd</code> 来代替 <code>find</code>。我们这里可以用 <code>hyperfine</code> 来比较一下它们。</p>
<p>例如，下面的例子中，我们可以看到 <code>fd</code> 比 <code>find</code> 要快20倍。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hyperfine --warmup 3 <span class="string">&#x27;fd -e jpg&#x27;</span> <span class="string">&#x27;find . -iname &quot;*.jpg&quot;&#x27;</span></span><br><span class="line">Benchmark <span class="comment">#1: fd -e jpg</span></span><br><span class="line">  Time (mean ± σ):      51.4 ms ±   2.9 ms    [User: 121.0 ms, System: 160.5 ms]</span><br><span class="line">  Range (min … max):    44.2 ms …  60.1 ms    56 runs</span><br><span class="line"></span><br><span class="line">Benchmark <span class="comment">#2: find . -iname &quot;*.jpg&quot;</span></span><br><span class="line">  Time (mean ± σ):      1.126 s ±  0.101 s    [User: 141.1 ms, System: 956.1 ms]</span><br><span class="line">  Range (min … max):    0.975 s …  1.287 s    10 runs</span><br><span class="line"></span><br><span class="line">Summary</span><br><span class="line">  <span class="string">&#x27;fd -e jpg&#x27;</span> ran</span><br><span class="line">   21.89 ± 2.33 <span class="built_in">times</span> faster than <span class="string">&#x27;find . -iname &quot;*.jpg&quot;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>和 debug 一样，浏览器也包含了很多不错的性能分析工具，可以用来分析页面加载，让我们可以搞清楚时间都消耗在什么地方（加载、渲染、脚本等等）。 更多关于 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Profiling_with_the_Built-in_Profiler">Firefox</a> 和 <a target="_blank" rel="noopener" href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools">Chrome</a> 的信息可以点击链接查看。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://FutureYL3.github.io">yl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://futureyl3.github.io/2025/03/02/MIT-The-Missing-Semester-Lec07-Debugging-and-Profiling/">https://futureyl3.github.io/2025/03/02/MIT-The-Missing-Semester-Lec07-Debugging-and-Profiling/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Debug/">Debug</a><a class="post-meta__tags" href="/tags/Profile/">Profile</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/02/MIT-The-Missing-Semester-Lec06-Git/" title="[MIT The Missing Semester] Lec06: Git"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">[MIT The Missing Semester] Lec06: Git</div></div><div class="info-2"><div class="info-item-1">Introduction to version control system -- Git.</div></div></div></a><a class="pagination-related" href="/2025/03/02/MIT-The-Missing-Semester-Lec08-Meta-Programming/" title="[MIT The Missing Semester] Lec08: Meta Programming"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">[MIT The Missing Semester] Lec08: Meta Programming</div></div><div class="info-2"><div class="info-item-1">Introduction to build system, version number, continuous integration and tesing.</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/kano.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yl</div><div class="author-info-description">Student at Harbin Institute of Technology (HIT) / Major in Software Engineering</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/FutureYL3" target="_blank" title="My GitHub Profile"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/310715755" target="_blank" title="My Bilibili Space"><i class="fa-brands fa-bilibili" style="color: #00a1d6;"></i></a><a class="social-icon" href="/future_yl@outlook.com" target="_blank" title="My Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Lec07：调试及性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-text">调试代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E8%B0%83%E8%AF%95%E6%B3%95%E4%B8%8E%E6%97%A5%E5%BF%97"><span class="toc-text">打印调试法与日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F"><span class="toc-text">第三方日志系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-text">调试器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95"><span class="toc-text">二进制程序调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95"><span class="toc-text">网络调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-text">代码静态分析工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6"><span class="toc-text">计时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-text">性能分析工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU"><span class="toc-text">CPU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-text">内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-text">事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-text">性能分析可视化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7"><span class="toc-text">资源监控</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E5%87%86%E6%AF%94%E8%BE%83%E6%B5%8B%E8%AF%95"><span class="toc-text">基准比较测试</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/Web-Development-Sky-Takeout/" title="Web Development -- Sky Takeout">Web Development -- Sky Takeout</a><time datetime="2025-03-02T10:51:57.000Z" title="Created 2025-03-02 18:51:57">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/Springfox-Swagger/" title="Springfox Swagger">Springfox Swagger</a><time datetime="2025-03-02T10:42:33.000Z" title="Created 2025-03-02 18:42:33">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/Database-and-SQL-Basic-Concepts-and-Usage/" title="Database and SQL: Basic Concepts and Usage">Database and SQL: Basic Concepts and Usage</a><time datetime="2025-03-02T10:29:51.000Z" title="Created 2025-03-02 18:29:51">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/MyBatis-Plus-Basic-Usage/" title="MyBatis Plus Basic Usage">MyBatis Plus Basic Usage</a><time datetime="2025-03-02T10:19:09.000Z" title="Created 2025-03-02 18:19:09">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/MIT-The-Missing-Semester-Lec10-Potpourri/" title="[MIT The Missing Semester] Lec10: Potpourri">[MIT The Missing Semester] Lec10: Potpourri</a><time datetime="2025-03-02T10:10:46.000Z" title="Created 2025-03-02 18:10:46">2025-03-02</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(to right, rgb(198, 255, 221), rgb(251, 215, 134), rgb(247, 121, 125));"><div id="footer-wrap"><div class="copyright">&copy;2025 By yl</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search through all posts and pages" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>