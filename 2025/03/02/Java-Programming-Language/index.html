<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java Programming Language | yl's blog</title><meta name="author" content="yl"><meta name="copyright" content="yl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="To lay great foundation for programming in Java.">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Programming Language">
<meta property="og:url" content="https://futureyl3.github.io/2025/03/02/Java-Programming-Language/">
<meta property="og:site_name" content="yl&#39;s blog">
<meta property="og:description" content="To lay great foundation for programming in Java.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://futureyl3.github.io/img/kano.JPG">
<meta property="article:published_time" content="2025-03-02T08:47:15.000Z">
<meta property="article:modified_time" content="2025-03-02T08:47:15.000Z">
<meta property="article:author" content="yl">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://futureyl3.github.io/img/kano.JPG"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java Programming Language",
  "url": "https://futureyl3.github.io/2025/03/02/Java-Programming-Language/",
  "image": "https://futureyl3.github.io/img/kano.JPG",
  "datePublished": "2025-03-02T08:47:15.000Z",
  "dateModified": "2025-03-02T08:47:15.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "yl",
      "url": "https://futureyl3.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://futureyl3.github.io/2025/03/02/Java-Programming-Language/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java Programming Language',
  isHighlightShrink: undefined,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/kano.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(to right, rgb(198, 255, 221), rgb(251, 215, 134), rgb(247, 121, 125));"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">yl's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Java Programming Language</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java Programming Language</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-02T08:47:15.000Z" title="Created 2025-03-02 16:47:15">2025-03-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-02T08:47:15.000Z" title="Updated 2025-03-02 16:47:15">2025-03-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Programming-Language/">Programming Language</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Programming-Language/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">30.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>94mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container">

	<div class="row">
    <embed src="Java编程基础_compressed.pdf" width="100%" height="550" type="application/pdf">
	</div>



<blockquote>
<p>Tips: Poor typesetting(no space between Chinese and non-Chinese words) content exists, please mainly refer to the mind map.</p>
</blockquote>
<h1>Java编程基础</h1>
<h2 id="第一章：内容介绍">第一章：内容介绍</h2>
<h2 id="第二章：Java概述">第二章：Java概述</h2>
<h2 id="第三章：变量">第三章：变量</h2>
<h2 id="第四章：运算符">第四章：运算符</h2>
<h2 id="第五章：程序控制结构">第五章：程序控制结构</h2>
<h2 id="第六章：数组、排序和查找">第六章：数组、排序和查找</h2>
<h2 id="第七章：面向对象编程（初级）">第七章：面向对象编程（初级）</h2>
<h3 id="7-1-类与对象">7.1 类与对象</h3>
<ul>
<li>
<p>引出</p>
<ul>
<li>
<p>单个声明每一个变量不利于数据的管理</p>
</li>
<li>
<p>使用数组不利于将意义与数据对应，效率低</p>
</li>
</ul>
</li>
<li>
<p>类与对象的关系</p>
<ul>
<li>类是对象的抽象，对象是类的实例化</li>
</ul>
</li>
<li>
<p>类与对象的区别和联系</p>
<ul>
<li>
<p>类是抽象的、概念的，代表一类事物，比如人类、猫类…，即类是数据类型</p>
</li>
<li>
<p>对象是具体的，实际的，代表一个具体事物，即是实例</p>
</li>
<li>
<p>类是对象的模板，对象是类的一个个体，对应一个实例</p>
</li>
</ul>
</li>
<li>
<p>对象在内存中的存在形式</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>属性/成员变量/字段</p>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>从概念或叫法上看：成员变量和属性、字段是一个意思。</p>
</li>
<li>
<p>属性是类的一个组成部分，一般是基本数据类型，也可以是引用类型</p>
</li>
</ul>
</li>
<li>
<p>注意事项的细节说明</p>
<ul>
<li>
<p>属性的定义语法同变量</p>
</li>
<li>
<p>属性的定义类型可以为任意类型，包含基本类型或引用类型</p>
</li>
<li>
<p>属性如果不赋值，会有默认值，规则和数组是一致的。<br>
具体说，int, short, byte, long 是 0，float 和 double 是 0.0，char 是 \u0000，boolean 是 false，String 是 null</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如何创建对象</p>
<ul>
<li>
<p>先声明再创建</p>
<ul>
<li>先声明，再分配内存</li>
</ul>
</li>
<li>
<p>直接创建</p>
<ul>
<li>声明和创建放在一起</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如何访问属性</p>
<ul>
<li>运用点（.）运算符</li>
</ul>
</li>
<li>
<p>类和对象的内存分配机制</p>
<ul>
<li>
<p>Java 的内存结构分析</p>
<ul>
<li>
<p>栈</p>
<ul>
<li>一般存放基本数据类型（局部变量）</li>
</ul>
</li>
<li>
<p>堆</p>
<ul>
<li>存放对象、数组等</li>
</ul>
</li>
<li>
<p>方法区</p>
<ul>
<li>存放常量池，类加载信息</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Java创建对象的流程简单分析</p>
<ul>
<li>
<p>先加载类信息（属性和方法信息，对一个类只会加载一次）</p>
</li>
<li>
<p>在堆中分配空间，进行默认初始化</p>
</li>
<li>
<p>把地址赋给标识符，标识符就指向对象</p>
</li>
<li>
<p>进行指定初始化（即在类定义时已经书写的初始化）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-2-成员方法">7.2 成员方法</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>在某些情况下，我们需要定义成员方法（简称方法）。比如人类，除了有一些属性外，人类还有一些行为比如：说话、吃饭、学习。这时就要用成员方法才能完成。</li>
</ul>
</li>
<li>
<p>方法的调用机制</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>成员方法的好处</p>
<ul>
<li>
<p>提高代码的复用性</p>
</li>
<li>
<p>可以将实现的细节封装起来，然后供其他用户来调用即可</p>
</li>
</ul>
</li>
<li>
<p>成员方法的定义</p>
<ul>
<li>
<p>形参列表</p>
<ul>
<li>表示成员方法输入</li>
</ul>
</li>
<li>
<p>返回数据类型</p>
<ul>
<li>表示成员方法的输出（返回值）</li>
</ul>
</li>
<li>
<p>方法主体</p>
<ul>
<li>实现某一功能的代码块</li>
</ul>
</li>
<li>
<p>return 语句（对于 void 类型不必要）</p>
</li>
</ul>
</li>
<li>
<p>注意事项和使用细节</p>
<ul>
<li>
<p>访问修饰符</p>
<ul>
<li>不写默认是默认修饰符</li>
</ul>
</li>
<li>
<p>返回数据类型</p>
<ul>
<li>
<p>一个方法最多有一个返回值（需要多个返回值可以返回数组）</p>
</li>
<li>
<p>返回类型可以为任意类型，包括基本类型和引用类型（数组对象字符串）</p>
</li>
<li>
<p>如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 语句；而且要求返回值类型和 return 的值类型一致或兼容</p>
</li>
<li>
<p>如果方法是 void，则方法体中可以没有 return 语句，或者只写 return；</p>
</li>
</ul>
</li>
<li>
<p>方法名</p>
<ul>
<li>遵循驼峰命名法，最好见名知义，表达出该功能的意思即可</li>
</ul>
</li>
<li>
<p>形参列表</p>
<ul>
<li>
<p>一个方法可以有 0 个参数，也可以有多个参数，中间用逗号隔开</p>
</li>
<li>
<p>参数类型可以为任意类型，包含基本类型和引用类型</p>
</li>
<li>
<p>调用带参数的方法时，一定对应着参数列表传入下相同类型或兼容类型的参数</p>
</li>
<li>
<p>方法定义时的参数称为形式参数，简称形参‘方法调用时传入的参数称为实际参数，简称实参，实参和形参的类型要一致或兼容，个数、顺序必须一致</p>
</li>
</ul>
</li>
<li>
<p>方法体</p>
<ul>
<li>几乎无限制，但注意方法体内不能再定义方法</li>
</ul>
</li>
<li>
<p>方法调用</p>
<ul>
<li>
<p>同一个类中的方法：直接调用</p>
</li>
<li>
<p>跨类中的方法调用：需要通过对象名调用，即要先创建对象才能调用</p>
</li>
<li>
<p>跨类方法调用还与方法的访问修饰符相关，后面会具体讲到</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-3-成员方法传参机制">7.3 成员方法传参机制</h3>
<ul>
<li>
<p>基本数据类型传参是值拷贝，不会影响主调方法中的变量</p>
</li>
<li>
<p>引用数据类型传参是地址拷贝，会影响主调方法中的引用数据类型变量</p>
</li>
</ul>
<h3 id="7-4-方法递归调用">7.4 方法递归调用</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>递归就是方法自己调用自己</li>
</ul>
</li>
<li>
<p>例子</p>
<ul>
<li>
<p>阶乘运算</p>
</li>
<li>
<p>猴子吃桃问题</p>
</li>
<li>
<p>迷宫问题</p>
</li>
<li>
<p>汉诺塔问题</p>
</li>
<li>
<p>八皇后问题</p>
</li>
</ul>
</li>
</ul>
<h3 id="7-5-方法重载">7.5 方法重载</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>Java 中允许同一个类中，多个同名方法的存在，但要求形参列表不一致</li>
</ul>
</li>
<li>
<p>重载的好处</p>
<ul>
<li>
<p>减轻了起名的麻烦</p>
</li>
<li>
<p>减轻了记名的麻烦</p>
</li>
</ul>
</li>
<li>
<p>注意事项和使用细节</p>
<ul>
<li>
<p>方法名：必须相同</p>
</li>
<li>
<p>形参列表：必须不同。简单地说，要一眼看上去就能通过形参列表区分两个方法，这样才构成重载</p>
</li>
<li>
<p>返回类型：无要求<br>
理解：形参列表要求不同那么返回类型肯定会有不同，所以返回类型无要求</p>
</li>
</ul>
</li>
</ul>
<h3 id="7-6-可变参数">7.6 可变参数</h3>
<ul>
<li>
<p>基本概念</p>
<ul>
<li>java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。</li>
</ul>
</li>
<li>
<p>基本语法</p>
<ul>
<li>访问修饰符 返回类型 方法名(数据类型… 形参名)</li>
</ul>
</li>
<li>
<p>注意事项和使用细节</p>
<ul>
<li>
<p>可变参数的实参可以为 0 个或任意多个</p>
</li>
<li>
<p>可变参数的实参可以为数组</p>
</li>
<li>
<p>可变参数的本质就是数组</p>
</li>
<li>
<p>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</p>
</li>
<li>
<p>一个形参列表中只能出现一个可变参数</p>
</li>
</ul>
</li>
</ul>
<h3 id="7-7-作用域">7.7 作用域</h3>
<ul>
<li>
<p>基本使用</p>
<ul>
<li>
<p>在 Java 编程中，主要的变量就是属性和局部变量</p>
</li>
<li>
<p>我们说的局部变量一般是指在成员方法中定义的变量</p>
</li>
<li>
<p>Java 中作用域的分类</p>
<ul>
<li>
<p>全局变量</p>
<ul>
<li>也就是属性，作用域为整个类体</li>
</ul>
</li>
<li>
<p>局部变量</p>
<ul>
<li>也就是除了属性之外的其他变量，作用域为定义它的代码块中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>全局变量可以不赋值，直接使用，因为有默认值。局部变量必须赋值后。才能使用，因为没有默认值</p>
</li>
</ul>
</li>
<li>
<p>注意事项和细节使用</p>
<ul>
<li>
<p>属性和局部变量可以重名，访问时遵循就近原则</p>
</li>
<li>
<p>在同一个作用域中，比如同一个成员方法中，两个局部变量不能重名</p>
</li>
<li>
<p>属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量生命周期较短，伴随着它的代码块的执行而创建，伴随这代码块的结束而销毁，即在一次方法调用过程中。</p>
</li>
<li>
<p>作用域范围不同</p>
<ul>
<li>
<p>全局变量 / 属性：可以被本类使用，或被其他类调用（通过对象调用）</p>
</li>
<li>
<p>局部变量：只能在本类中对应的方法中使用</p>
</li>
</ul>
</li>
<li>
<p>修饰符不同</p>
<ul>
<li>
<p>全局变量 / 属性可以加修饰符</p>
</li>
<li>
<p>局部变量不可以加修饰符</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-8-构造器">7.8 构造器</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>构造器，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化</li>
</ul>
</li>
<li>
<p>基本语法</p>
<ul>
<li>访问修饰符 方法名(形参列表){<br>
方法体;<br>
}
<ul>
<li>
<p>注意</p>
<ul>
<li>
<p>构造器的修饰符可以是默认，也可以是 public protected private</p>
</li>
<li>
<p>构造器没有返回值</p>
</li>
<li>
<p>方法名和类名必须一样</p>
</li>
<li>
<p>参数列表和成员方法是一样的规则</p>
</li>
<li>
<p>构造器的调用，由系统完成</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>特点</p>
<ul>
<li>
<p>方法名和类名相同</p>
</li>
<li>
<p>没有返回值</p>
</li>
<li>
<p>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化</p>
</li>
</ul>
</li>
<li>
<p>注意事项和使用细节</p>
<ul>
<li>
<p>一个类可以定义多个不同的构造器，即构造器重载</p>
</li>
<li>
<p>构造器名和类名要相同</p>
</li>
<li>
<p>构造器没有返回值</p>
</li>
<li>
<p>构造器是完成对象的初始化，并不是创建对象</p>
</li>
<li>
<p>在创建对象时，系统自动地调用该类的构造器</p>
</li>
<li>
<p>如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器</p>
</li>
<li>
<p>一旦定义了自己的构造器，默认的构造器就被覆盖了，就不能再使用默认的无参构造器，除非显式地定义一下</p>
</li>
</ul>
</li>
</ul>
<h3 id="7-9-对象创建流程分析">7.9 对象创建流程分析</h3>
<ul>
<li>
<p>流程</p>
<ul>
<li>
<p>加载类信息，且只会加载一次</p>
</li>
<li>
<p>在堆中分配空间（地址）</p>
</li>
<li>
<p>完成对象初始化</p>
<ul>
<li>
<p>默认初始化</p>
</li>
<li>
<p>显式（定义中的）初始化</p>
</li>
<li>
<p>构造器的初始化</p>
</li>
</ul>
</li>
<li>
<p>把对象在堆中的地址返回给标识符</p>
</li>
</ul>
</li>
</ul>
<h3 id="7-10-this-关键字">7.10 this 关键字</h3>
<ul>
<li>
<p>什么是 this</p>
<ul>
<li>
<p>Java 虚拟机会给每个对象分配 this，代表当前对象</p>
</li>
<li>
<p>简单地说，哪个对象调用，this 就代表哪个对象</p>
</li>
<li></li>
</ul>
</li>
<li>
<p>this 的注意事项和使用细节</p>
<ul>
<li>
<p>this 关键字可以用来访问本类的属性、方法、构造器</p>
</li>
<li>
<p>this 用于区别当前类的属性和局部变量</p>
</li>
<li>
<p>访问成员方法的语法，this.方法名(参数列表)</p>
</li>
<li>
<p>访问构造器语法：this(参数列表)。注意只能在构造器中访问另外一个构造器，且必须放在该构造器的第一条语句处</p>
</li>
<li>
<p>this 不能在类定义的外部使用，只能在类定义的方法中使用</p>
</li>
</ul>
</li>
</ul>
<h2 id="第八章：面向对象编程（中级）">第八章：面向对象编程（中级）</h2>
<h3 id="8-1-8-3-IDE-IDEA">8.1~8.3 IDE - IDEA</h3>
<ul>
<li>
<p>常用快捷键</p>
<ul>
<li>
<p>ctrl + d 删除当前行</p>
</li>
<li>
<p>ctrl + alt + 下箭头 复制当前行</p>
</li>
<li>
<p>alt + / 补全代码</p>
</li>
<li>
<p>ctrl + / 多行添加或删除注释</p>
</li>
<li>
<p>alt + enter 导入该行需要的类</p>
</li>
<li>
<p>ctrl + alt + L 快速格式化代码</p>
</li>
<li>
<p>alt + r 快速运行程序</p>
</li>
<li>
<p>alt + insert 生成构造器</p>
</li>
<li>
<p>ctrl + h 查看一个类的层级关系</p>
</li>
<li>
<p>ctrl + b 光标放在一个方法上时可以定位到方法处</p>
</li>
<li>
<p>.var 自动分配变量名</p>
</li>
</ul>
</li>
<li>
<p>模板 / 自定义模板</p>
<ul>
<li>file -&gt; settings -&gt; editor -&gt; Live templates</li>
</ul>
</li>
</ul>
<h3 id="8-4-包">8.4 包</h3>
<ul>
<li>
<p>包的三大作用</p>
<ul>
<li>
<p>区分相同名字的类</p>
</li>
<li>
<p>当类很多时，可以很好地管理类</p>
</li>
<li>
<p>控制访问范围</p>
</li>
</ul>
</li>
<li>
<p>包的基本语法</p>
<ul>
<li>
<p>package 包名</p>
</li>
<li>
<p>说明</p>
<ul>
<li>
<p>package 关键字，表示打包</p>
</li>
<li>
<p>包名中的（.）用于表示子目录</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>包的本质分析</p>
<ul>
<li>包的本质，实际上就是创建不同的文件夹 / 目录来保存类文件</li>
</ul>
</li>
<li>
<p>包的命名</p>
<ul>
<li>
<p>命名规则</p>
<ul>
<li>只能包含数字、字母、下划线和小圆点，但不能用数字开头，不能有关键字或保留字</li>
</ul>
</li>
<li>
<p>命名规范</p>
<ul>
<li>
<p>一般是小写字母 + 小圆点</p>
</li>
<li>
<p>一般命名为 com.公司名.项目名.业务模块名</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>常用的包</p>
<ul>
<li>
<p>java.lang.*</p>
<ul>
<li>lang 包是基本包，默认导入，不需要再导入</li>
</ul>
</li>
<li>
<p>java.util.*</p>
<ul>
<li>util 包是系统提供的工具包</li>
</ul>
</li>
<li>
<p><a target="_blank" rel="noopener" href="http://java.net">java.net</a>.*</p>
<ul>
<li>网络包，用于网络开发</li>
</ul>
</li>
<li>
<p>java.awt.*</p>
<ul>
<li>GUI 界面包，用于做可视化界面</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如何导入包</p>
<ul>
<li>
<p>语法</p>
<ul>
<li>import 包名</li>
</ul>
</li>
<li>
<p>引入一个包的主要目的是要使用该包下的类</p>
</li>
<li>
<p>建议需要哪个类就导入哪个类，不建议使用 * 导入</p>
</li>
</ul>
</li>
<li>
<p>注意事项和使用细节</p>
<ul>
<li>
<p>package 的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句 package</p>
</li>
<li>
<p>import 指令位置放在 package 下面，类定义的前面，可以有多句且顺序无要求</p>
</li>
</ul>
</li>
</ul>
<h3 id="8-5-访问修饰符">8.5 访问修饰符</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>Java 提供四种访问控制修饰符号，用于控制方法和属性的访问范围</p>
<ul>
<li>
<p>public</p>
<ul>
<li>对外公开</li>
</ul>
</li>
<li>
<p>protected</p>
<ul>
<li>对子类和同一个包中的类公开</li>
</ul>
</li>
<li>
<p>默认</p>
<ul>
<li>对同一个包中的类公开</li>
</ul>
</li>
<li>
<p>private</p>
<ul>
<li>只对本类公开，不对外公开</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>访问范围</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>使用的注意事项</p>
<ul>
<li>
<p>访问修饰符可以用来修饰类中的属性、方法和类本身</p>
</li>
<li>
<p>只有默认和 public 修饰符可以修饰类，并且遵循上述访问权限的特点</p>
</li>
<li>
<p>子类的访问权限会在讲完继承后讲解</p>
</li>
<li>
<p>成员方法的访问规则和属性完全一样</p>
</li>
</ul>
</li>
</ul>
<h3 id="8-6-面向对象编程三大特征">8.6 面向对象编程三大特征</h3>
<ul>
<li>
<p>封装</p>
</li>
<li>
<p>继承</p>
</li>
<li>
<p>多态</p>
</li>
</ul>
<h3 id="8-7-封装">8.7 封装</h3>
<ul>
<li>
<p>介绍</p>
<ul>
<li>封装就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作，才能对数据进行操作</li>
</ul>
</li>
<li>
<p>优点</p>
<ul>
<li>
<p>隐藏实现细节</p>
</li>
<li>
<p>可以对数据进行验证，保证安全合理</p>
</li>
</ul>
</li>
<li>
<p>实现步骤</p>
<ul>
<li>
<p>将属性私有化【使属性不能被直接修改】</p>
</li>
<li>
<p>提供一个 public 的 set 方法，用于对属性进行合法判断和赋值</p>
</li>
<li>
<p>提供一个 public 的 get 方法，用于验证权限和获取属性的值</p>
</li>
</ul>
</li>
</ul>
<h3 id="8-8-继承">8.8 继承</h3>
<ul>
<li>
<p>基本介绍和示意图</p>
<ul>
<li>
<p>继承可以解决代码复用，让我们的编程更加靠近人类思维。当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可。</p>
</li>
<li></li>
</ul>
</li>
<li>
<p>基本语法</p>
<ul>
<li>
<p>class 子类 extends 父类</p>
</li>
<li>
<p>说明</p>
<ul>
<li>
<p>子类会自动拥有父类定义的属性和方法</p>
</li>
<li>
<p>父类又叫超类、基类</p>
</li>
<li>
<p>子类又叫派生类</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>优点</p>
<ul>
<li>
<p>代码的复用性提高了</p>
</li>
<li>
<p>代码的扩展性和可维护性提高了</p>
</li>
</ul>
</li>
<li>
<p>继承的深入讨论和细节</p>
<ul>
<li>
<p>子类继承了父类所有的属性和方法，其中非私有的属性和方法可以在子类中直接访问，但是私有的属性和方法不能再子类中直接访问，要通过父类提供的公共的方法去访问</p>
</li>
<li>
<p>子类的构造器中必须调用父类的构造器，以完成父类的初始化</p>
</li>
<li>
<p>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成父类的初始化，否则编译不通过</p>
</li>
<li>
<p>如果希望指定去调用父类的某个构造器，则显式地调用一下</p>
</li>
<li>
<p>super 在使用时，必须放在构造器的第一行</p>
</li>
<li>
<p>super() 和 this() 都只能放在构造器的第一行，因此这两个方法不能在一个构造器中共存</p>
</li>
<li>
<p>Java 所有类都是 Object 类的子类，Object 类是所有类的父类</p>
</li>
<li>
<p>父类构造器的调用不限于直接父类！将一致往上追溯直到 Object 类</p>
</li>
<li>
<p>子类最多只能继承一个父类（指直接继承），即 Java 中是单继承机制</p>
</li>
<li>
<p>不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系</p>
</li>
</ul>
</li>
<li>
<p>继承的本质分析</p>
<ul>
<li>
<p>本质</p>
<ul>
<li>
<p>当子类对象创建好后，建立【查找】的关系</p>
</li>
<li></li>
</ul>
</li>
<li>
<p>JVM 如何知道要访问哪个属性？</p>
<ul>
<li>
<p>按照查找关系来返回信息</p>
<ul>
<li>
<p>首先看当前类是否有该属性</p>
</li>
<li>
<p>如果当前类有，并且可以访问，则返回信息</p>
</li>
<li>
<p>如果当前类没有这个属性，就看这个类的父类有没有这个属性（如果这个类的父类有该属性，并且可以访问，就返回信息）</p>
</li>
<li>
<p>如果这个类的父类没有，则按照3的规则，继续找上级父类，直到 Object</p>
</li>
</ul>
</li>
<li>
<p>对于方法的查找也是相同的规则</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8-9-super关键字">8.9 super关键字</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>super 代表父类的引用，用于访问父类的属性、方法和构造器</li>
</ul>
</li>
<li>
<p>基本语法</p>
<ul>
<li>
<p>访问父类的属性，但不能访问 private 属性<br>
super.属性名</p>
</li>
<li>
<p>访问父类的方法，但不能访问 private 的方法<br>
super.方法名(参数列表）</p>
</li>
<li>
<p>访问父类的构造器<br>
super(参数列表)<br>
只能放在构造器的第一句，只能出现一句</p>
</li>
</ul>
</li>
<li>
<p>给编程带来的便利</p>
<ul>
<li>分工明确，父类属性由父类初始化，子类属性由子类初始化</li>
</ul>
</li>
<li>
<p>注意细节</p>
<ul>
<li>
<p>当子类中有和父类中的属性和方法重名时，为了访问父类的属性和方法，必须通过 super。如果没有重名，使用 super，this，直接访问时一样的效果</p>
</li>
<li>
<p>super 的访问不限于直接父类，如果爷爷类和本类中有同名的属性或方法，也可以使用 super 去访问爷爷类的成员；如果多个上级类中都有重名的成员，使用 super 访问遵循就近原则，且遵守访问权限的相关规则</p>
</li>
</ul>
</li>
<li>
<p>this 和 super 的比较</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="8-10-方法重写-覆盖">8.10 方法重写/覆盖</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>方法覆盖（重写）就是指子类有一个方法，和父类的某个方法的名称、返回类型、参数都一样。那么我们就说子类的这个方法覆盖了父类的方法</li>
</ul>
</li>
<li>
<p>注意事项和使用细节</p>
<ul>
<li>
<p>子类方法的形参列表、方法名称必须要和父类的完全一样</p>
</li>
<li>
<p>子类方法的返回类型和父类方法的返回类型一样，或者是父类返回类型的子类<br>
比如父类返回 Object 类型，子类返回 String 类型，也构成方法重写</p>
</li>
<li>
<p>子类方法不能缩小父类方法的访问权限</p>
</li>
</ul>
</li>
<li>
<p>重写与重载的比较</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="8-11-多态">8.11 多态</h3>
<ul>
<li>
<p>引出</p>
<ul>
<li>
<p>传统的方法存在代码的复用性不高，不利于代码维护等缺点</p>
<ul>
<li>于是需要引入多态来解决</li>
</ul>
</li>
</ul>
</li>
<li>
<p>基本介绍</p>
<ul>
<li>方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的</li>
</ul>
</li>
<li>
<p>多态的具体体现</p>
<ul>
<li>
<p>方法的多态</p>
<ul>
<li>
<p>方法重写</p>
</li>
<li>
<p>方法重载</p>
</li>
</ul>
</li>
<li>
<p>对象的多态</p>
<ul>
<li>
<p>首先，几句前置知识</p>
<ul>
<li>
<p>一个对象的编译类型和运行类型可以不一致</p>
</li>
<li>
<p>编译类型在定义对象时，就确定了，不能改变</p>
</li>
<li>
<p>运行类型是可以变化的</p>
</li>
<li>
<p>编译类型看定义时 = 的左边，运行类型看 = 的右边</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>多态的注意事项和细节</p>
<ul>
<li>
<p>前提</p>
<ul>
<li>对象多态的前提是：两个对象（类）存在继承关系</li>
</ul>
</li>
<li>
<p>向上转型</p>
<ul>
<li>
<p>本质：父类的引用指向了子类的对象</p>
</li>
<li>
<p>语法： 父类类型 引用名 = new 子类类型();</p>
</li>
<li>
<p>特点</p>
<ul>
<li>
<p>编译类型看左边，运行类型看右边</p>
</li>
<li>
<p>可以调用编译类型中的所有成员（需要遵循访问权限）</p>
</li>
<li>
<p>不能调用运行类型中的特有成员</p>
</li>
<li>
<p>最终运行效果决定于运行类型的具体实现（即调用方法时，按照从运行类型开始查找方法的调用规则【同继承】来查找方法）</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>向下转型</p>
<ul>
<li>
<p>语法： 子类类型 引用名 = (子类类型)父类引用;</p>
</li>
<li>
<p>特点</p>
<ul>
<li>
<p>只是强转父类的引用，不是强转父类的对象（即只是引用类型被转变，具体对象在内存中的形式没有变化）</p>
</li>
<li>
<p>要求父类的引用必须指向的是当前强转类型的对象</p>
</li>
<li>
<p>当向下转型后，可以调用子类中所有成员（遵循访问限制）</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>属性没有重写一说！直接调用属性时具体属性的值取决于编译类型</p>
</li>
<li>
<p>instanceof 比较操作符，用于判断对象的【运行】类型是否为 XX 类型或者 XX 类型的子类</p>
</li>
</ul>
</li>
<li>
<p>动态绑定机制</p>
<ul>
<li>
<p>当调用对象方法的时候，该方法会和该对象的运行类型绑定（即调用对象方法时，总是调用该对象的运行类型的方法，若没有，才依次往上看）</p>
</li>
<li>
<p>当在方法中调用对象属性时，没有动态绑定机制，其返回的值遵循就近原则</p>
</li>
</ul>
</li>
<li>
<p>应用</p>
<ul>
<li>
<p>多态数组</p>
<ul>
<li>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型</li>
</ul>
</li>
<li>
<p>多态参数</p>
<ul>
<li>方法定义的形参类型为父类类型，实参类型允许为子类类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8-12-Object类详解">8.12 Object类详解</h3>
<ul>
<li>
<p>equals 方法</p>
<ul>
<li>
<p>== 和 equals 对比</p>
<ul>
<li>
<p>== 是一个比较运算符，equals 是一个方法</p>
</li>
<li>
<p>== 既可以判断基本类型，又可以判断引用类型</p>
</li>
<li>
<p>== 如果判断基本类型，判断的是值是否相等</p>
</li>
<li>
<p>== 如果判断引用类型，判断的是地址是否相等</p>
</li>
<li>
<p>equals 是 Object 类方法，只能判断引用类型</p>
</li>
<li>
<p>equals 默认判断的是地址是否相等，子类往往重写该方法，用于判断内容是否相等</p>
</li>
</ul>
</li>
<li>
<p>重写 equals 方法</p>
<ul>
<li>
<p>先判断是否是本身，是则返回 true</p>
</li>
<li>
<p>再判断类型是否匹配，是则判断值，不是则返回 false</p>
</li>
<li>
<p>类型如果匹配，则判断值，值都相等，则返回 false</p>
</li>
<li>
<p>如果上述均不满足，则返回 false</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>hashCode 方法</p>
<ul>
<li>
<p>用处：提高具有哈希结构的容器的效率</p>
</li>
<li>
<p>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的</p>
</li>
<li>
<p>两个引用，如果指向的是不同对象，则哈希值一般不同</p>
</li>
<li>
<p>哈希值主要是根据地址来算得的，但并不等价于地址</p>
</li>
<li>
<p>后面在集合中，hashCode 如果需要的话也会重写，在讲解集合时会说如何重写</p>
</li>
</ul>
</li>
<li>
<p>toString 方法</p>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>默认返回：全类名 + @ + 哈希值的十六进制<br>
子类往往重写 toString 方法，用于返回对象的属性信息</li>
</ul>
</li>
<li>
<p>重写 toString 方法</p>
<ul>
<li>是为了打印对象或拼接对象时，调用该对象的 toString 方法来方便开发</li>
</ul>
</li>
<li>
<p>当直接输出一个对象时，toString 方法会被默认调用</p>
</li>
</ul>
</li>
<li>
<p>finalize 方法</p>
<ul>
<li>
<p>当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作</p>
</li>
<li>
<p>什么时候被回收：当某个对象没有任何引用时，则 JVM 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁对象前，会调用 finalize 方法</p>
</li>
<li>
<p>垃圾回收机制的调用，是由系统来决定（有自己的 GC 算法），也可以通过 System.gc() 来主动调用垃圾回收期</p>
</li>
<li>
<p>注：在实际开发中，几乎不会运用 finalize，所以更多是为了应付面试</p>
</li>
</ul>
</li>
</ul>
<h3 id="8-13-断点调试">8.13 断点调试</h3>
<h3 id="8-14-零钱通项目">8.14 零钱通项目</h3>
<h2 id="第九章：房屋出租系统">第九章：房屋出租系统</h2>
<h3 id="分层模式设计">分层模式设计</h3>
<ul>
<li></li>
</ul>
<h3 id="源码">源码</h3>
<ul>
<li>
<p>HouseInterface.java</p>
</li>
<li>
<p>HouseService.java</p>
</li>
<li>
<p>Utility.java</p>
</li>
<li>
<p>House.java</p>
</li>
<li>
<p>HouseRentApp.java</p>
</li>
</ul>
<h2 id="第十章：面向对象编程（高级）">第十章：面向对象编程（高级）</h2>
<h3 id="10-1-类变量和类方法">10.1 类变量和类方法</h3>
<ul>
<li>
<p>类变量</p>
<ul>
<li>
<p>什么是类变量</p>
<ul>
<li>类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。</li>
</ul>
</li>
<li>
<p>如何定义类变量</p>
<ul>
<li>访问修饰符 static 数据类型 变量名;</li>
</ul>
</li>
<li>
<p>如何访问类变量</p>
<ul>
<li>
<p>类名.类变量名</p>
</li>
<li>
<p>对象名.类变量名</p>
</li>
</ul>
</li>
<li>
<p>类变量的内存布局</p>
<ul>
<li></li>
<li>
<p>static 变量是同一个类所有对象共享<br>
static 类变量，在类加载的时候就生成了</p>
</li>
</ul>
</li>
<li>
<p>类变量使用注意事项和细节讨论</p>
<ul>
<li>
<p>什么时候需要用类变量</p>
<ul>
<li>当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量</li>
</ul>
</li>
<li>
<p>类变量与实例变量的区别</p>
<ul>
<li>类变量时该类的所有对象共享的，而实例变量是每个对象独享的</li>
</ul>
</li>
<li>
<p>加上 static 称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量</p>
</li>
<li>
<p>类变量可以通过类名.类变量名或者对象名.类变量名来访问，推荐使用前者方式访问【前提是：满足访问修饰符的访问权限和范围】</p>
</li>
<li>
<p>实例变量不能通过类名.类变量名来访问</p>
</li>
<li>
<p>类变量是在类加载时就初始化了，也就是说，即使没有创建对象，只要类加载了，就可以使用类变量了</p>
</li>
<li>
<p>类变量的生命周期是随类的加载开始，随着类消亡而销毁</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>类方法</p>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>类方法也叫静态方法，形式如下：<br>
访问修饰符 static 数据返回类型 方法名（）{ }</li>
</ul>
</li>
<li>
<p>调用</p>
<ul>
<li>类名.类方法名或对象名.类方法名【前提要满足访问修饰符的访问权限和范围】</li>
</ul>
</li>
<li>
<p>Best Practice</p>
<ul>
<li>
<p>当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率<br>
【即这个方法不跟对象捆绑使用，则就可以设计成静态方法】</p>
</li>
<li>
<p>在程序员实际开发中，往往会将一些通用的方法设计成静态方法，这样我们不需要创建对象就可以使用了</p>
</li>
</ul>
</li>
<li>
<p>类方法使用注意事项和细节讨论</p>
<ul>
<li>
<p>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：<br>
类方法中不能使用this关键字，但普通方法可以</p>
</li>
<li>
<p>类方法可以通过类名调用，也可以通过对象名调用</p>
</li>
<li>
<p>普通方法和对象有关，需要通过对象名调用，不能通过类名调用</p>
</li>
<li>
<p>类方法中不允许使用和对象有关的关键字，比如 this 和 super，普通方法可以</p>
</li>
<li>
<p>静态方法只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员【遵守访问权限】</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="10-2-理解-main-方法语法">10.2 理解 main 方法语法</h3>
<ul>
<li>
<p>深入理解 main 方法</p>
<ul>
<li>
<p>main 方法是由 JVM 调用的</p>
</li>
<li>
<p>JVM 在执行 main() 方法时不必创建对象，所以该方法必须是 static</p>
</li>
<li>
<p>JVM 需要调用类的 main 方法，所以该方法的访问权限必须是 public</p>
</li>
<li>
<p>该方法接受 String 类型的数组参数，该数组中保存执行 Java 命令时所传递给所运行的类的参数</p>
</li>
<li>
<p>传值命令： java 执行的程序 参数1 参数2 参数3…</p>
</li>
</ul>
</li>
<li>
<p>特别提示</p>
<ul>
<li>
<p>在 main() 方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性（静态成员）</p>
</li>
<li>
<p>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员<br>
【即同 static 的访问规则】</p>
</li>
</ul>
</li>
<li>
<p>在 idea 中如何传递参数</p>
<ul>
<li>run 旁边的三点-&gt; run with parameters -&gt; 在 program arguments 处添加</li>
</ul>
</li>
</ul>
<h3 id="10-3-代码块">10.3 代码块</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>代码块又称初始化块，属于类中的成员，类似于方法将逻辑语句封装在方法体中，通过 {} 包围起来</p>
</li>
<li>
<p>但和方法不同，没有方法名，没有返回数据类型，没有参数，只有方法体，而且不用通过对象或类显式调用，而是在加载类或创建对象时隐式调用</p>
</li>
</ul>
</li>
<li>
<p>基本语法</p>
<ul>
<li>
<p>[修饰符] {<br>
代码<br>
};</p>
</li>
<li>
<p>注意</p>
<ul>
<li>
<p>修饰符仅有 static，是可选项</p>
</li>
<li>
<p>代码块分为两类，使用 static 修饰的叫静态代码块，没有 static 修饰的，叫普通代码块</p>
</li>
<li>
<p>逻辑语句可以为任何语句</p>
</li>
<li>
<p>;可以写上，也可以省略</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>好处</p>
<ul>
<li>
<p>相当于构造器的补充，可以帮助构造器做初始化的工作</p>
</li>
<li>
<p>如果多个构造器中都有重复的语句，可以抽取到代码块中，提高代码的重用性</p>
</li>
</ul>
</li>
<li>
<p>使用注意事项和细节讨论</p>
<ul>
<li>
<p>static 代码块也叫静态代码块，作用就是对类进行初始化，它随着类的加载而执行，并且只会执行一次。普通代码块，每创建一个对象就执行一次</p>
</li>
<li>
<p>类何时被加载？</p>
<ul>
<li>
<p>创建对象实例时 (new)</p>
</li>
<li>
<p>创建子类对象实例，父类也会被加载<br>
联想继承下的对象创建顺序</p>
</li>
<li>
<p>使用类的静态成员(静态属性或方法）时</p>
</li>
</ul>
</li>
<li>
<p>普通的代码块，在创建对象实例时，会被隐式地调用，对象被创建一次，就会调用一次<br>
如果只是使用类的静态成员，普通代码块不会被调用</p>
</li>
</ul>
</li>
<li>
<p>创建一个对象时，在一个类中的调用顺序</p>
<ul>
<li>
<p>完成类加载，调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化的优先级一样，如果有多个静态代码块和多个静态属性初始化，则按他们定义的顺序来依次调用）</p>
</li>
<li>
<p>完成对象属性（非静态属性）的初始化，即调用普通代码块和普通属性的初始化（注意事项同上）</p>
</li>
<li>
<p>调用构造器完成构造器中的初始化</p>
</li>
</ul>
</li>
<li>
<p>构造器的最前面隐含了 super() 与普通代码块的调用和普通属性初始化（即在调用子类的构造器初始化之前，先完成父类的初始化和子类普通属性初始化（包括普通代码块调用）</p>
</li>
</ul>
<p>静态代码块和静态属性初始化在类加载时就执行完毕，因此其执行顺序是优先于构造器和普通代码块的</p>
<ul>
<li>
<p>具有继承关系的类创建对象时，静态代码块、属性，普通代码块、属性和构造器的调用顺序</p>
<ul>
<li>
<p>父类的静态代码块和静态属性</p>
</li>
<li>
<p>子类的静态代码块和静态属性</p>
</li>
<li>
<p>父类的普通代码块和普通属性初始化</p>
</li>
<li>
<p>父类的构造器</p>
</li>
<li>
<p>子类的普通代码块和普通属性初始化</p>
</li>
<li>
<p>子类的构造器</p>
</li>
</ul>
</li>
<li>
<p>静态代码块只能直接调用静态成员，普通代码块可以调用任意成员</p>
</li>
</ul>
<h3 id="10-4-单例设计模式">10.4 单例设计模式</h3>
<ul>
<li>
<p>什么是设计模式</p>
<ul>
<li>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格以及解决问题的思考方式。<br>
打个比方，设计模式就像是经典的棋谱，对于不同的棋局使用不同的棋谱，免去再思考和摸索的过程</li>
</ul>
</li>
<li>
<p>什么是单例模式</p>
<ul>
<li>
<p>单例（单个实例）（单个对象）</p>
<ul>
<li>
<p>所谓类的单例模式，就是采取一定的方法保证在整个软件系统中，对某个类只存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p>
</li>
<li>
<p>单例模式有两种方式：饿汉式和懒汉式</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>饿汉式和懒汉式单例模式的实现</p>
<ul>
<li>
<p>将构造器私有化 -&gt; 防止new生成更多对象</p>
</li>
<li>
<p>在类的内部创建静态对象</p>
</li>
<li>
<p>向外暴露一个静态的公共获取实例的方法</p>
</li>
</ul>
</li>
<li>
<p>饿汉式和懒汉式的区别</p>
<ul>
<li>
<p>二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载时就创建了对象实例，而懒汉式是在使用时才创建（具体是在调用 getInstance 方法时创建）</p>
</li>
<li>
<p>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</p>
</li>
<li>
<p>饿汉式存在资源浪费的可能，而懒汉式不存在这个问题</p>
</li>
<li>
<p>JavaSE 中的 java.lang.Runtime 就是经典的单例模式</p>
</li>
</ul>
</li>
</ul>
<h3 id="10-5-final-关键字">10.5 final 关键字</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>final 可以修饰类、属性、方法、局部变量和形参</p>
</li>
<li>
<p>有以下需求时，就会使用到 final</p>
<ul>
<li>
<p>当不希望某个类被继承时，可以用 final 关键字修饰</p>
</li>
<li>
<p>当不希望父类的某个方法被子类重写时，可以用 final 关键字修饰</p>
</li>
<li>
<p>当不希望类的某个属性的值被修改，就可以用 final 关键字修饰</p>
</li>
<li>
<p>当不希望某个局部变量被修改时，就可以使用 final 关键字修饰</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>注意事项和细节讨论</p>
<ul>
<li>
<p>final 修饰的属性又叫常量，一般用 XX_XXX_XX 来命名</p>
</li>
<li>
<p>final 修饰的属性在定义时必须赋初值，并且以后不能再修改，赋值可以在如下位置之一<br>
（1）定义时<br>
（2）在构造器中<br>
（3）在代码块中</p>
</li>
<li>
<p>如果final修饰的属性是静态的，则赋初值的位置只能是<br>
（1）定义时<br>
（2）在静态代码块中<br>
不能在构造器中赋值</p>
</li>
<li>
<p>final 类不能被继承，但能实例化对象</p>
</li>
<li>
<p>如果类不是 final 类，但是含有 final 类方法，则该方法虽然不能被重写，但是可以被继承</p>
</li>
<li>
<p>一般来说，如果一个类已经是 final 类了，就没有必要再将方法修饰成 final 方法</p>
</li>
<li>
<p>final 不能修饰构造器</p>
</li>
<li>
<p>final 和 static 往往搭配使用，用于在希望不进行类加载的情况下访问某个类的静态属性，这样会使效率更高，因为底层编译器对此做了优化</p>
</li>
<li>
<p>包装类和 String 也是 final 类</p>
</li>
</ul>
</li>
</ul>
<h3 id="10-6-抽象类">10.6 抽象类</h3>
<ul>
<li>
<p>为何需要？</p>
<ul>
<li>在继承中，当父类的某些方法需要声明，但又不确定如何实现时，可以将其声明为抽象方法，该类成为抽象类</li>
</ul>
</li>
<li>
<p>介绍</p>
<ul>
<li>
<p>用abstract关键字来修饰一个类时，这个类就叫抽象类</p>
</li>
<li>
<p>用abstract关键字来修饰一个方法时，这个方法就是抽象方法<br>
语法：访问修饰符 abstract 返回数据类型 方法名(参数列表)；</p>
</li>
<li>
<p>抽象类的价值更多在于设计，用于明晰子类所具有的方法和属性，并解决代码冗余问题</p>
</li>
<li>
<p>抽象类在框架和设计模式使用较多</p>
</li>
</ul>
</li>
<li>
<p>使用注意事项和细节讨论</p>
<ul>
<li>
<p>抽象类不能被实例化</p>
</li>
<li>
<p>抽象类不一定要包含抽象方法，也就是说抽象类可以没有抽象方法</p>
</li>
<li>
<p>一旦类包含了抽象方法，则这个类必须声明为抽象类</p>
</li>
<li>
<p>abstract关键字只能修饰类和方法，不能修饰属性和其他的</p>
</li>
<li>
<p>抽象类可以有任意成员【即抽象类的本质还是类，满足类的性质】</p>
</li>
<li>
<p>抽象方法不能有方法体（{}和其中的语句)，即不能实现</p>
</li>
<li>
<p>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为抽象类</p>
</li>
<li>
<p>抽象方法不能使用private，final和static修饰，因为这些关键字与重写相违背</p>
</li>
</ul>
</li>
</ul>
<h3 id="10-7-抽象类最佳实践：模板设计模式">10.7 抽象类最佳实践：模板设计模式</h3>
<ul>
<li>
<p>Best Practice 模板设计模式</p>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式</li>
</ul>
</li>
<li>
<p>能解决的问题</p>
<ul>
<li>
<p>当功能内部一部分实现时确定的，一部分时不确定的时，可以把不确定的部分暴露出去，让子类来实现</p>
</li>
<li>
<p>编写一个抽象父类，提供多个子类的通用方法，并把一个或多个方法留给其子类实现，这就是一种模板模式</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="10-8-接口">10.8 接口</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>接口就是给出一些没有实现的方法，封装到一起，当某个类要使用的时候，再根据具体情况把这些方法写出来</li>
</ul>
</li>
<li>
<p>语法</p>
<ul>
<li>
<p>interface 接口名{<br>
//属性<br>
//抽象方法<br>
}</p>
</li>
<li>
<p>class 类名 implements 接口{<br>
//自己属性<br>
//自己方法<br>
//必须实现的接口的抽象方法<br>
}</p>
</li>
</ul>
</li>
<li>
<p>深入理解接口</p>
<ul>
<li>
<p>接口可用于设计规范，便于多人协作开发完成后将各个类组合起来使用</p>
</li>
<li>
<p>接口可以用来设计框架，明晰软件骨架</p>
</li>
</ul>
</li>
<li>
<p>注意事项和细节</p>
<ul>
<li>
<p>接口不能被实例化</p>
</li>
<li>
<p>接口中所有方法都是public方法，接口中的抽象方法可以不用abstract修饰</p>
</li>
<li>
<p>一个普通类实现接口，就必须将该接口的所有方法都实现</p>
</li>
<li>
<p>抽象类实现接口，可以不用实现接口的方法</p>
</li>
<li>
<p>一个类可以实现多个接口</p>
</li>
<li>
<p>接口中的属性，只能时final的，而且隐含public static final三个修饰符</p>
</li>
<li>
<p>接口中属性的访问方式：接口名.属性名</p>
</li>
<li>
<p>接口不能继承其他类，但是可以继承【多个】别的接口</p>
</li>
<li>
<p>接口的修饰符只能是public和默认，与类相同</p>
</li>
<li>
<p>1实现接口和继承类是同一层次的行为，如果一个类即继承了其他类，又实现了接口，父类和接口中存在同名属性时，在访问时就会产生混淆，所以必须指明是访问接口名.属性名还是super.属性名</p>
</li>
</ul>
</li>
<li>
<p>实现类vs继承接口</p>
<ul>
<li>
<p>继承：当子类继承了父类，就自动地拥有父类的功能<br>
实现接口：如果子类需要扩展功能，可以通过实现接口的方式扩展<br>
可以理解成：实现接口是对Java单继承机制的一种补充</p>
</li>
<li>
<p>接口和继承解决的问题不同</p>
<ul>
<li>
<p>继承的价值主要在于：解决代码的复用性和可维护性</p>
</li>
<li>
<p>接口的价值主要在于：设计好各种规范（方法），让其他类去实现这些方法，更加灵活</p>
</li>
<li>
<p>接口比继承更加灵活，继承要满足is-a关系，接口只需满足like-a关系</p>
</li>
<li>
<p>接口在一定程度上可实现代码解耦（接口规范性+动态绑定机制）</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>接口的多态特性</p>
<ul>
<li>
<p>多态参数</p>
<ul>
<li>即方法的参数可以用接口数据类型的参数指向实现了该接口的类的对象，并在运行时动态绑定</li>
</ul>
</li>
<li>
<p>多态数组</p>
<ul>
<li>用法同前多态数组</li>
</ul>
</li>
<li>
<p>多态传递</p>
<ul>
<li>如果接口继承了其他接口，则可以用父类接口数据类型指向实现了子接口的类的对象，这称为接口的多态传递</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="10-9内部类">10.9内部类</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>一个类的内部又完整地嵌套了另一个类结构，则被嵌套的类称为内部类，嵌套其的类称为外部类。内部类是类的第五大成员。内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系</li>
</ul>
</li>
<li>
<p>基本语法</p>
<ul>
<li>class Outer{<br>
class Inner{<br>
}<br>
}</li>
</ul>
</li>
</ul>
<p>class Other{<br>
}</p>
<ul>
<li>
<p>分类</p>
<ul>
<li>
<p>定义在外部类局部位置上（方法内和代码块内）</p>
<ul>
<li>
<p>局部内部类（有类名）</p>
</li>
<li>
<p>匿名内部类（无类名）</p>
</li>
</ul>
</li>
<li>
<p>定义在外部类的成员位置上（即定义类成员的地方）</p>
<ul>
<li>
<p>成员内部类（无static修饰）</p>
</li>
<li>
<p>静态内部类（有static修饰）</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>局部内部类</p>
<ul>
<li>
<p>使用</p>
<ul>
<li>
<p>可以直接访问外部类的所有成员，包括私有</p>
</li>
<li>
<p>不能添加访问修饰符，因为它的地位就是一个局部变量，局部变量是不能使用修饰符的。但可以用final修饰，因为局部变量也可以用</p>
</li>
<li>
<p>作用域：仅仅在定义它的方法或代码块中</p>
</li>
<li>
<p>局部内部类访问外部类成员，直接访问</p>
</li>
<li>
<p>外部类访问局部内部类成员，通过创建对象访问</p>
</li>
<li>
<p>外部其他类不能访问局部内部类</p>
</li>
<li>
<p>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）来访问</p>
</li>
<li>
<p>局部内部类本质仍然是一个类，所以适用于类的规定和特性</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>匿名内部类</p>
<ul>
<li>
<p>理解</p>
<ul>
<li>
<p>本质是类</p>
</li>
<li>
<p>是内部类</p>
</li>
<li>
<p>该类没有名字</p>
</li>
<li>
<p>同时还是一个对象</p>
</li>
</ul>
</li>
<li>
<p>语法</p>
<ul>
<li>new 类或接口(参数列表){<br>
类体<br>
};</li>
</ul>
</li>
<li>
<p>为何需要</p>
<ul>
<li>在某些场景中，我们想使用一个接口并实现该接口并创建对象调用方法。使用传统方法会造成资源浪费，当只需使用一次该类时，就可以用内部匿名类来简化开发</li>
</ul>
</li>
<li>
<p>基于接口的匿名内部类</p>
<ul>
<li>
<p>语法：<br>
接口名 对象引用 = new 接口(){<br>
类体<br>
};</p>
<ul>
<li>相当于定义一个实现了该接口的匿名内部类，类体为实现内容</li>
</ul>
</li>
<li>
<p>底层细节</p>
<ul>
<li>在执行new 接口(){};时，等价于执行class 外部类名$1234… implements 接口{};并立马创建了匿名内部类的实例返回给对象引用，随后这个匿名内部类就被销毁，即不能在后续代码中再通过new 外部类名$1234… 来创建新的对象实例</li>
</ul>
</li>
</ul>
</li>
<li>
<p>基于类的匿名内部类</p>
<ul>
<li>
<p>语法：<br>
父类名 对象引用 = new 类(参数列表){<br>
类体<br>
};</p>
<ul>
<li>相当于定义一个继承了该类的匿名内部类，类体为继承后的子类的特有内容或重写方法，参数列表中的参数传递给父类的构造器（如果有有参的话）</li>
</ul>
</li>
<li>
<p>底层细节同上</p>
</li>
</ul>
</li>
<li>
<p>细节</p>
<ul>
<li>
<p>匿名内部类的语法比较奇特，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征</p>
</li>
<li>
<p>可以直接访问外部类的所有成员，包括私有</p>
</li>
<li>
<p>不能添加访问修饰符，因为它的地位就是一个局部变量</p>
</li>
<li>
<p>作用域：仅仅在定义它的方法或代码块中</p>
</li>
<li>
<p>匿名内部类访问外部类成员，直接访问</p>
</li>
<li>
<p>外部类访问匿名内部类成员，不能访问</p>
</li>
<li>
<p>外部其他类访问匿名内部类，不能访问</p>
</li>
<li>
<p>如果外部类和匿名内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）来访问</p>
</li>
</ul>
</li>
<li>
<p>Best Practice</p>
<ul>
<li>
<p>将匿名内部类当作实参直接传递，简洁高效省资源</p>
</li>
<li>
<p>f1(new IL() {<br>
@Override<br>
public void show() {<br>
System.out.println(“这是一副名画~~…”);<br>
}<br>
});</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>成员内部类</p>
<ul>
<li>
<p>定义：成员内部类时定义在外部类成员位置，并且没有static修饰的类</p>
</li>
<li>
<p>细节</p>
<ul>
<li>
<p>可以直接访问外部类的所有成员，包括私有的</p>
</li>
<li>
<p>可以添加任意访问修饰符，因为它的地位就是一个成员</p>
</li>
<li>
<p>作用域是整个外部类</p>
</li>
<li>
<p>成员内部类访问外部类成员，直接访问</p>
</li>
<li>
<p>外部类访问成员内部类，先创建对象再访问</p>
</li>
<li>
<p>外部其他类访问成员内部类有两种方式</p>
<ul>
<li>
<p>把new 内部类当作外部类的成员<br>
Outer08 outer08 = new Outer08();<br>
Outer08.Inner08 inner08 = outer08.new Inner08();</p>
</li>
<li>
<p>在外部类中编写一个方法，返回内部类的对象<br>
public Inner08 getInner08Instance(){<br>
return new Inner08();<br>
}</p>
</li>
</ul>
</li>
<li>
<p>如果外部类和成员内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）来访问</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>静态内部类</p>
<ul>
<li>
<p>定义：静态内部类是定义在外部类的成员位置，并且有static修饰的类</p>
</li>
<li>
<p>细节</p>
<ul>
<li>
<p>可以直接访问外部类的所有静态成员，包括私有，但不能访问非静态成员</p>
</li>
<li>
<p>可以添加任意访问修饰符，因为它的地位就是一个成员</p>
</li>
<li>
<p>作用域：整个外部类</p>
</li>
<li>
<p>静态内部类访问外部类静态成员，直接访问</p>
</li>
<li>
<p>外部类访问静态内部类成员，先创建对象，再访问</p>
</li>
<li>
<p>外部其他类访问静态内部类成员，有两种方式</p>
<ul>
<li>
<p>因为静态内部类，是可以通过类名直接访问(前提是满足访问权限)<br>
Outer10 outer10 = new Outer10();<br>
Outer10.Inner10 inner10 = new Outer10.Inner10();</p>
</li>
<li>
<p>编写一个方法，可以返回静态内部类的对象实例<br>
public static Inner10 getInner10_() {<br>
return new Inner10();<br>
}</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第十一章：枚举和注解">第十一章：枚举和注解</h2>
<h3 id="枚举enumeration">枚举enumeration</h3>
<ul>
<li>
<p>应用场景</p>
<ul>
<li>当定义的类中只客观存在几个有限的对象（比如季节）时，可以考虑将其设计为枚举类</li>
</ul>
</li>
<li>
<p>枚举说明</p>
<ul>
<li>
<p>枚举是一组常量的集合</p>
</li>
<li>
<p>可以这样理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象</p>
</li>
</ul>
</li>
<li>
<p>两种实现方法</p>
<ul>
<li>
<p>自定义类实现枚举</p>
<ul>
<li>
<p>步骤</p>
<ul>
<li>
<p>将构造器私有化，防止直接new新对象</p>
</li>
<li>
<p>本类内部创建一组对象供其他类调用</p>
</li>
<li>
<p>对外暴露对象（通过为对象添加public static final修饰符）</p>
</li>
<li>
<p>可以提供get方法获得对象属性，但不要提供set方法</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>使用enum关键字实现枚举</p>
<ul>
<li>
<p>步骤</p>
<ul>
<li>
<p>使用关键字enum替代class</p>
</li>
<li>
<p>区别于写public static final Season SPRING = new Season(“春天”, “温暖”);<br>
可以直接写SPRING(“春天”，“温暖”)，相当于系统帮你补充成了上面那一长串</p>
</li>
<li>
<p>如果枚举类中有多个对象，用“,&quot;间隔即可，最后加上”;“</p>
</li>
<li>
<p>如果使用enum来实现枚举，确保在类的最前面定义创建常量对象</p>
</li>
<li>
<p>如果使用无参构造器创建常量对象，则括号可以省略</p>
</li>
<li>
<p>其他成员比如属性、构造器、方法都可以自行添加以丰富对象的使用</p>
</li>
</ul>
</li>
<li>
<p>注意事项</p>
<ul>
<li>
<p>当我们使用enum关键字来开发一个枚举类时，默认会继承Enum类，而且会将我们自己的类设为final类，不能再被继承</p>
</li>
<li>
<p>传统的 public static final Season2 SPRING = new Season2(“春天”, “温暖”);                        简化成SPRING(“春天”, “温暖”)， 这里必<br>
须知道，它调用的是哪个构造器</p>
</li>
<li>
<p>如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略</p>
</li>
<li>
<p>当有多个枚举对象时，使用&quot;,&quot;间隔，最后由一个分号结尾</p>
</li>
<li>
<p>枚举对象必须放在枚举类的行首</p>
</li>
</ul>
</li>
<li>
<p>继承自Enum的常用方法有哪些</p>
<ul>
<li>
<p>toString</p>
<ul>
<li>Enum 类已经重写过了，返回的是当前对象<br>
名,子类可以重写该方法，用于返回对象的属性信息</li>
</ul>
</li>
<li>
<p>name</p>
<ul>
<li>返回当前对象名（常量名），子类中不能重写</li>
</ul>
</li>
<li>
<p>ordinal</p>
<ul>
<li>返回当前对象的位置号，默认从 0 开始<br>
位置号即为定义时的顺序号</li>
</ul>
</li>
<li>
<p>values</p>
<ul>
<li>返回当前枚举类中所有的常量（对象），是一个对象数组</li>
</ul>
</li>
<li>
<p>valueOf</p>
<ul>
<li>将字符串转换成枚举对象，要求字符串必须<br>
为已有的常量名，否则报异常！<br>
即搜索特定名字的枚举对象，搜不到的话就报错</li>
</ul>
</li>
<li>
<p>compareTo</p>
<ul>
<li>比较两个枚举常量，比较的就是位置号<br>
返回前一个对象的位置号 - 后一个对象的位置号</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>enum实现接口</p>
<ul>
<li>
<p>使用enum关键字后，就不能再继承其他类了，因为已经隐式继承Enum，而Java是单继承机制</p>
</li>
<li>
<p>enum实现的类本质上还是类，所以可以实现接口</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="注解">注解</h3>
<ul>
<li>
<p>理解</p>
<ul>
<li>
<p>注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息</p>
</li>
<li>
<p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息</p>
</li>
<li>
<p>在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角<br>
色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML配置等</p>
</li>
</ul>
</li>
<li>
<p>基本注解的介绍</p>
<ul>
<li>
<p>@Override</p>
<ul>
<li>
<p>限定某个方法是重写父类方法，该注解只能用于方法</p>
</li>
<li>
<p>使用说明</p>
<ul>
<li>
<p>@Override表示指定重写父类的方法（从编译层面验证），如果父类没有其重写的方法，则会报错</p>
</li>
<li>
<p>如果不写@Override注解，仍然可以重写父类方法</p>
</li>
<li>
<p>@Override只能修饰方法</p>
</li>
<li>
<p>@Target是修饰注解的注解，称为元注解</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>@Deprecated</p>
<ul>
<li>
<p>用于表示某个程序元素（类、方法等）已过时</p>
</li>
<li>
<p>可以修饰方法、类、字段、包、参数等等</p>
</li>
<li>
<p>@Deprecated可以起到帮助新旧版本的兼容和过渡的作用</p>
</li>
</ul>
</li>
<li>
<p>@SuppressWarnings</p>
<ul>
<li>
<p>抑制编译器警告</p>
</li>
<li>
<p>当我们不希望看到某种警告的时候，可以使用@SuppressWarnings来抑制（不显示）警告信息</p>
</li>
<li>
<p>在{”“}中，可以写入你希望抑制的警告信息</p>
</li>
<li>
<p>可以指定的警告类型有</p>
<ul>
<li>// all，抑制所有警告<br>
// boxing，抑制与封装/拆装作业相关的警告<br>
//cast，抑制与强制转型作业相关的警告<br>
//dep-ann，抑制与淘汰注释相关的警告<br>
//deprecation，抑制与淘汰的相关警告<br>
//fallthrough，抑制与 switch 陈述式中遗漏 break 相关的警告<br>
//finally，抑制与未传回 finally 区块相关的警告<br>
//hiding，抑制与隐藏变数的区域变数相关的警告<br>
//incomplete-switch，抑制与 switch 陈述式(enum case)中遗漏项目相关的警告<br>
//javadoc，抑制与 javadoc 相关的警告<br>
//nls，抑制与非 nls 字串文字相关的警告<br>
//null，抑制与空值分析相关的警告<br>
//rawtypes，抑制与使用 raw 类型相关的警告<br>
//resource，抑制与使用 Closeable 类型的资源相关的警告<br>
//restriction，抑制与使用不建议或禁止参照相关的警告<br>
//serial，抑制与可序列化的类别遗漏 serialVersionUID 栏位相关的警告<br>
//static-access，抑制与静态存取不正确相关的警告<br>
//static-method，抑制与可能宣告为 static 的方法相关的警告<br>
//super，抑制与置换方法相关但不含 super 呼叫的警告<br>
//synthetic-access，抑制与内部类别的存取未最佳化相关的警告<br>
//sync-override，抑制因为置换同步方法而遗漏同步化的警告<br>
//unchecked，抑制与未检查的作业相关的警告<br>
//unqualified-field-access，抑制与栏位存取不合格相关的警告<br>
//unused，抑制与未用的程式码及停用的程式码相关的警告</li>
</ul>
</li>
<li>
<p>作用范围与放置的位置相关</p>
<ul>
<li>
<p>放置在方法上，则范围就是该方法</p>
</li>
<li>
<p>防止在类上，就是整个类</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="元注解">元注解</h3>
<ul>
<li>
<p>Retention</p>
<ul>
<li>指定注解的范围：SOURCE, CLASS, RUNTIME</li>
</ul>
</li>
<li>
<p>Target</p>
<ul>
<li>指定注解可以在哪些地方使用</li>
</ul>
</li>
<li>
<p>Documented</p>
<ul>
<li>指定该注解是否会在javadoc体现</li>
</ul>
</li>
<li>
<p>Inherited</p>
<ul>
<li>使用后子类会继承父类的注解</li>
</ul>
</li>
</ul>
<h2 id="第十二章：异常-Exception">第十二章：异常-Exception</h2>
<h3 id="12-1-引出">12.1 引出</h3>
<ul>
<li>为了防止程序运行过程和编译过程可能导致程序崩溃的不是特别重要的代码段使程序崩溃而使程序功能无法执行，引入异常处理机制，即使发生了异常，程序也可以继续执行</li>
</ul>
<h3 id="12-2-异常介绍">12.2 异常介绍</h3>
<ul>
<li>
<p>基本概念</p>
<ul>
<li>Java语言中，将程序执行中发生的不正常情况称为“异常”（开发过程中的语法错误和逻辑错误不是异常）</li>
</ul>
</li>
<li>
<p>分类</p>
<ul>
<li>
<p>错误Error</p>
<ul>
<li>Java虚拟机无法解决的严重问题。例如JVM系统内部错误，资源耗尽（stackoverflow栈溢出和OOM out of memory）。Error是严重错误，程序会崩溃</li>
</ul>
</li>
<li>
<p>异常Exception</p>
<ul>
<li>其他因变成错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等。Exception分为两大类：运行时异常（程序运行时发生的异常）和编译时异常（编译时，编译器检查出的异常）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="12-3-异常体系图">12.3 异常体系图</h3>
<ul>
<li></li>
<li>
<p>小结</p>
<ul>
<li>
<p>异常分为两大类，运行时异常和编译时异常</p>
</li>
<li>
<p>运行时异常，编译器检查不出来。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常</p>
</li>
<li>
<p>对于运行时异常，可以不做处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响</p>
</li>
<li>
<p>编译时异常，是编译器要求必须处置的异常</p>
</li>
</ul>
</li>
</ul>
<h3 id="12-4-常见的运行时异常">12.4 常见的运行时异常</h3>
<ul>
<li>
<p>NullPointerException</p>
</li>
<li>
<p>ArithmeticException</p>
</li>
<li>
<p>ArrayIndexOutOfBoundsException</p>
</li>
<li>
<p>ClassCastException</p>
</li>
<li>
<p>NumberFormatException</p>
</li>
</ul>
<h3 id="12-5-编译异常">12.5 编译异常</h3>
<ul>
<li>
<p>介绍</p>
<ul>
<li>编译异常是指在编译期间，就必须处理的异常，否则代码不能通过编译</li>
</ul>
</li>
<li>
<p>常见的编译异常</p>
<ul>
<li>
<p>SQLException操作数据库时，查询表可能发生的异常</p>
</li>
<li>
<p>IOException操作文件时，发生的异常</p>
</li>
<li>
<p>FileNotFoundException当操作一个不存在的文件时，发生异常</p>
</li>
<li>
<p>ClassNotFoundException加载类，而该类不存在时，发生异常</p>
</li>
<li>
<p>EOFException操作文件，到文件末尾，发生异常</p>
</li>
<li>
<p>IllegalArgumentException参数异常</p>
</li>
</ul>
</li>
</ul>
<h3 id="12-6-异常处理">12.6 异常处理</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>异常处理就是当异常发生时，对异常处理的一些方式</li>
</ul>
</li>
<li>
<p>方式</p>
<ul>
<li>
<p>try-catch-finally<br>
程序员在代码中捕获发生的异常，再自行处理</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>throws<br>
将发生的异常抛出给调用者，交给调用者（方法）来处理，最顶级的处理者是JVM</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="12-7-try-catch异常处理">12.7 try-catch异常处理</h3>
<ul>
<li>
<p>说明</p>
<ul>
<li>Java提供try和catch块来处理异常。try块用于包含可能出错的代码。catch块用于处理try块中发生的异常。可以根据需要在程序中有多个try…catch块</li>
</ul>
</li>
<li>
<p>基本语法</p>
<ul>
<li>try{<br>
//可疑代码<br>
}catch (异常名 e){<br>
//对异常的处理<br>
}</li>
</ul>
</li>
<li>
<p>注意事项</p>
<ul>
<li>
<p>如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块</p>
</li>
<li>
<p>如果异常没有发生，则顺序执行try代码块，不会进入到catch</p>
</li>
<li>
<p>如果希望不管是否发生异常，都执行某段代码（比如关闭连接，释放资源等），则使用finally代码块</p>
</li>
<li>
<p>可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求父类异常在后，子类异常在前，如果发生异常，只会匹配一个catch</p>
</li>
<li>
<p>可以try-finally配合使用，这种用法相当于没有捕获异常，因此程序发生异常会直接崩溃。应用场景：执行一代代码，不管是否发生异常，都必须执行某个业务逻辑</p>
</li>
</ul>
</li>
<li>
<p>小结</p>
<ul>
<li>
<p>如果没有出现异常，则执行try块中所有语句，不执行catch块中语句，如果有finally，最后还要执行finally里面的语句</p>
</li>
<li>
<p>如果出现异常，则try块中异常发生后，try块剩下的语句不在执行。将执行catch语句块中的语句，如果有finally，最后还需要执行finally里面的语句</p>
</li>
</ul>
</li>
</ul>
<h3 id="12-8-throws异常处理">12.8 throws异常处理</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</p>
</li>
<li>
<p>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p>
</li>
</ul>
</li>
<li>
<p>注意事项和使用细节</p>
<ul>
<li>
<p>对于编译异常，程序中必须处理，要么try-catch，要么throws</p>
</li>
<li>
<p>对于运行时异常，程序中如果没有处理，默认是throws方法处理</p>
</li>
<li>
<p>子类重写父类方法时，对抛出异常的规定：子类重写的方法所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出异常类型的子类</p>
</li>
<li>
<p>在throws过程中，如果有方法try-catch，就相当于处理异常，则可以不必throws</p>
</li>
</ul>
</li>
</ul>
<h3 id="12-9-自定义异常">12.9 自定义异常</h3>
<ul>
<li>
<p>基本概念</p>
<ul>
<li>当程序中出现了某些“错误”，但该错误并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息</li>
</ul>
</li>
<li>
<p>自定义异常步骤</p>
<ul>
<li>
<p>定义类，class 异常类名 extends Exception或者RuntimeException</p>
</li>
<li>
<p>如果继承Exception，则属于编译时异常</p>
</li>
<li>
<p>如果继承RuntimeException，属于运行时异常（一般都继承RuntimeException）</p>
</li>
</ul>
</li>
</ul>
<h3 id="12-10-throw和throws的区别">12.10 throw和throws的区别</h3>
<ul>
<li>
<p>一览表</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h2 id="第十三章：常用类">第十三章：常用类</h2>
<h3 id="13-1-包装类">13.1 包装类</h3>
<ul>
<li>
<p>包装类的分类</p>
<ul>
<li>
<p>针对八种基本数据类型相应的引用类型-包装类</p>
</li>
<li>
<p>有了类的特点，就可以调用类中的方法</p>
</li>
<li>
<p>八大包装类的类继承关系</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<p>包装类和基本数据的转换</p>
<ul>
<li>
<p>JDK5之前是手动装箱和拆箱<br>
手动装箱：int n1 = 100;<br>
Integer integer = new Integer(n1);<br>
Integer integer1 = Integer.valueOf(n1）<br>
手动拆箱：int i = integer.intValue()</p>
</li>
<li>
<p>JDK5（含）以后，是自动装箱和拆箱方式<br>
自动装箱：int n2 = 200；<br>
Integer integer2 = n2; //底层使用的是 Integer.valueOf(n2)<br>
自动拆箱：int n3 = integer2; //底层仍然使用的是 intValue()方法</p>
</li>
<li>
<p>自动装箱底层调用的是valueOf方法，拆箱调用的是typeValue方法</p>
</li>
<li>
<p>其他包装类的用法类似，不一一举例</p>
</li>
</ul>
</li>
<li>
<p>包装类型和String类型的相互转换</p>
<ul>
<li>
<p>方式1：String str1 = i + “”;（i为包装类型）</p>
</li>
<li>
<p>方式2：String str2 =i.toString();<br>
调用包装类的toString方法</p>
</li>
<li>
<p>方式3：String str3 = String.valueOf(i);<br>
调用包装类的valueOf方法</p>
</li>
</ul>
</li>
<li>
<p>Integer类和Character类常用方法</p>
<ul>
<li>
<p>Integer</p>
<ul>
<li>
<p>MIN_VALUE返回Integer类型的最小值</p>
</li>
<li>
<p>MAX_VALUE返回Integer类型的最大值</p>
</li>
</ul>
</li>
<li>
<p>Character</p>
<ul>
<li>
<p>isDigit判断是否是数字</p>
</li>
<li>
<p>isLetter判断是否是字母</p>
</li>
<li>
<p>isUpperCase判断是否是大写</p>
</li>
<li>
<p>isLowerCase判断是否是小写</p>
</li>
<li>
<p>isWhitespace判断是否是空格</p>
</li>
<li>
<p>toUpperCase转成大写</p>
</li>
<li>
<p>toLowerCase转成小写</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Integer类自动装箱的特性</p>
<ul>
<li>
<p>//1. 如果 i 在 IntegerCache.low(-128)~IntegerCache.high(127),就直接从数组返回<br>
//2. 如果不在 -128~127,就直接 new Integer()</p>
</li>
<li>
<p>比如</p>
<ul>
<li>
<p>Integer i = new Integer;<br>
Integer j = new Integer;<br>
System.out.println(i == j);// False</p>
</li>
<li>
<p>Integer m = 1; //底层 Integer.valueOf; -&gt; 阅读源码<br>
Integer n = 1;//底层 Integer.valueOf;<br>
System.out.println(m == n); // True</p>
</li>
</ul>
</li>
<li>
<p>如果包装类和对应的基本数据类型比较大小，则比较的是值，不是地址</p>
</li>
</ul>
</li>
</ul>
<h3 id="13-2-String类">13.2 String类</h3>
<ul>
<li>
<p>String类的理解和创建对象</p>
<ul>
<li>
<p>理解</p>
<ul>
<li>
<p>String对象用于保存字符串，也就是一组字符序列</p>
</li>
<li>
<p>字符串常量是用双引号括起的字符序列</p>
</li>
<li>
<p>字符串的字符使用Unicode字符编码，一个字符（不区分是字母还是汉字）占两个字节</p>
</li>
<li>
<p>String类有很多构造器，构造器的重载，常用的有<br>
//String s1 = new String();<br>
//String s2 = new String(String original);<br>
//String s3 = new String(char[] a);<br>
//String s4 = new String(char[] a,int startIndex,int count)<br>
//String s5 = new String(byte[]</p>
</li>
</ul>
</li>
<li>
<p>String类实现了接口Serializable（String可以串行化：可以在网络传输）<br>
实现了接口Comparable（String对象可以比较大小）</p>
</li>
<li>
<p>String是final类，不能被其他类继承</p>
</li>
<li>
<p>String有属性private final char value[]，用于存放字符串常量的地址</p>
</li>
<li>
<p>一定要注意：value是一个final类型，不可以被修改，即value不能指向新的地址，但是可以修改value指向的地址中的内容</p>
</li>
</ul>
</li>
<li>
<p>创建String对象的两种方式</p>
<ul>
<li>
<p>方式1：直接赋值String s = “xxx”;</p>
</li>
<li>
<p>方式2：调用构造器String s = new String(“xxx”);</p>
</li>
<li>
<p>区别</p>
<ul>
<li>
<p>方式一：先从常量池查看是否有&quot;xxx&quot;数据空间，如果有，直接让s指向该数据空间；如果没有，则创建，然后让s指向。s最终指向的是常量池的空间地址</p>
</li>
<li>
<p>方式二：先在堆中创建空间，里面维护了value属性，指向常量池的&quot;xxx&quot;空间。如果常量池中没有&quot;xxx&quot;，则创建，再让value指向。最终s指向的是堆中value所存储的地址，通过value指向常量池中的字符串</p>
</li>
</ul>
</li>
<li>
<p>内存布局</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="13-3-字符串的特性">13.3 字符串的特性</h3>
<ul>
<li>
<p>String是一个final类，代表不可变的字符序列</p>
</li>
<li>
<p>字符串是不可变的。一个字符串对象一旦被分配，其指向内容是不可变的。改变指向对象实际上是新创建了一个String对象再重新指向该String对象</p>
</li>
<li>
<p>直接String s = “abc” + “efg&quot;会被优化成<br>
String s = “abcefg”，不会分别创建&quot;abc&quot;和&quot;efg”，而只创建&quot;abcefg&quot;<br>
所以只创建1个对象</p>
</li>
<li>
<p>String a = “1”;<br>
String b = “2”;<br>
String c = a + b;</p>
<ul>
<li>底层是创建StringBuilder sb = new StringBuilder(); sb.append(a); sb.append(b)<br>
来创建String对象的</li>
</ul>
</li>
<li>
<p>intern方法返回的是常量池中字符串常量的地址</p>
</li>
</ul>
<h3 id="13-4-String类的常用方法">13.4 String类的常用方法</h3>
<ul>
<li>
<p>小说明</p>
<ul>
<li>String类是保存字符串常量的，每次更新都需要重新开辟空间，效率较低，因此Java设计者还提供了StringBuilder和StringBuffer来增强String的功能，并提高效率</li>
</ul>
</li>
<li>
<p>equals</p>
<ul>
<li>判断字符串内容是否相等，区分大小写</li>
</ul>
</li>
<li>
<p>equalsIgnoreCase</p>
<ul>
<li>不区分大小写，判断字符串内容是否相等</li>
</ul>
</li>
<li>
<p>length</p>
<ul>
<li>获取字符串的长度，即字符的个数</li>
</ul>
</li>
<li>
<p>indexOf</p>
<ul>
<li>获取某个字符（串）在字符串中第一次出现位置的索引，索引从0开始，找不到则返回-1</li>
</ul>
</li>
<li>
<p>lastIndexOf</p>
<ul>
<li>获取某个字符（串）在字符串中最后一次出现位置的索引，索引从0开始，找不到则返回-1</li>
</ul>
</li>
<li>
<p>substring</p>
<ul>
<li>截取指定范围内的子串</li>
</ul>
</li>
<li>
<p>trim</p>
<ul>
<li>前后去空格</li>
</ul>
</li>
<li>
<p>charAt</p>
<ul>
<li>获取某索引处的字符，注意不能用s[index]这种方式来获取</li>
</ul>
</li>
<li>
<p>toUpperCase</p>
<ul>
<li>转成大写</li>
</ul>
</li>
<li>
<p>toLowerCase</p>
<ul>
<li>转成小写</li>
</ul>
</li>
<li>
<p>concat</p>
<ul>
<li>拼接另一个字符串到此字符串</li>
</ul>
</li>
<li>
<p>replace</p>
<ul>
<li>替换字符串中的所有某个字符（串）为某个字符（串），返回替换后的字符串</li>
</ul>
</li>
<li>
<p>split</p>
<ul>
<li>分割字符串，以某个字符为分割线，逢此字符就分割，返回一个字符串数组</li>
</ul>
</li>
<li>
<p>compareTo</p>
<ul>
<li>
<p>比较两个字符串的大小</p>
<ul>
<li>
<p>如果长度相同，并且每个字符也相同，就返回0</p>
</li>
<li>
<p>如果长度相同或不相同，但在比较时可以区分大小，就返回if (c1 != c2) {<br>
return c1 - c2;<br>
}</p>
</li>
<li>
<p>如果前面的部分都相同，就返回str1.length - str2.length</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>toCharArray</p>
<ul>
<li>返回字符串的字符数组</li>
</ul>
</li>
<li>
<p>format</p>
<ul>
<li>格式化字符串，格式化形式类似于C语言的输出语句的格式化字符串形式，返回格式化后的字符串。静态方法</li>
</ul>
</li>
</ul>
<h3 id="13-5-StringBuffer类">13.5 StringBuffer类</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>StringBuffer代表可变的字符序列，可以对字符串内容进行增删</p>
</li>
<li>
<p>很多方法与String相同，但StringBuffer是可变长度的</p>
</li>
<li>
<p>StringBuffer是一个容器</p>
</li>
<li>
<p>类继承关系</p>
<ul>
<li>
<p>直接父类是AbstractStringBuilder</p>
</li>
<li>
<p>实现了Serializable，即StringBuffer对象可以串行化</p>
</li>
<li>
<p>在父类AbstractStringBuilder类中有属性char[] value，但不是final，示意可以改变</p>
<ul>
<li>该value数组存放字符串内容，存放在堆中</li>
</ul>
</li>
<li>
<p>StringBuffer是final类，不可被继承</p>
</li>
<li>
<p>因为StringBuffer字符内容是存储在char[] value中，所以改变字符串内容是不用每次都更换地址，所以效率高于String</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>String和StringBuffer比较</p>
<ul>
<li>
<p>String保存的是字符串常量，里面的值不能更改，每次Sting类的更新实际上是创建新对象并更改地址，效率较低</p>
</li>
<li>
<p>StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上是更新内容，不用更新地址，效率较高</p>
</li>
</ul>
</li>
<li>
<p>String和StringBuffer的相互转换</p>
<ul>
<li>
<p>String转StringBuffer</p>
<ul>
<li>
<p>使用构造器</p>
<ul>
<li>StringBuffer stringBuffer = new StringBuffer(str)；</li>
</ul>
</li>
<li>
<p>使用append方法</p>
<ul>
<li>StringBuffer stringBuffer1 = new StringBuffer();<br>
stringBuffer1 = stringBuffer1.append(str)；</li>
</ul>
</li>
</ul>
</li>
<li>
<p>StringBuffer转String</p>
<ul>
<li>
<p>使用StringBuffer类的toString方法</p>
<ul>
<li>String s = stringBuffer3.toString；</li>
</ul>
</li>
<li>
<p>使用构造器</p>
<ul>
<li>String s1 = new String(stringBuffer);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>常用方法</p>
<ul>
<li>
<p>增</p>
<ul>
<li>
<p>append</p>
<ul>
<li>可以追加整数型，布尔型，浮点型，会被转换成字符串</li>
</ul>
</li>
</ul>
</li>
<li>
<p>删</p>
<ul>
<li>
<p>delete</p>
<ul>
<li>删除索引为[start, end)范围的字符</li>
</ul>
</li>
</ul>
</li>
<li>
<p>改</p>
<ul>
<li>
<p>replace</p>
<ul>
<li>使用字符串&quot;xxx&quot;替换索引[start, end)范围的字符</li>
</ul>
</li>
</ul>
</li>
<li>
<p>插</p>
<ul>
<li>
<p>insert</p>
<ul>
<li>在索引x处插入内容，x索引原内容后移</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="13-6-StringBuilder类">13.6 StringBuilder类</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>StringBuilder是一个可变的字符序列类。此类提供一个与StringBuffer兼容的API，但不保证同步（不是线程安全）。该类被设计用作StringBuffer的一个简易替换，用于字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer还快</p>
</li>
<li>
<p>在StringBuilder对象上的主要操作是append方法和insert方法，可重载这些方法，以接收任意类型的数据</p>
</li>
<li>
<p>类继承关系</p>
<ul>
<li>与StringBuffer一样</li>
</ul>
</li>
</ul>
</li>
<li>
<p>常用方法</p>
<ul>
<li>与StringBuffer一样</li>
</ul>
</li>
<li>
<p>String、StringBuffer 和 StringBuilder 的比较</p>
<ul>
<li>
<p>StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样</p>
</li>
<li>
<p>String：不可变字符序列，效率低，但复用率高</p>
</li>
<li>
<p>StringBuffer：可变字符序列，效率较高，线程安全</p>
</li>
<li>
<p>StringBuilder：可变字符序列，效率最高，线程不安全</p>
</li>
<li>
<p>String使用注意说明：<br>
String s = “a”;<br>
s += “b”;实际上原来的&quot;a&quot;字符串对象已经被丢弃了，现在又产生了一个字符串&quot;ab&quot;，如果多次执行这些改变串内容的操作，会导致大量的副本字符串对象留存在内容中，降低效率，如果这样的操作放到循环中，会极大影响程序的性能<br>
于是===》如果有要对字符串内容做大量修改，不要使用String类</p>
</li>
</ul>
</li>
<li>
<p>String、StringBuffer 和 StringBuilder 的选择</p>
<ul>
<li>
<p>使用的原则</p>
<ul>
<li>
<p>如果字符串存在大量的修改操作，一般使用StringBuffer和StringBuilder</p>
</li>
<li>
<p>如果字符串存在大量的修改操作，并在单线程的情况，一般使用StringBuilder</p>
</li>
<li>
<p>如果字符串存在大量的修改操作，并在多线程的情况，一般使用StringBuffer</p>
</li>
<li>
<p>如果字符串很少修改，被多个对象引用，使用String，比如配置信息等情况</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="13-7-Math类">13.7 Math类</h3>
<ul>
<li>
<p>Math类包含用于执行基本数学运算的方法，比如初等指数，对数，平方根和三角函数</p>
</li>
<li>
<p>基本方法</p>
<ul>
<li>
<p>abs</p>
<ul>
<li>绝对值</li>
</ul>
</li>
<li>
<p>pow</p>
<ul>
<li>幂</li>
</ul>
</li>
<li>
<p>ceil</p>
<ul>
<li>向上取整</li>
</ul>
</li>
<li>
<p>floor</p>
<ul>
<li>向下取整</li>
</ul>
</li>
<li>
<p>round</p>
<ul>
<li>四舍五入</li>
</ul>
</li>
<li>
<p>sqrt</p>
<ul>
<li>平方根</li>
</ul>
</li>
<li>
<p>random</p>
<ul>
<li>
<p>随机[0,1)之间的数</p>
<ul>
<li>
<p>返回[a,b]之间的整数，用random实现</p>
<ul>
<li>(int)(a + Math.random() * (b-a +1) )</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>min, max</p>
<ul>
<li>两个数中的最大值和最小值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="13-8-Arrays类">13.8 Arrays类</h3>
<ul>
<li>
<p>包含一系列静态常用方法</p>
<ul>
<li>
<p>toString</p>
<ul>
<li>返回数组的字符串形式</li>
</ul>
</li>
<li>
<p>sort</p>
<ul>
<li>
<p>自然排序</p>
<ul>
<li>从小到大排序数组元素</li>
</ul>
</li>
<li>
<p>定制排序</p>
<ul>
<li>
<p>可选择是从小到大还是从大到小</p>
<ul>
<li>
<p>Arrays.sort(arr, new Comparator() {<br>
@Override<br>
public int compare(Object o1, Object o2) {<br>
Integer i1 = (Integer) o1;<br>
Integer i2 = (Integer) o2;<br>
return i2 - i1;<br>
}<br>
});</p>
</li>
<li>
<p>接口编程</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>binarySearch</p>
<ul>
<li>二分搜索法，需要数组是有序的</li>
</ul>
</li>
<li>
<p>copyOf</p>
<ul>
<li>
<p>从原数组的开头拷贝x个元素到新数组中，返回新数组</p>
</li>
<li>
<p>如果拷贝的长度大于原数组的长度，则在新数组后加null</p>
</li>
<li>
<p>如果拷贝长度小于0，抛异常NegativeArraySizeException</p>
</li>
</ul>
</li>
<li>
<p>fill</p>
<ul>
<li>
<p>数组元素填充</p>
<ul>
<li>用某个数去填充数组中的所有元素</li>
</ul>
</li>
</ul>
</li>
<li>
<p>equals</p>
<ul>
<li>判断两个数组的内容是否完全一致</li>
</ul>
</li>
<li>
<p>asList</p>
<ul>
<li>
<p>将数组转换成一个List集合</p>
<ul>
<li>
<p>返回的 asList 编译类型是List(接口)</p>
</li>
<li>
<p>asList 运行类型是java.util.Arrays#ArrayList, 是 Arrays 类的<br>
静态内部类 private static class ArrayList<E> extends AbstractList<E><br>
implements RandomAccess, java.io.Serializable</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="13-9-System类">13.9 System类</h3>
<ul>
<li>
<p>类常用静态方法</p>
<ul>
<li>
<p>exit</p>
<ul>
<li>退出当前程序</li>
</ul>
</li>
<li>
<p>arraycopy</p>
<ul>
<li>
<p>复制数组元素，适合底层调用，一般不用</p>
</li>
<li>
<p>五个参数</p>
<ul>
<li>// src：源数组<br>
// srcPos：从源数组的哪个索引位置开始拷贝<br>
// dest : 目标数组，即把源数组的数据拷贝到哪个数组<br>
// destPos: 把源数组的数据拷贝到 目标数组的哪个索引<br>
// length: 从源数组拷贝多少个数据到目标数组</li>
</ul>
</li>
</ul>
</li>
<li>
<p>currentTimeMillens</p>
<ul>
<li>返回当前时间距离1970-1-1的毫秒数</li>
</ul>
</li>
<li>
<p>gc</p>
<ul>
<li>运行垃圾回收机制</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="13-10-BigInteger类和BigDecimal类">13.10 BigInteger类和BigDecimal类</h3>
<ul>
<li>
<p>应用场景</p>
<ul>
<li>
<p>BigInteger适合保存很大的整形</p>
</li>
<li>
<p>BigDecimal适合保存精度很高的浮点型</p>
</li>
</ul>
</li>
<li>
<p>常用方法</p>
<ul>
<li>
<p>add</p>
<ul>
<li>加</li>
</ul>
</li>
<li>
<p>substract</p>
<ul>
<li>减</li>
</ul>
</li>
<li>
<p>multiply</p>
<ul>
<li>乘</li>
</ul>
</li>
<li>
<p>divide</p>
<ul>
<li>
<p>除</p>
</li>
<li>
<p>System.out.println(bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING));</p>
<ul>
<li>在浮点数进行divide方法时，为了避免出现无限循环小数抛异常，常会规定输出精度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="13-11-日期类">13.11 日期类</h3>
<ul>
<li>
<p>第一代日期类Date</p>
<ul>
<li>
<p>介绍</p>
<ul>
<li>//1. 获取当前系统时间<br>
//2. 这里的 Date 类是在 java.util 包<br>
//3. 默认输出的日期格式是国外的方式, 因此通常需要对格式进行转换</li>
</ul>
</li>
<li>
<p>输出格式转换</p>
<ul>
<li>SimpleDateFormat sdf = new SimpleDateFormat(“yyyy 年 MM 月 dd 日 hh:mm:ss E”);<br>
String format = sdf.format(d1);<br>
// format:将日期转换成指定格式的字符串<br>
System.out.println(“当前日期=” + format);</li>
</ul>
</li>
<li>
<p>可以把一个格式化的String转成对应的Date</p>
<ul>
<li>
<p>String s = “1996 年 01 月 01 日 10:20:30 星期一”;<br>
Date parse = sdf.parse(s);</p>
</li>
<li>
<p>得到 Date 仍然在输出时，还是按照国外的形式，如果希望指定格式输出，需要转换</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在把 String -&gt; Date ， 使用的 sdf 格式需要和你给的 String 的格式一样，否则会抛出转换异常</p>
<ul>
<li>
<p>第二代日期类Calendar</p>
<ul>
<li>
<p>介绍</p>
<ul>
<li>Calendar 是一个抽象类， 并且构造器是private<br>
可以通过 getInstance() 来获取实例<br>
提供大量的方法和字段提供给程序员<br>
Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)<br>
如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=&gt; Calendar.HOUR_OF_DAY<br>
Calender 没有专门的格式化方法，所以需要程序员自己来组合显示</li>
</ul>
</li>
</ul>
</li>
<li>
<p>第三代日期类（JDK8加入）LocalTime,LocalDate,LocalDateTime</p>
<ul>
<li>
<p>介绍</p>
<ul>
<li>
<p>使用 now() 返回表示当前日期时间的对象<br>
LocalDateTime ldt = LocalDateTime.now(); <a target="_blank" rel="noopener" href="//LocalDate.now">//LocalDate.now</a>();<a target="_blank" rel="noopener" href="//LocalTime.now">//LocalTime.now</a>()</p>
</li>
<li>
<p>使用 DateTimeFormatter 对象来进行格式化<br>
DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”);<br>
String format = dateTimeFormatter.format(ldt);</p>
</li>
</ul>
</li>
<li>
<p>方法使用时查看API文档</p>
</li>
</ul>
</li>
<li>
<p>instant时间戳类</p>
<ul>
<li>
<p>介绍</p>
<ul>
<li>
<p>通过 静态方法 now() 获取表示当前时间戳的对象<br>
Instant now = Instant.now();</p>
</li>
<li>
<p>通过 from 可以把 Instant 转成Date<br>
Date date = Date.from(now);</p>
</li>
<li>
<p>通过 date 的 toInstant() 可以把 date 转成 Instant 对象<br>
Instant instant = date.toInstant();</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第十四章：集合">第十四章：集合</h2>
<h3 id="14-1-集合的好处">14.1 集合的好处</h3>
<ul>
<li>
<p>可以动态保存任意多个对象，使用比较方便</p>
</li>
<li>
<p>提供了一系列方便的操作对象的方法：add, remove, set, get等</p>
</li>
<li>
<p>使用集合添加或删除新元素的代码简洁明了</p>
</li>
</ul>
<h3 id="14-2-集合的框架体系">14.2 集合的框架体系</h3>
<ul>
<li>
<p>单列集合（即元素是单个个体）</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>双列集合（即元素通常是键值对的形式）</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="14-3-Collection接口和常用方法">14.3 Collection接口和常用方法</h3>
<ul>
<li>
<p>Collection接口实现类的特点</p>
<ul>
<li>
<p>实现类可以存放多个元素，每个元素可以是Object</p>
</li>
<li>
<p>有些实现类可以存放重复的元素（List的实现类），有些不可以（Set的实现类）</p>
</li>
<li>
<p>有些实现类的元素是有序的（List的实现类），有些不是有序的（Set的实现类）</p>
</li>
<li>
<p>Collection接口没有直接的实现子类，子类通过它的子接口List和Set来实现Collection接口</p>
</li>
</ul>
</li>
<li>
<p>常用方法</p>
<ul>
<li>
<p>add</p>
<ul>
<li>添加单个元素</li>
</ul>
</li>
<li>
<p>remove</p>
<ul>
<li>删除指定元素，可以指定索引或名称</li>
</ul>
</li>
<li>
<p>contains</p>
<ul>
<li>查找某元素是否存在</li>
</ul>
</li>
<li>
<p>size</p>
<ul>
<li>获取元素的个数</li>
</ul>
</li>
<li>
<p>isEmpty</p>
<ul>
<li>判断是否为空</li>
</ul>
</li>
<li>
<p>clear</p>
<ul>
<li>清空，不保留空间</li>
</ul>
</li>
<li>
<p>addAll</p>
<ul>
<li>添加多个元素，通常是添加另一个Collection的实现子类</li>
</ul>
</li>
<li>
<p>containsAll</p>
<ul>
<li>查找多个元素是否都存在，通常查找另一个Collection的实现子类中的元素是否都在</li>
</ul>
</li>
<li>
<p>removeAll</p>
<ul>
<li>删除多个元素，通常从该对象中删除另一个Collection实现子类中的含有的元素</li>
</ul>
</li>
</ul>
</li>
<li>
<p>实现了Collection接口的子类遍历元素的方式</p>
<ul>
<li>
<p>使用迭代器（iterator）</p>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>Iterator对象成为迭代器，主要用于遍历Collection集合实现子类中的元素</p>
</li>
<li>
<p>所有实现了Collection接口的子类都有一个iterator()方法，用以返回一个迭代该子类的迭代器</p>
</li>
<li>
<p>Iterator的结构</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>Iterator仅用于遍历集合，本身并不存放对象</p>
</li>
</ul>
</li>
<li>
<p>执行原理</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>其常用方法</p>
<ul>
<li>
<p>hasNext</p>
<ul>
<li>
<p>检查是否还存在下一个元素可以遍历</p>
<ul>
<li>如果不进行判断，可能抛出NoSuchElementException</li>
</ul>
</li>
</ul>
</li>
<li>
<p>next</p>
<ul>
<li>返回下一个遍历的元素</li>
</ul>
</li>
</ul>
</li>
<li>
<p>快捷键 itit</p>
</li>
</ul>
</li>
<li>
<p>增强for循环</p>
<ul>
<li>
<p>只能用于遍历集合或数组</p>
</li>
<li>
<p>快捷键 I</p>
</li>
</ul>
</li>
<li>
<p>普通for循环</p>
</li>
</ul>
</li>
</ul>
<h3 id="14-4-List-接口和常用方法">14.4 List 接口和常用方法</h3>
<ul>
<li>
<p>List接口基本介绍</p>
<ul>
<li>
<p>List实现类中元素有序（即添加顺序和取出顺序一致），且可重复</p>
</li>
<li>
<p>List实现类中的每个元素都有其对应的顺序索引，即支持索引（索引从0开始）</p>
</li>
<li>
<p>List实现类中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</p>
</li>
<li>
<p>List接口的实现类常用的有ArrayList, LinkedList和Vector</p>
</li>
</ul>
</li>
<li>
<p>List接口常用方法</p>
<ul>
<li>
<p>add</p>
<ul>
<li>添加元素，可以不带参数，默认添加到末尾，也可带参数，添加到索引处</li>
</ul>
</li>
<li>
<p>addAll</p>
<ul>
<li>添加另一个List中的元素到该List中，可以选择添加的位置</li>
</ul>
</li>
<li>
<p>get</p>
<ul>
<li>获取指定索引位置的元素</li>
</ul>
</li>
<li>
<p>indexOf</p>
<ul>
<li>返回参数对象在List中首次出现的位置</li>
</ul>
</li>
<li>
<p>lastIndexOf</p>
<ul>
<li>返回参数对象在List中末次出现的位置</li>
</ul>
</li>
<li>
<p>remove</p>
<ul>
<li>移除指定索引位置的元素，并返回该元素</li>
</ul>
</li>
<li>
<p>set</p>
<ul>
<li>设置指定索引位置的元素为参数对象，相当于是替换</li>
</ul>
</li>
<li>
<p>subList</p>
<ul>
<li>返回从第一个参数索引（含）到第二个参数索引（不含）的子List</li>
</ul>
</li>
</ul>
</li>
<li>
<p>List的三种遍历方式</p>
<ul>
<li>
<p>使用迭代器</p>
</li>
<li>
<p>使用增强for</p>
</li>
<li>
<p>使用普通for</p>
</li>
</ul>
</li>
</ul>
<h3 id="14-5-ArrayList-底层结构和源码分析">14.5 ArrayList 底层结构和源码分析</h3>
<ul>
<li>
<p>注意事项</p>
<ul>
<li>
<p>permits all elements， including null，ArrayList可以加入null，并且可加入多个。</p>
</li>
<li>
<p>ArrayList是由数组来实现数据存储的</p>
</li>
<li>
<p>ArrayList基本等同于Vector，除了ArrayList是线程不安全（效率高）。在多线程情况下不建议使用</p>
</li>
</ul>
</li>
<li>
<p>底层操作机制源码分析</p>
<ul>
<li>
<p>ArrayList中维护了一个Object类型的数组elementData。<br>
transient Object[] elementData;<br>
transient表示瞬间，短暂的，表示该属性不会被序列化</p>
</li>
<li>
<p>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData含量为0，第1次添加元素时，扩容到10，再需扩容时，扩容至1.5倍</p>
</li>
<li>
<p>如果使用的是指定大小的构造器，则初始elementData容量为构造器中指定大小，如果需要扩容，则直接扩容elementData为1.5倍。</p>
</li>
</ul>
</li>
</ul>
<h3 id="14-6-Vector-底层结构和源码剖析">14.6 Vector 底层结构和源码剖析</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>定义说明<br>
public class Vector<E><br>
extends AbstractList<E><br>
implements List<E>, RandomAccess, Cloneable, Serializable</p>
</li>
<li>
<p>Vector底层也是一个对象数组，protected Object[] elementData;</p>
</li>
<li>
<p>Vector是线程安全的，操作方法带有synchronized</p>
</li>
<li>
<p>在开放中，需要线程同步安全时，考虑使用Vector</p>
</li>
</ul>
</li>
<li>
<p>源码剖析</p>
<ul>
<li>
<p>使用无参构造器创建时，默认给容量10</p>
</li>
<li>
<p>使用有参构造器创建时，容量为指定容量</p>
</li>
<li>
<p>当需要扩容时，两倍扩容</p>
</li>
</ul>
</li>
<li>
<p>Vector和ArrayList比较</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="14-7-LinkedList-底层结构">14.7 LinkedList 底层结构</h3>
<ul>
<li>
<p>全面说明</p>
<ul>
<li>
<p>LinkedList底层实现了双向链表和双端队列特点</p>
</li>
<li>
<p>可以添加任意元素（可重复），包括null</p>
</li>
<li>
<p>线程不安全，没有实现同步</p>
</li>
</ul>
</li>
<li>
<p>底层操作机制</p>
<ul>
<li>
<p>LinkedList底层维护了一个双向链表</p>
</li>
<li>
<p>LinkedList中维护了两个属性first和last，分别指向首节点和尾节点</p>
</li>
<li>
<p>每个节点（Node对象）里面又维护了prev, next, item三个属性，其中通过prev指向前一个，通过next指向后一个节点，最终实现双向链表</p>
</li>
<li>
<p>所以LinkedList的元素的添加和删除不是通过数组来完成的，效率较高</p>
</li>
</ul>
</li>
</ul>
<h3 id="14-8-ArrayList-和-LinkedList-比较">14.8 ArrayList 和 LinkedList 比较</h3>
<ul>
<li>
<p>ArrayList和LinkedList比较及如何选择</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="14-9-Set-接口和常用方法">14.9 Set 接口和常用方法</h3>
<ul>
<li>
<p>Set接口基本介绍</p>
<ul>
<li>
<p>无序（添加和取出的顺序不一致），没有索引</p>
</li>
<li>
<p>不允许添加重复元素，所以最多包含一个null</p>
</li>
<li>
<p>常用Set实现类有HashSet, LinkedHashSet, TreeSet</p>
</li>
</ul>
</li>
<li>
<p>常用方法</p>
<ul>
<li>和List接口是一样，Set接口也是Collection的子接口，因此常用方法和Collection接口一样</li>
</ul>
</li>
<li>
<p>Set接口实现类的遍历方式</p>
<ul>
<li>
<p>使用迭代器</p>
</li>
<li>
<p>使用增强for</p>
</li>
</ul>
</li>
</ul>
<h3 id="14-10-Set-接口实现类-HashSet">14.10 Set 接口实现类-HashSet</h3>
<ul>
<li>
<p>全面说明</p>
<ul>
<li>
<p>HashSet实现了Set接口</p>
</li>
<li>
<p>HashSet底层实际上是HashMap，因为底层维护了一个HashMap，只不过将&lt;K, V&gt;对中的value全部都设为了同一个常量</p>
</li>
<li>
<p>可以存放null，但只能有一个null</p>
</li>
<li>
<p>HashSet不保证元素是有序的，取决于被hash后索引的位置</p>
</li>
<li>
<p>不能有重复元素/对象（因为是Set的实现类）</p>
</li>
</ul>
</li>
<li>
<p>添加元素底层机制说明</p>
<ul>
<li>
<p>（1）</p>
<ul>
<li>
<p>HashSet的底层是HashMap，HashMap的底层是数组+链表+红黑树</p>
</li>
<li>
<p>HashSet底层是HashMap</p>
</li>
<li>
<p>添加一个元素时，先得到hash值，再转成数组索引值</p>
</li>
<li>
<p>找到存储数据表（数组table，是 HashMap 的一个数组，存储的数据类型是 Node）对应索引位置，看这个位置是否已经存放有元素</p>
</li>
<li>
<p>如果没有，直接加入</p>
</li>
<li>
<p>如果有，调用【equals】依次比较，如果比较结果相同，就放弃添加，如果不相同，则加到最后</p>
</li>
<li>
<p>在Java8中，如果一条链表的元素个数到达8，并且table中（包括链表中）已有元素个数大于64，该条链表就会树化成红黑树来存储数据</p>
</li>
</ul>
</li>
<li>
<p>（2）</p>
<ul>
<li>
<p>HashSet底层是HashMap，第一次添加时，数组table扩容到16，临界值是16 * 0.75 = 12</p>
</li>
<li>
<p>如果table数组达到了临界值，就会扩容到32，新的临界值是32 * 0.75 = 24</p>
</li>
<li>
<p>在java8中，如果一条链表的元素个数到达8，并且table数组大小达到64，就会树化，否则继续扩大table数组</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="14-11-Set-接口实现类-LinkedHashSet">14.11 Set 接口实现类-LinkedHashSet</h3>
<ul>
<li>
<p>全面说明</p>
<ul>
<li>
<p>LinkedHashSet是HashSet的子类</p>
</li>
<li>
<p>LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表</p>
</li>
<li>
<p>LinkedHashMap根据元素的hash值来决定元素的存储位置，同时用双向链表维护元素的添加顺序，这使得元素看起来是以插入顺序保存的</p>
</li>
<li>
<p>不允许重复元素</p>
</li>
</ul>
</li>
</ul>
<h3 id="14-12-Map-接口和常用方法">14.12 Map 接口和常用方法</h3>
<ul>
<li>
<p>Map接口类的实现特点</p>
<ul>
<li>
<p>Map与Collection并列存在，其用于保存具有映射关系的数据：Key-Value</p>
</li>
<li>
<p>Map中的Key和Value可以是任何的引用类型的数据，会封装到HashMap$Node对象中</p>
</li>
<li>
<p>Map中的Key不允许重复，原因和HashSet一样（底层源码的规定）（即此映射关系只能一对一或者一对多，不能多对一）</p>
</li>
<li>
<p>Map中的value可以重复（即一对多）</p>
</li>
<li>
<p>Map中的Key可以为null，value也可以为null，但Key中的null只有一个，value可以有多个</p>
</li>
<li>
<p>常用String类作为Map的Key</p>
</li>
<li>
<p>key和value之间存在单项一对一关系，即通过指定的key总能找到对应的value</p>
</li>
<li>
<p>Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的，又因为Node实现了Map.Entry接口，所以也可以叫做一对k-v就是一个Entry<br>
KeySet存放了所有的key，Entry存放了所有的key-value键值对，这样做是为了方便遍历，因为Map接口没有迭代器，要间接通过Collection实现类来遍历</p>
</li>
</ul>
</li>
<li>
<p>Map接口常用方法</p>
<ul>
<li>
<p>put</p>
<ul>
<li>添加键值对</li>
</ul>
</li>
<li>
<p>remove</p>
<ul>
<li>根据键删除相应键值对</li>
</ul>
</li>
<li>
<p>get</p>
<ul>
<li>根据索引获取value</li>
</ul>
</li>
<li>
<p>size</p>
<ul>
<li>获取元素个数</li>
</ul>
</li>
<li>
<p>isEmpty</p>
<ul>
<li>判断是否为空</li>
</ul>
</li>
<li>
<p>clear</p>
<ul>
<li>清空Map</li>
</ul>
</li>
<li>
<p>containsKey</p>
<ul>
<li>查找键是否存在</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Map接口遍历方法</p>
<ul>
<li>
<p>第一组</p>
<ul>
<li>先取出所有的Key，通过key取出所有的Value<br>
Set keyset = map.keySet();<br>
然后使用迭代器或增强for遍历keySet来遍历值</li>
</ul>
</li>
<li>
<p>第二组</p>
<ul>
<li>把所有的values取出<br>
Collection values = map.values();<br>
然后使用迭代器或增强for遍历所有值</li>
</ul>
</li>
<li>
<p>第三组</p>
<ul>
<li>使用EntrySet来获取k-v<br>
Set entrySet = map.entrySet();<br>
然后用迭代器或增强for来遍历每个entry，通过Map.Entry自带的getKey和getValue方法来获得entry中的一对k-v</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="14-13-Map-接口实现类-HashMap">14.13 Map 接口实现类-HashMap</h3>
<ul>
<li>
<p>前述HashMap小结</p>
<ul>
<li>
<p>Map接口的常用实现类：HashMap, Hashtable, Properties</p>
</li>
<li>
<p>HashMap是Map接口使用频率最高的实现类</p>
</li>
<li>
<p>HashMap是以键值对的形式来存储数据（类型为HashMap$Node)</p>
</li>
<li>
<p>key不能重复，但是值可以重复，允许使用null键和null值</p>
</li>
<li>
<p>如果添加相同的key，则会覆盖原来的k-v，等同于替换</p>
</li>
<li>
<p>与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的</p>
</li>
<li>
<p>HashMap没有实现同步，因此是线程不安全的，方法没有做同步互斥的操作，没有synchronized</p>
</li>
</ul>
</li>
<li>
<p>底层机制及源码剖析</p>
<ul>
<li>
<p>底层示意</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>扩容机制</p>
<ul>
<li>
<p>HashMap底层维护了Node类型的数组table，默认为null</p>
</li>
<li>
<p>当创建对象时，将加载因子(loadfactor)初始化为0.75</p>
</li>
<li>
<p>当添加键值对时，通过key的hash值得到在table的索引，然后判断该索引处是有元素，如果没有则直接添加，如果有且相等则直接替换，如果有且不相等则需要判断后面是树结构还是表结构，做出比较判断，看要不要添加或替换。如果添加后发现容量达到临界值，则扩容</p>
</li>
<li>
<p>第一次添加，将table扩容至16，临界值12</p>
</li>
<li>
<p>以后再次扩容，则双倍扩容，临界值也变为原来的两倍</p>
</li>
<li>
<p>在Java8后，如果链表的元素个数超过8且table大小超过64，就会树化</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="14-14-Map-接口实现类-Hashtable">14.14 Map 接口实现类-Hashtable</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>存放的元素是键值对：即K-V</p>
</li>
<li>
<p>Hashtable的键和值都不能为null，否则会抛出NullPointerException</p>
</li>
<li>
<p>Hashtable使用方法基本上和HashMap一样</p>
</li>
<li>
<p>Hashtable是线程安全的，HashMap是线程不安全的</p>
</li>
</ul>
</li>
<li>
<p>Hashtable和HashMap对比</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="14-15-Map-接口实现类-Properties">14.15 Map 接口实现类-Properties</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>Properties类继承自Hashtable类并且实现了Map接口，也是使用一种键值对的形式来保存数据</p>
</li>
<li>
<p>它的使用特点和Hashtable类似</p>
</li>
<li>
<p>Properties还可以用于从后缀为properties的文件中加载数据到Properties类对象，并进行读取和修改</p>
</li>
<li>
<p>说明：工作时，properties文件通常作为配置文件，在IO流时具体学习</p>
</li>
</ul>
</li>
</ul>
<h3 id="14-16-总结-开发中如何选择集合实现类">14.16 总结-开发中如何选择集合实现类</h3>
<ul>
<li>
<p>先判断存储的类型（一组对象【单列】或一组键值对【双列】</p>
</li>
<li>
<p>一组对象【单列】：Collection接口实现类<br>
允许重复：List<br>
增删多：LinkedList（双向列表）<br>
改查多：ArrayList（数组）<br>
不允许重复：Set<br>
无序：HashSet（HashMap）<br>
排序：TreeSet<br>
插入和取出顺序一致：LinkedHashSet（数组+双向链表）</p>
</li>
<li>
<p>一组键值对【双列】：Map接口实现类<br>
键无序：HashMap<br>
键排序：TreeSet<br>
插入和取出顺序一致：LinkedHashMap（数组+双向链表）</p>
</li>
<li>
<p>补充</p>
<ul>
<li>
<p>TreeSet和TreeMap</p>
<ul>
<li>
<p>TreeSet底层是TreeMap，在添加元素时，TreeMap会先判断添加顺序，然后再添加元素，所以可以实现键排序</p>
<ul>
<li>
<ol>
<li>构造器把传入的比较器对象，赋给了 TreeSet 的底层的 TreeMap 的属性 this.comparator<br>
public TreeMap(Comparator&lt;? super K&gt; comparator) {<br>
this.comparator = comparator;<br>
}</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>
<p>在 调用 treeSet.add(“tom”), 在底层会执行到<br>
if (cpr != null) {//cpr 就是我们的匿名内部类(对象)<br>
do {<br>
parent = t;<br>
//动态绑定到我们的匿名内部类(对象)compare<br>
cmp = cpr.compare(key, t.key);<br>
if (cmp &lt; 0)<br>
t = t.left;<br>
else if (cmp &gt; 0)<br>
t = t.right;<br>
else //如果相等，即返回 0,这个 Key 就没有加入<br>
return t.setValue(value);<br>
} while (t != null);<br>
}</p>
<pre><code> 	- 通过在创建TreeMap对象时调用有参构造器传入匿名内部类Comparator，可以自定义添加键值对时的默认顺序，可以是根据字符串长度、字符串在字母表中顺序等来自定义。同样，如果根据添加规则发现有相同元素，就替换
</code></pre>
</li>
</ol>
<h3 id="14-17-Collections-工具类">14.17 Collections 工具类</h3>
<ul>
<li>
<p>介绍</p>
<ul>
<li>
<p>Collections是一个操作Set，List和Map等集合的工具类</p>
</li>
<li>
<p>Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</p>
</li>
</ul>
</li>
<li>
<p>排序操作</p>
<ul>
<li>
<p>reverse(List)</p>
<ul>
<li>反转List中元素的顺序</li>
</ul>
</li>
<li>
<p>shuffle(List)</p>
<ul>
<li>对List中元素进行随机排序（打乱）</li>
</ul>
</li>
<li>
<p>sort(List)</p>
<ul>
<li>根据元素的自然顺序（字母表顺序）对指定List中元素按升序排序</li>
</ul>
</li>
<li>
<p>sort(List, Comparator)</p>
<ul>
<li>按照指定的Comparator中的compare方法产生的顺序来排序</li>
</ul>
</li>
<li>
<p>swap(List, int, int)</p>
<ul>
<li>将指定List中的i处元素和j处元素交换</li>
</ul>
</li>
</ul>
</li>
<li>
<p>查找、替换操作</p>
<ul>
<li>
<p>max(Collection)</p>
<ul>
<li>根据元素的自然顺序，返回给定集合中的最大元素</li>
</ul>
</li>
<li>
<p>max(Collection, Comparator)</p>
<ul>
<li>根据自定义顺序，返回给定集合中的最大元素</li>
</ul>
</li>
<li>
<p>min(Collection)</p>
<ul>
<li>同上</li>
</ul>
</li>
<li>
<p>min(Collection, Comparator)</p>
<ul>
<li>同上</li>
</ul>
</li>
<li>
<p>frequency(Collection, Object)</p>
<ul>
<li>返回Object在集合中出现的次数</li>
</ul>
</li>
<li>
<p>copy(List dest, List src)</p>
<ul>
<li>将src中的内容复制到dest中</li>
</ul>
</li>
<li>
<p>replace(List, Object oldVal, Object newVal)</p>
<ul>
<li>将List中的所有oldVal元素替换为newVal</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第十五章：泛型">第十五章：泛型</h2>
<h3 id="15-1-2-泛型的理解和好处">15.1 2 泛型的理解和好处</h3>
<ul>
<li>
<p>传统方法的问题</p>
<ul>
<li>
<p>不能对加入到集合中的数据类型进行约束</p>
</li>
<li>
<p>遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响</p>
</li>
</ul>
</li>
<li>
<p>泛型的好处</p>
<ul>
<li>
<p>编译时，检查添加元素的类型，提高了安全性</p>
</li>
<li>
<p>减少了类型转换的次数，提高效率</p>
</li>
<li>
<p>不再提示编译警告</p>
</li>
</ul>
</li>
</ul>
<h3 id="15-3-泛型介绍">15.3 泛型介绍</h3>
<ul>
<li>
<p>泛——广泛，泛型——广泛的类型，泛化的类型</p>
<ul>
<li>
<p>泛型又称为参数化类型，是JDK5.0出现的新特性，解决数据类型的安全性问题</p>
</li>
<li>
<p>在类声明或实例化时只要制定好需要的具体的类型即可</p>
</li>
<li>
<p>Java泛型可以保证如果程序在编译时没有发出警告，那么运行时就不会产生</p>
</li>
<li>
<p>泛型的作用是：可以在类声明时通过一个标识表示类中的某个属性的类型，或是某个方法的返回值的类型，或是参数类型</p>
</li>
</ul>
</li>
</ul>
<h3 id="15-4-泛型的语法">15.4 泛型的语法</h3>
<ul>
<li>
<p>泛型的声明</p>
<ul>
<li>
<p>interface name<T> {}<br>
class name &lt;K,V&gt;{}等</p>
<ul>
<li>
<p>其中，T、K、V不代表值，而是表示类型</p>
</li>
<li>
<p>任意字母都可以。常用T表示，是type的缩写</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>泛型的实例化</p>
<ul>
<li>
<p>需要在类名或接口名后指定类型参数的值</p>
<ul>
<li>List<String> strList = new ArrayList&lt;&gt;();<br>
Iterator<Customer> iterator = customers.iterator();</li>
</ul>
</li>
</ul>
</li>
<li>
<p>泛型使用的注意事项和细节</p>
<ul>
<li>
<p>T、V等字母代表的类型只能是引用类型</p>
</li>
<li>
<p>在给泛型指定具体的类型后，可以传入该类型或其子类类型</p>
</li>
<li>
<p>泛型使用形式，推荐写成如下形式：<br>
List<Integer> list = new ArrayList&lt;&gt;();<br>
如果尖括号内不写内容，默认为Object</p>
</li>
</ul>
</li>
</ul>
<h3 id="15-6-自定义泛型">15.6 自定义泛型</h3>
<ul>
<li>
<p>自定义泛型类</p>
<ul>
<li>
<p>基本语法</p>
<ul>
<li>class name &lt;T, R…&gt; {<br>
成员<br>
}</li>
</ul>
</li>
<li>
<p>注意细节</p>
<ul>
<li>
<p>普通成员可以使用泛型</p>
</li>
<li>
<p>使用泛型的数组，不能初始化（因为编译器不知道该分配多大的空间）</p>
</li>
<li>
<p>静态方法中不能使用类的泛型（因为静态方法是跟类相关的，在类加载时，对象还没创建，泛型还没指定）</p>
</li>
<li>
<p>泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型）</p>
</li>
<li>
<p>如果在创建对象时，没有指定类型，默认为Object</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>自定义泛型接口</p>
<ul>
<li>
<p>基本语法</p>
<ul>
<li>interface name &lt;T, R…&gt; {<br>
…<br>
}</li>
</ul>
</li>
<li>
<p>注意细节</p>
<ul>
<li>
<p>接口中，静态成员也不能使用泛型（与泛型类的规定一样）</p>
</li>
<li>
<p>泛型接口的类型，在继承接口或实现接口时确定</p>
</li>
<li>
<p>没有指定类型，默认为Object</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>自定义泛型方法</p>
<ul>
<li>
<p>基本语法</p>
<ul>
<li>修饰符 &lt;T, R…&gt; 返回类型 方法名(参数列表){<br>
}</li>
</ul>
</li>
<li>
<p>注意细节</p>
<ul>
<li>
<p>泛型方法，可以定义在普通类中，也可以定义在泛型类中</p>
</li>
<li>
<p>当泛型方法被调用时，类型会确定</p>
</li>
<li>
<p>注意泛型方法和使用了泛型的方法的区别<br>
（泛型方法指调用方法时需要传泛型类型的方法，而使用了泛型的方法仅指返回值或参数类型有泛型的方法，其泛型不是在调用时指定的）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="15-7-泛型的继承和通配符">15.7 泛型的继承和通配符</h3>
<ul>
<li>
<p>说明</p>
<ul>
<li>
<p>泛型不具备继承性，即<br>
List<Object> list = new ArrayList<String>();是不正确的</p>
</li>
<li>
<?>：支持任意泛型类型
</li>
<li>
<? extends A>：支持A类以及A的子类，规定了泛型的上限
</li>
<li>
<? super A>：支持A类以及A的父类，不限于直接父类，规定了泛型的下限
</li>
</ul>
</li>
</ul>
<h3 id="15-9-JUnit">15.9 JUnit</h3>
<ul>
<li>
<p>为什么需要？</p>
<ul>
<li>
<p>一个类有很多功能代码需要测试，为了测试，就需要写入到main方法中</p>
</li>
<li>
<p>如果有多个功能代码测试，就需要来回注释掉，切换很麻烦</p>
</li>
<li>
<p>如果可以直接运行一个方法，就方便很多，并且可以给出相关信息</p>
</li>
</ul>
</li>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>JUnit是一个Java语言的单元测试框架</p>
</li>
<li>
<p>多数Java的开发环境都已经继承了JUnit作为单元测试工具</p>
</li>
</ul>
</li>
</ul>
<h2 id="第十七章：多线程基础">第十七章：多线程基础</h2>
<h3 id="17-1-线程相关概念">17.1 线程相关概念</h3>
<ul>
<li>
<p>程序</p>
<ul>
<li>程序就是：为完成特定任务，用某种语言编写的一组指令的集合，简单地说就是我们写的代码</li>
</ul>
</li>
<li>
<p>进程</p>
<ul>
<li>
<p>进程是指运行中的程序，比如我们点开QQ，就启动了一个进程，操作系统就会为该进程分配内存空间。</p>
</li>
<li>
<p>进程是程序的一次执行过程，或是正在运行的一个程序。是动态过程：有它自身的产生，存在，和消亡的过程。</p>
</li>
</ul>
</li>
<li>
<p>线程</p>
<ul>
<li>
<p>线程由进程创建，是进程的一个实体（即进程通过线程来完成工作，线程是进程具体完成工作的实体，而进程是线程的抽象）</p>
</li>
<li>
<p>一个进程可以拥有多个线程（比如一个Java程序中就可以创建多个线程）</p>
</li>
</ul>
</li>
<li>
<p>单线程</p>
<ul>
<li>同一个时刻，只允许执行一个线程</li>
</ul>
</li>
<li>
<p>多线程</p>
<ul>
<li>同一个时刻，可以执行多个线程</li>
</ul>
</li>
<li>
<p>并发</p>
<ul>
<li>同一个时刻，多个任务交替执行，造成一种“貌似同时”的错觉，简单的说，单核cpu实现的多任务就是并发</li>
</ul>
</li>
<li>
<p>并行</p>
<ul>
<li>同一个时刻，多个任务同时执行，多核cpu可以实现并行</li>
</ul>
</li>
</ul>
<h3 id="17-2-线程的基本使用">17.2 线程的基本使用</h3>
<ul>
<li>
<p>创建线程的两种方式</p>
<ul>
<li>
<p>继承Thread类，重写run方法</p>
</li>
<li>
<p>实现Runnable接口，重写run方法</p>
<ul>
<li>
<p>Java是单继承的，在某些情况下一个类可能已经继承了某个父类，这时再用继承Thread类的方法来创建线程已经不可能了</p>
</li>
<li>
<p>Java设计者们提供了另外一个方式创建线程，就是通过实现Runnable接口来创建线程</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>start0，run和start</p>
<ul>
<li>
<p>start0是本地方法，是JVM调用的方法，底层是c/c++实现，是真正实现多线程效果的方法</p>
<ul>
<li>start方法调用start0方法后，该线程并不一定会立马执行，只是将线程变成了可运行状态。具体什么时候执行，取决于CPU，由CPU统一调度</li>
</ul>
</li>
<li>
<p>run，即线程运行时所执行的方法，如果单独调用而不是通过start调用，那就没有多线程效果，只是简单的方法调用</p>
</li>
<li>
<p>start，启动线程，程序不会阻塞，即实现了多线程的效果</p>
</li>
</ul>
</li>
</ul>
<h3 id="17-3-继承Thread-vs-实现Runnable">17.3 继承Thread vs 实现Runnable</h3>
<ul>
<li>
<p>从Java设计来看，通过继承Thread和实现Runnable接口来创建线程本质上没有区别，从jdk帮助文档可以看到，Thread类本身就实现了Runnable接口</p>
</li>
<li>
<p>实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制，建议使用Runnable</p>
</li>
</ul>
<h3 id="17-4-线程终止">17.4 线程终止</h3>
<ul>
<li>
<p>基本说明</p>
<ul>
<li>
<p>当线程完成任务后，会自动退出</p>
</li>
<li>
<p>还可以通过使用变量来控制run方法退出的方式来停止线程，这种终止方式叫做通知方式</p>
</li>
</ul>
</li>
<li>
<p>步骤</p>
<ul>
<li>
<p>定义标记变量，默认为true</p>
</li>
<li>
<p>将标记变量设为循环条件</p>
</li>
<li>
<p>提供公共的set方法，用于更新loop</p>
</li>
</ul>
</li>
</ul>
<h3 id="17-5-线程常用方法">17.5 线程常用方法</h3>
<ul>
<li>
<p>setName</p>
<ul>
<li>设置线程名称，与参数name相同</li>
</ul>
</li>
<li>
<p>getName</p>
<ul>
<li>返回该线程的名称</li>
</ul>
</li>
<li>
<p>start</p>
<ul>
<li>使该线程开始执行；Java虚拟机底层调用该线程的start0方法</li>
</ul>
</li>
<li>
<p>run</p>
<ul>
<li>调用线程对象的run方法</li>
</ul>
</li>
<li>
<p>setPriority</p>
<ul>
<li>更改线程的优先级</li>
</ul>
</li>
<li>
<p>getPriority</p>
<ul>
<li>获取线程的优先级</li>
</ul>
</li>
<li>
<p>sleep</p>
<ul>
<li>在指定的毫秒数内让当前正在执行的线程休眠</li>
</ul>
</li>
<li>
<p>interrupt</p>
<ul>
<li>中断线程</li>
</ul>
</li>
<li>
<p>yield</p>
<ul>
<li>线程的礼让。让出cpu，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功</li>
</ul>
</li>
<li>
<p>join</p>
<ul>
<li>线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务，才执行当前线程的任务</li>
</ul>
</li>
<li>
<p>用户线程和守护线程</p>
<ul>
<li>
<p>用户线程</p>
<ul>
<li>也叫工作线程，当线程的任务执行完或以通知方式通知则结束</li>
</ul>
</li>
<li>
<p>守护线程</p>
<ul>
<li>一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束<br>
典型例子：垃圾回收机制线程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="17-6-线程的生命周期">17.6 线程的生命周期</h3>
<ul>
<li>
<p>JDK中用Thread.State枚举表示了线程的几种状态</p>
<ul>
<li>
<p>NEW</p>
<ul>
<li>线程尚未启动</li>
</ul>
</li>
<li>
<p>RUNNABLE</p>
<ul>
<li>线程处于执行状态</li>
</ul>
</li>
<li>
<p>BLOCKED</p>
<ul>
<li>线程处于被阻塞状态</li>
</ul>
</li>
<li>
<p>WAITING</p>
<ul>
<li>线程处于等待状态</li>
</ul>
</li>
<li>
<p>TIMED_WAITING</p>
<ul>
<li>线程处于定时等待状态</li>
</ul>
</li>
<li>
<p>TERMINATED</p>
<ul>
<li>线程处于终止状态</li>
</ul>
</li>
</ul>
</li>
<li>
<p>线程状态转换图</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>查看线程状态</p>
<ul>
<li>getState()方法</li>
</ul>
</li>
</ul>
<h3 id="17-7-线程的同步">17.7 线程的同步</h3>
<ul>
<li>
<p>为什么需要？</p>
<ul>
<li>当多个线程同时操作共有资源时，会导致发生不期望的结果，于是需要某一时刻只能有一个线程进行操作，于是需要线程的同步</li>
</ul>
</li>
<li>
<p>线程的同步，使用Synchronized关键字</p>
</li>
</ul>
<h3 id="17-8-Synchronized">17.8 Synchronized</h3>
<ul>
<li>
<p>线程同步机制</p>
<ul>
<li>
<p>在多线程编程时，一些敏感数据不允许被多个线程同时访问，此时就需要同步访问技术，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性</p>
</li>
<li>
<p>也可以这样理解：线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作</p>
</li>
</ul>
</li>
<li>
<p>语法</p>
<ul>
<li>
<p>同步代码块</p>
<ul>
<li>synchronized (对象) { // 得到对象的锁，才能                                               操作同步代码<br>
}</li>
</ul>
</li>
<li>
<p>同步方法</p>
<ul>
<li>public synchronized void name(…) {<br>
}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="17-9-分析同步原理">17.9 分析同步原理</h3>
<ul>
<li></li>
<li>
<p>同一时间只能有一个线程拿到锁，并操作同步代码，此时其他线程没有拿到锁，无法操作，直到线程操作完毕把锁归还，所有线程再一起竞争这把锁，再重复</p>
</li>
</ul>
<h3 id="17-10-互斥锁">17.10 互斥锁</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性</p>
</li>
<li>
<p>每个对象都对应与一个可称为“互斥锁”的标记，这个标记用来保证在任意时刻，只能有一个线程访问该对象</p>
</li>
<li>
<p>关键字synchronized用来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任意时刻只能由一个线程访问</p>
</li>
<li>
<p>同步的局限性：导致程序的执行效率降低</p>
</li>
<li>
<p>同步方法（非静态）的锁可以是this（当前对象），也可以是其他对象（要求多个线程对应的是同一对象）</p>
</li>
<li>
<p>同步方法（静态）的锁为当前类本身</p>
</li>
<li>
<p>同步代码块的锁是this对象</p>
</li>
</ul>
</li>
<li>
<p>注意事项和细节</p>
<ul>
<li>
<p>同步方法如果没有使用static修饰，默认锁对象为this</p>
</li>
<li>
<p>如果方法使用static修饰，默认锁对象为当前类.class</p>
</li>
<li>
<p>如何实现线程同步？</p>
<ul>
<li>
<p>需要先分析上锁的代码</p>
</li>
<li>
<p>选择使用同步代码块或同步方法</p>
</li>
<li>
<p>要求多个线程的锁对象为同一个即可</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="17-11-线程的死锁">17.11 线程的死锁</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>多个线程都占用了对方的锁的资源，都需要得到对方的锁才能进行下一步操作，此时就导致了死锁。这是在编程中必须要避免的！</li>
</ul>
</li>
<li>
<p>举例</p>
<ul>
<li>a线程得到了x的锁，正在执行代码，到某个节点执行下一步代码需要得到y的锁；而同时b线程得到了y的锁，下一步执行需要得到x的锁才能继续执行。两者互不相让，导致线程死锁，程序不继续进行，也不退出。</li>
</ul>
</li>
</ul>
<h3 id="17-12-释放锁">17.12 释放锁</h3>
<ul>
<li>
<p>以下的操作会释放锁</p>
<ul>
<li>
<p>当前线程的同步方法、同步代码块执行结束</p>
</li>
<li>
<p>当前线程在同步代码块、同步方法中遇到break, return</p>
</li>
<li>
<p>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</p>
</li>
<li>
<p>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁</p>
</li>
</ul>
</li>
<li>
<p>以下操作不会释放锁</p>
<ul>
<li>
<p>线程执行同步方法、同步代码块时，程序调用Thread.sleep(), Thread.yield()方法暂停当前线程的执行时，不会释放锁</p>
</li>
<li>
<p>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，不会释放锁</p>
</li>
</ul>
</li>
</ul>
<h2 id="第十九章：IO流">第十九章：IO流</h2>
<h3 id="19-1-文件">19.1 文件</h3>
<ul>
<li>
<p>什么是文件？</p>
<ul>
<li>文件是保存数据的地方，它既可以是一张图片，也可以是一段视频，一段音频等等</li>
</ul>
</li>
<li>
<p>文件流</p>
<ul>
<li>
<p>文件在程序中是以流的形式来操作的</p>
</li>
<li>
<p>流</p>
<ul>
<li>数据在数据源和程序之间的路径</li>
</ul>
</li>
<li>
<p>输入流</p>
<ul>
<li>数据从数据源到程序的路径</li>
</ul>
</li>
<li>
<p>输出流</p>
<ul>
<li>数据从程序到数据源的路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="19-2-常用的文件操作">19.2 常用的文件操作</h3>
<ul>
<li>
<p>创建文件对象的相关构造器的方法</p>
<ul>
<li>
<p>构造器</p>
<ul>
<li>new File(String pathname)//根据绝对路径构建一个File对象<br>
new File(File parent, String child)//根据父目录文件对象+子路径构建<br>
new File(String parent, String child)//根据父目录+子目录贵贱</li>
</ul>
</li>
<li>
<p>方法</p>
<ul>
<li>
<p>createNewFile</p>
<ul>
<li>创建新文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>获取文件的相关信息</p>
<ul>
<li>
<p>getName</p>
<ul>
<li>获取文件名</li>
</ul>
</li>
<li>
<p>getAbsolutePath</p>
<ul>
<li>获取文件绝对路径</li>
</ul>
</li>
<li>
<p>getParent</p>
<ul>
<li>获取文件父级目录</li>
</ul>
</li>
<li>
<p>length</p>
<ul>
<li>获取文件大小（字节）</li>
</ul>
</li>
<li>
<p>exists</p>
<ul>
<li>判断文件是否存在</li>
</ul>
</li>
<li>
<p>isFile</p>
<ul>
<li>判断是不是一个文件</li>
</ul>
</li>
<li>
<p>isDirectory</p>
<ul>
<li>判断是不是一个目录</li>
</ul>
</li>
</ul>
</li>
<li>
<p>文件的操作和文件删除</p>
<ul>
<li>
<p>mkdir</p>
<ul>
<li>创建一级目录</li>
</ul>
</li>
<li>
<p>mkdirs</p>
<ul>
<li>创建多级目录，指如果文件当前所指位置之前有多个目录需要创建，则用此方法可以一次性创建多个目录，直到文件所指位置</li>
</ul>
</li>
<li>
<p>delete</p>
<ul>
<li>删除空目录或文件，不可删除非空的目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="19-3-IO流原理及流的分类">19.3 IO流原理及流的分类</h3>
<ul>
<li>
<p>Java IO流的原理</p>
<ul>
<li>
<p>I/O是Input/Output的缩写，I/O技术是非常实用的技术，用于处理数据传输。如读写文件，网络通讯等</p>
</li>
<li>
<p>Java程序中，对于数据的输入和输出是以“流”的方式进行</p>
</li>
<li>
<p>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过方法输入或输出数据</p>
</li>
<li>
<p>输入：读取外部数据（磁盘、光盘、网络等）到程序（内存）中</p>
</li>
<li>
<p>输出：将程序（内存）中的数据输出到外部源（磁盘，光盘，网络等）中</p>
</li>
</ul>
</li>
<li>
<p>流的分类</p>
<ul>
<li>
<p>按操作数据的单位分为</p>
<ul>
<li>
<p>字节流</p>
<ul>
<li>适合读写二进制文件</li>
</ul>
</li>
<li>
<p>字符流</p>
<ul>
<li>适合读写文本文件</li>
</ul>
</li>
</ul>
</li>
<li>
<p>按数据流的流向不同分为</p>
<ul>
<li>
<p>输入流</p>
</li>
<li>
<p>输出流</p>
</li>
</ul>
</li>
<li>
<p>按流的角色的不同分为</p>
<ul>
<li>
<p>节点流</p>
</li>
<li>
<p>处理流/包装流</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="19-4-IO流体系图和常用的类">19.4 IO流体系图和常用的类</h3>
<ul>
<li>
<p>IO流体系图</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>文件和流的关系</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>FileInputStream</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>FileOutputStream</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>FileReader</p>
<ul>
<li></li>
<li>
<p>相关方法</p>
<ul>
<li>
<p>new FileReader(File/String)</p>
<ul>
<li>构造器，可以用File对象或路径字符串</li>
</ul>
</li>
<li>
<p>read()</p>
<ul>
<li>每次读取单个字符，返回该字符，如果到文件末尾返回-1</li>
</ul>
</li>
<li>
<p>read(char[])</p>
<ul>
<li>批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1</li>
</ul>
</li>
<li>
<p>new String(char[])</p>
<ul>
<li>将char[]转换为String</li>
</ul>
</li>
<li>
<p>new String(char[], off, len)</p>
<ul>
<li>将char[]指定部分转换成String</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>FileWriter</p>
<ul>
<li></li>
<li>
<p>相关方法</p>
<ul>
<li>
<p>new FileWriter(File/String)</p>
<ul>
<li>构造器，可以用File对象或路径字符串，覆盖模式</li>
</ul>
</li>
<li>
<p>new FileWriter(File/String, true)</p>
<ul>
<li>构造器，可以用File对象或路径字符串，追加模式</li>
</ul>
</li>
<li>
<p>write(int)</p>
<ul>
<li>写入单个字符</li>
</ul>
</li>
<li>
<p>write(char[])</p>
<ul>
<li>写入整个数组</li>
</ul>
</li>
<li>
<p>write(char[], off, len)</p>
<ul>
<li>写入数组的指定部分</li>
</ul>
</li>
<li>
<p>write(String)</p>
<ul>
<li>写入整个字符串</li>
</ul>
</li>
<li>
<p>write(String, off, len)</p>
<ul>
<li>写入字符串的指定部分</li>
</ul>
</li>
<li>
<p>toCharArray()</p>
<ul>
<li>将String转换为char[]</li>
</ul>
</li>
<li>
<p>注意</p>
<ul>
<li>FileWriter使用后，必须要关闭(close)或者刷新(flush)，否则数据还在内存中，没有写入到文件中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="19-5-节点流和处理流">19.5 节点流和处理流</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>节点流可以从一个特定的数据源读写数据，如FileWriter, FileWriter</p>
</li>
<li>
<p>处理流（包装流）是“连接”在已存在的流之上，为程序提供更为强大的读写功能，也更加灵活。如BufferedReader, BufferedWriter</p>
</li>
</ul>
</li>
<li>
<p>节点流和处理流的区别和联系</p>
<ul>
<li>
<p>节点流是底层流/低级流，直接跟数据源相接</p>
</li>
<li>
<p>处理流（包装流）包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出</p>
</li>
<li>
<p>处理流（包装流）对节点流进行包装，使用了修饰器模式，不会直接与数据源相连</p>
</li>
</ul>
</li>
<li>
<p>处理流的功能主要体现在以下两个方面</p>
<ul>
<li>
<p>性能的提高：主要以增加缓冲的方式来提高输入输出的效率</p>
</li>
<li>
<p>操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便</p>
</li>
</ul>
</li>
<li>
<p>BufferedReader</p>
</li>
<li>
<p>BufferedWriter</p>
</li>
<li>
<p>BufferedInputStream</p>
</li>
<li>
<p>BufferedOutputStream</p>
</li>
<li>
<p>对象流</p>
<ul>
<li>
<p>为何需要？</p>
<ul>
<li>
<p>有时我们希望保存到文件的数据既有值又有数据类型，这样我们在读取文件时可以直接把读取到的值赋值给对应数据类型的对象，免去了类型转换的步骤</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<p>序列化和反序列化</p>
<ul>
<li>
<p>序列化就是在保存数据时，保存数据的值和数据类型</p>
</li>
<li>
<p>反序列化就是在恢复数据时，恢复数据的值和数据类型</p>
</li>
<li>
<p>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：</p>
<ul>
<li>Serializable // 这是一个标记接口，没有方法</li>
<li>Externalizable // 该接口有方法需要实现，所以一般实现上面的Serializable接口</li>
</ul>
</li>
</ul>
</li>
<li>
<p>介绍</p>
<ul>
<li>
<p>功能</p>
<ul>
<li>提供了对基本类型或对象类型的序列化和反序列化的方法</li>
</ul>
</li>
<li>
<p>ObjectInputStream</p>
<ul>
<li>
<h2 id="提供反序列化功能">提供反序列化功能</h2>
</li>
</ul>
</li>
<li>
<p>ObjectOutputStream</p>
<ul>
<li>
<h2 id="提供序列化功能">提供序列化功能</h2>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>注意事项和细节说明</p>
<ul>
<li>
<p>读写顺序要一致</p>
</li>
<li>
<p>要求序列化或反序列化的对象，要实现序列化接口</p>
</li>
<li>
<p>序列化的类中建议添加SerialVersionUID，以提高版本的兼容性</p>
</li>
<li>
<p>序列化对象时，默认将里面所有属性都进行序列化，除了static或transient修饰的成员</p>
</li>
<li>
<p>序列化对象时，要求里面属性的类型也实现了序列化接口</p>
</li>
<li>
<p>序列化具备可继承性，也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>标准输入输出流</p>
<ul>
<li>
<p>介绍</p>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="http://System.in">System.in</a></p>
<ul>
<li>
<p>标准输入，类型为InputStream，默认输入设备为键盘</p>
</li>
<li>
<p>new Scanner(<a target="_blank" rel="noopener" href="http://System.in">System.in</a>)</p>
</li>
</ul>
</li>
<li>
<p>System.out</p>
<ul>
<li>
<p>标准输出，类型为PrintStream，默认输出设备为显示器</p>
</li>
<li>
<p>System.out.println()</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>转换流</p>
<ul>
<li>
<p>介绍</p>
<ul>
<li>
<p>InputStreamReader</p>
<ul>
<li>Reader的子类，可以将InputStream（字节流）包装（转换）成Reader（字符流）</li>
</ul>
</li>
<li>
<p>OutputStreamWriter</p>
<ul>
<li>Writer的子类，可以将OutputStream（字节流）转换成Writer（字符流）</li>
</ul>
</li>
<li>
<p>当处理纯文本数据时，使用字符流效率更高，并且可以有效解决中文乱码问题，所以建议此时将字节流转换成字符流</p>
</li>
<li>
<p>可以在使用时指定编码格式（utf-8, gbk, gb2312, ISO8859-1）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="19-6-打印流">19.6 打印流</h3>
<ul>
<li>
<p>打印流</p>
<ul>
<li>
<p>PrintStream</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>PrintWriter</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="19-7-Properties类">19.7 Properties类</h3>
<ul>
<li>
<p>使用场景</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>是专门用于读写后缀为properties的配置文件的集合类，配置文件的格式：<br>
键=值<br>
键=值<br>
…</p>
</li>
<li>
<p>注意，键值对中间没有空格，值不需要用引号括起来，默认值都为Sting类型</p>
</li>
<li>
<p>常用方法</p>
<ul>
<li>
<p>load</p>
<ul>
<li>加载配置文件的键值对到Properties对象</li>
</ul>
</li>
<li>
<p>list</p>
<ul>
<li>将数据显示到指定设备</li>
</ul>
</li>
<li>
<p>getProperty(key)</p>
<ul>
<li>根据键获取值</li>
</ul>
</li>
<li>
<p>setProperty(key, value)</p>
<ul>
<li>设置（更新）键值对到Properties对象</li>
</ul>
</li>
<li>
<p>store</p>
<ul>
<li>将Properties中的键值对存储到配置文件中，在idea中，保存信息到配置文件时，如果有中文，会存储为Unicode码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第二十一章：网络编程">第二十一章：网络编程</h2>
<h3 id="21-1-网络的相关概念">21.1 网络的相关概念</h3>
<ul>
<li>
<p>网络通信</p>
<ul>
<li>
<p>两台设备之间通过网络实现数据传输的过程</p>
</li>
<li>
<p>java.net包下提供了一系列的类或接口供程序员使用，来完成网络通信</p>
</li>
</ul>
</li>
<li>
<p>网络</p>
<ul>
<li>
<p>概念</p>
<ul>
<li>两台或多台设备通过一定物理设备连接起来构成了网络</li>
</ul>
</li>
<li>
<p>分类：根据网络的覆盖范围不同，对网络进行分类</p>
<ul>
<li>
<p>局域网</p>
</li>
<li>
<p>城域网</p>
</li>
<li>
<p>广域网</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ip地址</p>
<ul>
<li>
<p>概念</p>
<ul>
<li>用于唯一表示网络中的每台计算机/主机的标识</li>
</ul>
</li>
<li>
<p>查看ip地址</p>
<ul>
<li>控制台输入ipconfig</li>
</ul>
</li>
<li>
<p>ip地址的表示形式</p>
<ul>
<li>
<p>点分十进制<br>
<a target="_blank" rel="noopener" href="http://xxx.xxx.xxx.xxx">xxx.xxx.xxx.xxx</a></p>
</li>
<li>
<p>每个十进制数的范围：0~255</p>
</li>
</ul>
</li>
<li>
<p>ip地址的组成</p>
<ul>
<li>网络地址+主机地址</li>
</ul>
</li>
<li>
<p>IPv6</p>
<ul>
<li>
<p>IPv6是互联网工程任务组设计的用于替代IPv4的下一代IP协议，其地址数量号称可以为全世界的每一粒沙子编上一个地址</p>
</li>
<li>
<p>由于IPv4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IPv4地址分类</p>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<p>域名</p>
<ul>
<li>
<p>实例：<a target="_blank" rel="noopener" href="http://www.baidu.com">www.baidu.com</a></p>
</li>
<li>
<p>好处：可以方便记忆，省去了记IP的麻烦</p>
</li>
<li>
<p>概念：通过HTTP协议，可以将IP地址映射成域名，方便记忆</p>
</li>
<li>
<p>端口号</p>
<ul>
<li>
<p>概念：用于标识计算机上某个特定的网络程序</p>
</li>
<li>
<p>表示形式：以整数形式表示，端口范围0~65535（两个字节表示）</p>
</li>
<li>
<p>0~1024已经被占用，比如ssh22, ftp21, smtp25, http80</p>
</li>
<li>
<p>常见的网络程序端口号</p>
<ul>
<li>
<p>tomcat:8080</p>
</li>
<li>
<p>mysql:3306</p>
</li>
<li>
<p>oracle:1521</p>
</li>
<li>
<p>sqlserver:1433</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>协议(TCP/IP)</p>
<ul>
<li>
<p>TCP/IP是Transmission Control Protocol/Internet Protocol的简写，中文译名为传输控制协议/因特网互联协议，又叫网络通讯协议，是互联网最基本的血祭，是国际互联网的基础。由网络层的IP协议和传输层的TCP协议组成</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<p>网络通信协议</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>TCP和UDP</p>
<ul>
<li>
<p>TCP</p>
<ul>
<li>
<p>传输控制协议</p>
<ul>
<li>
<p>使用TCP协议前，需要先建立TCP连接，形成传输数据通道</p>
</li>
<li>
<p>传输前，采用“三次握手”方式，是可靠的</p>
</li>
<li>
<p>TCP协议进行通信的两个应用进程：服务端和客户端</p>
</li>
<li>
<p>在连接中可进行大数据量的传输</p>
</li>
<li>
<p>传输完毕，需要释放已经建立的连接，效率低</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>UDP</p>
<ul>
<li>
<p>用户数据协议</p>
<ul>
<li>
<p>将数据、源、目的封装成数据包，不需要建立连接</p>
</li>
<li>
<p>每个数据包的大小限制在64KB内，不适合传输大量数据</p>
</li>
<li>
<p>因无需连接，故是不可靠的</p>
</li>
<li>
<p>发送数据结束时无需释放资源（因为不是面向连接的），速度快</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="21-2-InetAddress类">21.2 InetAddress类</h3>
<ul>
<li>
<p>相关方法</p>
<ul>
<li>
<p>getLocalHost</p>
<ul>
<li>获取本机的InetAddress对象</li>
</ul>
</li>
<li>
<p>getByName</p>
<ul>
<li>根据指定主机名/域名获取InetAddress对象</li>
</ul>
</li>
<li>
<p>getHostName</p>
<ul>
<li>获取InetAddress对象的主机名</li>
</ul>
</li>
<li>
<p>getHostAddress</p>
<ul>
<li>获取InetAddress对象的ip地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="21-3-Socket">21.3 Socket</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>使用套接字（Socket）开发网络应用程序被广泛采用，以至于称为事实上的标准</p>
</li>
<li>
<p>通信的两端都要有Socket，是两台机器间通信的端点</p>
</li>
<li>
<p>网络通信其实就是Socket之间的通信</p>
</li>
<li>
<p>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输</p>
</li>
<li>
<p>一般主动发起通信的应用程序属于客户端，等待通信请求的为服务端</p>
</li>
</ul>
</li>
<li></li>
</ul>
<h3 id="21-4-TCP网络通信编程">21.4 TCP网络通信编程</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>基于客服端-服务端的网络通信</p>
</li>
<li>
<p>底层使用的是TCP/IP协议</p>
</li>
<li>
<p>基于Socket的TCP编程</p>
</li>
<li>
<p>应用场景举例：客户端发送数据。服务端接收并显示在控制台上</p>
</li>
</ul>
</li>
<li>
<p>举例</p>
<ul>
<li>
<p>案例1</p>
<ul>
<li>
<p>TCPSocket01Client.java</p>
</li>
<li>
<p>TCPSocket01Server.java</p>
</li>
</ul>
</li>
<li>
<p>案例2</p>
<ul>
<li>
<p>TCPSocket02Client.java</p>
</li>
<li>
<p>TCPSocket02Server.java</p>
</li>
</ul>
</li>
<li>
<p>案例3</p>
<ul>
<li>
<p>TCPSocket03Client.java</p>
</li>
<li>
<p>TCPSocket03Server.java</p>
</li>
</ul>
</li>
<li>
<p>案例4</p>
<ul>
<li>
<p>uploadFileClient.java</p>
</li>
<li>
<p>uploadFileServer.java</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>netstat指令</p>
<ul>
<li>
<p>netstat -an 可以查看当前主机网络情况，包括端口监听情况和网络连接情况</p>
</li>
<li>
<p>netstat -an|more 可以分页显示</p>
</li>
<li>
<p>listening表示某个端口正在监听<br>
如果有一个外部程序连接到该端口，就会显示一条连接信息</p>
</li>
</ul>
</li>
<li>
<p>TCP网络通讯细节</p>
<ul>
<li>当客户端连接到服务端后，实际上客户端也是通过一个端口和服务端进行通讯的，这个端口是TCP/IP来分配的，是不确定的，是随机的。</li>
</ul>
</li>
</ul>
<h3 id="21-5-UDP网络编程">21.5 UDP网络编程</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>类DatagramSocket和DatagramPacket实现了基于UDP协议网络程序</p>
</li>
<li>
<p>UDP数据包DatagramPacket通过数据包套接字DatagramSocket发送和接收，系统不保证UDP数据包一定能够安全送到目的地，也不确定什么时候可以送达</p>
</li>
<li>
<p>DatagramPacket对象封装了UDP数据包，在数据包中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号</p>
</li>
<li>
<p>UDP协议中每个数据包都给出了完整的地址信息，因此无需建立发送方和接收方的连接</p>
</li>
</ul>
</li>
<li>
<p>基本流程</p>
<ul>
<li>
<p>核心的两个类/对象：DatagramSocket和DatagramPacket</p>
</li>
<li>
<p>建立发送端，接收端（没有服务端和客户端的概念）</p>
</li>
<li>
<p>发送数据前，建立数据包对象DatagramPacket</p>
</li>
<li>
<p>调用数据包套接字DatagramSocket的发送和接收方法</p>
</li>
<li>
<p>关闭DatagramSocket</p>
</li>
</ul>
</li>
<li>
<p>案例</p>
<ul>
<li>
<p>UDPReceiver.java</p>
</li>
<li>
<p>UDPSender.java</p>
</li>
</ul>
</li>
</ul>
<h2 id="第二十三章：反射">第二十三章：反射</h2>
<h3 id="23-1-引出背景">23.1 引出背景</h3>
<ul>
<li>
<p>根据如下配置文件，创建Cat对象并调用方法hi<br>
classfullpath=com.hspedu.Cat<br>
method=hi</p>
</li>
<li>
<p>利用现有技术，几乎不能完成，于是引入反射机制</p>
</li>
<li>
<p>这样的根据外部文件的配置，在不修改源码的情况下来控制程序用的非常多，也符合设计模式中的开闭原则（不修改源码，可扩展功能）</p>
</li>
</ul>
<h3 id="23-2-反射机制">23.2 反射机制</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>反射机制允许程序在执行期间借助于反射相关API取得任何类的内部信息（比如成员变量，构造器，成员方法等等），并能创建对象并操作对象的属性及方法。反射在设计模式和框架底层都会用到</p>
</li>
<li>
<p>加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个Class对象就像一面镜子，透过这个镜子看到类的结构，所以形象地称之为反射</p>
</li>
</ul>
</li>
<li>
<p>反射机制原理示意图</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>通过反射可以做到</p>
<ul>
<li>
<p>在运行时判断任意一个对象所属的类</p>
</li>
<li>
<p>在运行时构造任意一个类的对象</p>
</li>
<li>
<p>在运行时得到任意一个类所具有的成员变量和方法</p>
</li>
<li>
<p>在运行时调用任意一个对象的成员变量和方法</p>
</li>
<li>
<p>生产动态代理</p>
</li>
</ul>
</li>
<li>
<p>反射相关主要类</p>
<ul>
<li>
<p>java.lang.Class</p>
<ul>
<li>代表一个类，Class对象表示某个类加载后在堆中的对象</li>
</ul>
</li>
<li>
<p>java.lang.reflect.Method</p>
<ul>
<li>代表类的方法，Method对象本身某个类的方法</li>
</ul>
</li>
<li>
<p>java.lang.reflect.Field</p>
<ul>
<li>代表类的成员变量，Field对象表示某个类的成员变量</li>
</ul>
</li>
<li>
<p>java.lang.reflect.Constructor</p>
<ul>
<li>代表类的构造器，Constructor对象本身某个类的构造器</li>
</ul>
</li>
</ul>
</li>
<li>
<p>反射的优点和缺点</p>
<ul>
<li>
<p>优点</p>
<ul>
<li>可以动态地创建和使用对象（也是框架底层核心），使用灵活，没有反射机制，框架技术就失去底层支撑</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>使用反射基本是解释执行，对执行速度有影响</li>
</ul>
</li>
</ul>
</li>
<li>
<p>反射调用优化——关闭访问检查</p>
<ul>
<li>
<p>Method和Field、Constructor对象都有setAccessible()方法</p>
</li>
<li>
<p>setAccessible作用是启动和禁用访问安全检查的开关</p>
</li>
<li>
<p>参数值为true表示反射的对象在使用时取消访问检查，提高反射的效率。参数值为false则表示反射的对象执行访问检查</p>
</li>
</ul>
</li>
</ul>
<h3 id="23-3-Class类">23.3 Class类</h3>
<ul>
<li>
<p>基本介绍</p>
<ul>
<li>
<p>Class类也是类，因此也继承Object类</p>
</li>
<li>
<p>Class类对象不是new出来的，而是系统创建的</p>
</li>
<li>
<p>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</p>
</li>
<li>
<p>每个类的实例都会记得自己是由哪个Class对象所生成的</p>
</li>
<li>
<p>通过Class对象可以通过API完整地得到一个类的完整结构</p>
</li>
<li>
<p>Class对象是存放在堆里的</p>
</li>
<li>
<p>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码，变量名，方法名，访问权限等）</p>
</li>
<li></li>
</ul>
</li>
<li>
<p>常用方法</p>
<ul>
<li>
<p>forName(String name)</p>
<ul>
<li>返回指定类名name的Class对象</li>
</ul>
</li>
<li>
<p>newInstance</p>
<ul>
<li>调用无参构造器，返回该Class对象的一个实例</li>
</ul>
</li>
<li>
<p>getName</p>
<ul>
<li>返回此Class对象所表示的实体（类、接口、数组、基本类型等）的全类名</li>
</ul>
</li>
<li>
<p>getInterfaces</p>
<ul>
<li>获取当前Class对象的所有实现接口的Class对象，返回Class数组</li>
</ul>
</li>
<li>
<p>getClassLoader</p>
<ul>
<li>返回该类的类加载器</li>
</ul>
</li>
<li>
<p>getSuperclass</p>
<ul>
<li>返回表示此Class所表示的实体的父类的Class</li>
</ul>
</li>
<li>
<p>getConstructors</p>
<ul>
<li>返回该Class对象的实例的所有公开的构造器</li>
</ul>
</li>
<li>
<p>getDeclaredFields</p>
<ul>
<li>返回该Class对象的实例的所有属性</li>
</ul>
</li>
<li>
<p>getMethod(String name, paramTypes…)</p>
<ul>
<li>根据name和形参类型返回该类的某个方法</li>
</ul>
</li>
<li>
<p>getPackage</p>
<ul>
<li>获得该Class对象的包名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="23-4-获取Class类对象">23.4 获取Class类对象</h3>
<ul>
<li>
<p>情况1：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName(String fullName)获取，注意，可能抛出ClassNotFoundException</p>
<ul>
<li>应用场景：多用于配置文件，读取类的全路径，加载Class对象</li>
</ul>
</li>
<li>
<p>情况2：已知具体的类，可通过类的class获取，该方式最为安全可靠，程序性能最高。实例：Class cls = Cat.class;</p>
<ul>
<li>应用场景：多用于参数传递，比如通过反射得到对应的构造器对象</li>
</ul>
</li>
<li>
<p>情况3：已知某个类的实例，可调用该实例的getClass()方法获取Class对象</p>
<ul>
<li>应用场景：有现成的创建好的对象实例</li>
</ul>
</li>
<li>
<p>其他方式：<br>
ClassLoader cl = 对象.getClass().getClassLoader();<br>
class cls = cl.loadClass(String fullName);</p>
</li>
<li>
<p>基本数据类型通过如下方法获取Class对象<br>
Class cls = 基本数据类型.class;</p>
</li>
<li>
<p>基本数据类型对应的包装类，可以通过.TYPE得到Class类对象<br>
Class cls = 包装类.TYPE;</p>
</li>
</ul>
<h3 id="23-5-哪些类型有Class对象？">23.5 哪些类型有Class对象？</h3>
<ul>
<li>
<p>外部类、成员内部类、静态内部类、局部内部类、匿名内部类</p>
</li>
<li>
<p>接口</p>
</li>
<li>
<p>数组</p>
</li>
<li>
<p>枚举类</p>
</li>
<li>
<p>注解</p>
</li>
<li>
<p>基本数据类型</p>
</li>
<li>
<p>void</p>
</li>
</ul>
<h3 id="23-6-类加载">23.6 类加载</h3>
<ul>
<li>
<p>基本说明</p>
<ul>
<li>
<p>反射机制是Java实现动态语言的关键，也就是通过反射实现类动态加载</p>
<ul>
<li>
<p>静态加载</p>
<ul>
<li>编译时加载相关的类，如果没有相关类则会报错，依赖性很强</li>
</ul>
</li>
<li>
<p>动态加载</p>
<ul>
<li>运行时加载需要的类，如果运行时不用该类，即使该类不存在，也不会报错，降低了依赖性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>类加载时机</p>
<ul>
<li>
<p>创建对象时（静态加载）</p>
</li>
<li>
<p>当子类被加载时，父类也会加载（静态加载）</p>
</li>
<li>
<p>调用类中的静态成员时（静态加载）</p>
</li>
<li>
<p>通过反射得到类的Class对象时（动态加载）</p>
</li>
</ul>
</li>
<li>
<p>类加载过程图</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>类加载各阶段完成的任务</p>
<ul>
<li>
<p>加载</p>
<ul>
<li>
<p>将类的class文件读入内存，并位置创建一个java.lang.Class对象。此过程由类加载器完成</p>
<ul>
<li>主要目的是将字节码从不同的数据源（可能是class文件、也可能是jar包，甚至是网络）转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</li>
</ul>
</li>
</ul>
</li>
<li>
<p>连接</p>
<ul>
<li>
<p>将类的二进制数据合并到JRE中</p>
<ul>
<li>
<p>三个阶段</p>
<ul>
<li>
<p>验证</p>
<ul>
<li>
<p>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p>
</li>
<li>
<p>验证包括：文件格式验证（是否以魔数oxcafebabe开头）、元数据验证、字节码验证和符号引用验证</p>
</li>
<li>
<p>可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，缩短虚拟机加载类的时间</p>
</li>
</ul>
</li>
<li>
<p>准备</p>
<ul>
<li>JVM会在该阶段对静态变量分配内存并默认初始化（对应数据类型的默认初始值）。这些变量所使用的内存都将在方法区中进行分配</li>
</ul>
</li>
<li>
<p>解析</p>
<ul>
<li>虚拟机将常量池内的符号引用替换为直接引用的过程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>初始化</p>
<ul>
<li>
<p>JVM负责对类进行初始化，主要是静态成员的初始化</p>
<ul>
<li>
<p>一直到初始化阶段，才真正开始执行类中的Java程序代码，初始化阶段是执行clinit()方法的过程</p>
</li>
<li>
<p>clinit()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并（即最终每个静态变量只会保留最后的赋值语句）</p>
</li>
<li>
<p>虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁同步，不会出现多个线程同时去执行类的clinit()方法，导致初始化错误的情况。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="23-7-通过反射获取类的结构信息">23.7 通过反射获取类的结构信息</h3>
<ul>
<li>
<p>通过Class类获取</p>
<ul>
<li>
<p>getName</p>
<ul>
<li>获取全类名</li>
</ul>
</li>
<li>
<p>getSimpleName</p>
<ul>
<li>获取简单类名</li>
</ul>
</li>
<li>
<p>getFields</p>
<ul>
<li>获取本类以及父类所有public修饰的属性</li>
</ul>
</li>
<li>
<p>getDeclaredFields</p>
<ul>
<li>获取本类中的所有属性（不限修饰符）</li>
</ul>
</li>
<li>
<p>getMethods</p>
<ul>
<li>获取本类和父类的所有public修饰的方法</li>
</ul>
</li>
<li>
<p>getDeclaredMethods</p>
<ul>
<li>获取本类中的所有方法（不限修饰符）</li>
</ul>
</li>
<li>
<p>getConstructors</p>
<ul>
<li>获取本类所有的public修饰的构造器</li>
</ul>
</li>
<li>
<p>getDeclaredConstructors</p>
<ul>
<li>获取本类中所有构造器（不限修饰符）</li>
</ul>
</li>
<li>
<p>getPackage</p>
<ul>
<li>以Package形式返回包信息</li>
</ul>
</li>
<li>
<p>getSuperClass</p>
<ul>
<li>以Class形式返回父类Class对象</li>
</ul>
</li>
<li>
<p>getInterfaces</p>
<ul>
<li>以Class[]形式返回所有实现接口</li>
</ul>
</li>
<li>
<p>getAnnotations</p>
<ul>
<li>以Annotation[]形式返回注解信息</li>
</ul>
</li>
</ul>
</li>
<li>
<p>通过Feild类获取</p>
<ul>
<li>
<p>getModifiers</p>
<ul>
<li>
<p>以int的形式返回修饰符</p>
<ul>
<li>0=默认，1=public，2=private，4=protected，8=static，16=final<br>
有多个则相加</li>
</ul>
</li>
</ul>
</li>
<li>
<p>getType</p>
<ul>
<li>以Class形式返回类型</li>
</ul>
</li>
<li>
<p>getName</p>
<ul>
<li>返回属性名</li>
</ul>
</li>
</ul>
</li>
<li>
<p>通过Method类获取</p>
<ul>
<li>
<p>getModifiers同上</p>
</li>
<li>
<p>getReturnType</p>
<ul>
<li>以Class形式返回 返回类型</li>
</ul>
</li>
<li>
<p>getName</p>
</li>
<li>
<p>返回方法名</p>
</li>
<li>
<p>getParameterTypes</p>
<ul>
<li>以Class[]形式返回参数类型数组</li>
</ul>
</li>
</ul>
</li>
<li>
<p>通过Constructor类获取</p>
<ul>
<li>
<p>getModifiers同上</p>
</li>
<li>
<p>getName</p>
<ul>
<li>返回构造器全名</li>
</ul>
</li>
<li>
<p>getParameterTypes同上</p>
</li>
</ul>
</li>
</ul>
<h3 id="23-8-通过反射创建对象">23.8 通过反射创建对象</h3>
<ul>
<li>
<p>方式一</p>
<ul>
<li>调用类中的public修饰的无参构造器</li>
</ul>
</li>
<li>
<p>方式二</p>
<ul>
<li>调用类中的指定构造器</li>
</ul>
</li>
<li>
<p>相关的Class类方法</p>
<ul>
<li>
<p>newInstance</p>
<ul>
<li>调用类中的无参构造器，获取对应类的对象</li>
</ul>
</li>
<li>
<p>getConstructor(class …clazz)</p>
<ul>
<li>根据参数列表，获取对应的public构造器对象</li>
</ul>
</li>
<li>
<p>getDeclaredConstructor(Class …clazz)</p>
<ul>
<li>根据参数列表，获取对应的构造器对象（不限修饰符）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>相关的Constructor类方法</p>
<ul>
<li>
<p>setAccessible(true)</p>
<ul>
<li>爆破</li>
</ul>
</li>
<li>
<p>newInstance(Object …obj)</p>
<ul>
<li>调用构造器，传入对应实参来初始化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="23-9-通过反射访问类中的成员">23.9 通过反射访问类中的成员</h3>
<ul>
<li>
<p>访问属性</p>
<ul>
<li>
<p>步骤</p>
<ul>
<li>
<p>根据属性名获取Field对象<br>
Field f = clazz.getDeclaredField(属性名)</p>
</li>
<li>
<p>（可选）爆破<br>
f.setAccessible(true)</p>
</li>
<li>
<p>访问<br>
f.set(对象实例，值)<br>
f.get(对象实例)</p>
</li>
<li>
<p>注意</p>
<ul>
<li>如果访问的是静态属性，则set和get方法中的对象实例可以写成null</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>访问方法</p>
<ul>
<li>
<p>步骤</p>
<ul>
<li>
<p>根据方法名和参数列表获取Method对象<br>
Method m = clazz.getDeclaredMethod(name, XX.class…)</p>
</li>
<li>
<p>获取对象<br>
Object o = clazz.newInstance();</p>
</li>
<li>
<p>爆破（可选）m.setAccessible(true)</p>
</li>
<li>
<p>访问<br>
Object returnVal = m.invoke(对象实例，实参)</p>
</li>
<li>
<p>注意</p>
<ul>
<li>如果是静态方法，则invoke方法的对象实例可以写成null</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="补充：Java8新特性">补充：Java8新特性</h2>
<h3 id="lambda表达式">lambda表达式</h3>
<h3 id="函数式接口">函数式接口</h3>
<h3 id="方法引用">方法引用</h3>
<h3 id="构造器引用和数组引用">构造器引用和数组引用</h3>
<h3 id="StreamAPI">StreamAPI</h3>
<h3 id="Optional类">Optional类</h3>
<h3 id="新日期API">新日期API</h3>
<h3 id="JDK底层代码优化">JDK底层代码优化</h3>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://FutureYL3.github.io">yl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://futureyl3.github.io/2025/03/02/Java-Programming-Language/">https://futureyl3.github.io/2025/03/02/Java-Programming-Language/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/02/Dart-Programming-Language-Basic-Syntax/" title="Dart Programming Language Basic Syntax"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Dart Programming Language Basic Syntax</div></div><div class="info-2"><div class="info-item-1">Introduction to Dart Programming Language including basic syntax, data types, functions, OOP and asynchronous programming.</div></div></div></a><a class="pagination-related" href="/2025/03/02/Java-Learning-Road-Map/" title="Java Learning Road Map"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Java Learning Road Map</div></div><div class="info-2"><div class="info-item-1">Road Map for Java Learner aimed to succeed in web backend development.</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/02/Java-Learning-Road-Map/" title="Java Learning Road Map"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-03-02</div><div class="info-item-2">Java Learning Road Map</div></div><div class="info-2"><div class="info-item-1">Road Map for Java Learner aimed to succeed in web backend development.</div></div></div></a><a class="pagination-related" href="/2025/03/02/JSR-380-Java-Bean-Validation/" title="JSR 380 Java Bean Validation"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-03-02</div><div class="info-item-2">JSR 380 Java Bean Validation</div></div><div class="info-2"><div class="info-item-1">Introduce how to add and use "Hibernate-Validator" Bean Validation Framework in Java Spring Boot Web Project.</div></div></div></a><a class="pagination-related" href="/2025/03/02/Web-Development-Sky-Takeout/" title="Web Development -- Sky Takeout"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-03-02</div><div class="info-item-2">Web Development -- Sky Takeout</div></div><div class="info-2"><div class="info-item-1">Project oriendted way to learn advanced web development.</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/kano.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">yl</div><div class="author-info-description">Student at Harbin Institute of Technology (HIT) / Major in Software Engineering</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/FutureYL3" target="_blank" title="My GitHub Profile"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/310715755" target="_blank" title="My Bilibili Space"><i class="fa-brands fa-bilibili" style="color: #00a1d6;"></i></a><a class="social-icon" href="/future_yl@outlook.com" target="_blank" title="My Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Java编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E5%86%85%E5%AE%B9%E4%BB%8B%E7%BB%8D"><span class="toc-text">第一章：内容介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9AJava%E6%A6%82%E8%BF%B0"><span class="toc-text">第二章：Java概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%8F%98%E9%87%8F"><span class="toc-text">第三章：变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">第四章：运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-text">第五章：程序控制结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE"><span class="toc-text">第六章：数组、排序和查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%89"><span class="toc-text">第七章：面向对象编程（初级）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-text">7.1 类与对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">7.2 成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6"><span class="toc-text">7.3 成员方法传参机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E6%96%B9%E6%B3%95%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="toc-text">7.4 方法递归调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-text">7.5 方法重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">7.6 可变参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">7.7 作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">7.8 构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">7.9 对象创建流程分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-10-this-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">7.10 this 关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89"><span class="toc-text">第八章：面向对象编程（中级）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-8-3-IDE-IDEA"><span class="toc-text">8.1~8.3 IDE - IDEA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E5%8C%85"><span class="toc-text">8.4 包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">8.5 访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-text">8.6 面向对象编程三大特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-%E5%B0%81%E8%A3%85"><span class="toc-text">8.7 封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-%E7%BB%A7%E6%89%BF"><span class="toc-text">8.8 继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-9-super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">8.9 super关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-10-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-%E8%A6%86%E7%9B%96"><span class="toc-text">8.10 方法重写&#x2F;覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-11-%E5%A4%9A%E6%80%81"><span class="toc-text">8.11 多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-12-Object%E7%B1%BB%E8%AF%A6%E8%A7%A3"><span class="toc-text">8.12 Object类详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-13-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95"><span class="toc-text">8.13 断点调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-14-%E9%9B%B6%E9%92%B1%E9%80%9A%E9%A1%B9%E7%9B%AE"><span class="toc-text">8.14 零钱通项目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E6%88%BF%E5%B1%8B%E5%87%BA%E7%A7%9F%E7%B3%BB%E7%BB%9F"><span class="toc-text">第九章：房屋出租系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">分层模式设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-text">源码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89"><span class="toc-text">第十章：面向对象编程（高级）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">10.1 类变量和类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E7%90%86%E8%A7%A3-main-%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95"><span class="toc-text">10.2 理解 main 方法语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">10.3 代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">10.4 单例设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-final-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">10.5 final 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">10.6 抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">10.7 抽象类最佳实践：模板设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-8-%E6%8E%A5%E5%8F%A3"><span class="toc-text">10.8 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-9%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">10.9内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-text">第十一章：枚举和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BEenumeration"><span class="toc-text">枚举enumeration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-text">注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-text">元注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%BC%82%E5%B8%B8-Exception"><span class="toc-text">第十二章：异常-Exception</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E5%BC%95%E5%87%BA"><span class="toc-text">12.1 引出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E5%BC%82%E5%B8%B8%E4%BB%8B%E7%BB%8D"><span class="toc-text">12.2 异常介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE"><span class="toc-text">12.3 异常体系图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-text">12.4 常见的运行时异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B8"><span class="toc-text">12.5 编译异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">12.6 异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-7-try-catch%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">12.7 try-catch异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-8-throws%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">12.8 throws异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-9-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-text">12.9 自定义异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-10-throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">12.10 throw和throws的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">第十三章：常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">13.1 包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-String%E7%B1%BB"><span class="toc-text">13.2 String类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">13.3 字符串的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">13.4 String类的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-StringBuffer%E7%B1%BB"><span class="toc-text">13.5 StringBuffer类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-StringBuilder%E7%B1%BB"><span class="toc-text">13.6 StringBuilder类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7-Math%E7%B1%BB"><span class="toc-text">13.7 Math类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-8-Arrays%E7%B1%BB"><span class="toc-text">13.8 Arrays类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-9-System%E7%B1%BB"><span class="toc-text">13.9 System类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-10-BigInteger%E7%B1%BB%E5%92%8CBigDecimal%E7%B1%BB"><span class="toc-text">13.10 BigInteger类和BigDecimal类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-11-%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-text">13.11 日期类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9A%E9%9B%86%E5%90%88"><span class="toc-text">第十四章：集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-%E9%9B%86%E5%90%88%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">14.1 集合的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-%E9%9B%86%E5%90%88%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB"><span class="toc-text">14.2 集合的框架体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-Collection%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">14.3 Collection接口和常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-List-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">14.4 List 接口和常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-ArrayList-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">14.5 ArrayList 底层结构和源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-Vector-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-text">14.6 Vector 底层结构和源码剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7-LinkedList-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-text">14.7 LinkedList 底层结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-8-ArrayList-%E5%92%8C-LinkedList-%E6%AF%94%E8%BE%83"><span class="toc-text">14.8 ArrayList 和 LinkedList 比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-9-Set-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">14.9 Set 接口和常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-10-Set-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-HashSet"><span class="toc-text">14.10 Set 接口实现类-HashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-11-Set-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-LinkedHashSet"><span class="toc-text">14.11 Set 接口实现类-LinkedHashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-12-Map-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">14.12 Map 接口和常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-13-Map-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-HashMap"><span class="toc-text">14.13 Map 接口实现类-HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-14-Map-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-Hashtable"><span class="toc-text">14.14 Map 接口实现类-Hashtable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-15-Map-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-Properties"><span class="toc-text">14.15 Map 接口实现类-Properties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-16-%E6%80%BB%E7%BB%93-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E9%9B%86%E5%90%88%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">14.16 总结-开发中如何选择集合实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-17-Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">14.17 Collections 工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E6%B3%9B%E5%9E%8B"><span class="toc-text">第十五章：泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-2-%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%A5%BD%E5%A4%84"><span class="toc-text">15.1 2 泛型的理解和好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-%E6%B3%9B%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="toc-text">15.3 泛型介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">15.4 泛型的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-6-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-text">15.6 自定义泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-7-%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">15.7 泛型的继承和通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-9-JUnit"><span class="toc-text">15.9 JUnit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">第十七章：多线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">17.1 线程相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">17.2 线程的基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-%E7%BB%A7%E6%89%BFThread-vs-%E5%AE%9E%E7%8E%B0Runnable"><span class="toc-text">17.3 继承Thread vs 实现Runnable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-text">17.4 线程终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-5-%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">17.5 线程常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-6-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">17.6 线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-7-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-text">17.7 线程的同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-8-Synchronized"><span class="toc-text">17.8 Synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-9-%E5%88%86%E6%9E%90%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-text">17.9 分析同步原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-10-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">17.10 互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-11-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%BB%E9%94%81"><span class="toc-text">17.11 线程的死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-12-%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-text">17.12 释放锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%EF%BC%9AIO%E6%B5%81"><span class="toc-text">第十九章：IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-1-%E6%96%87%E4%BB%B6"><span class="toc-text">19.1 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-2-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">19.2 常用的文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-IO%E6%B5%81%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">19.3 IO流原理及流的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-4-IO%E6%B5%81%E4%BD%93%E7%B3%BB%E5%9B%BE%E5%92%8C%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="toc-text">19.4 IO流体系图和常用的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-5-%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-text">19.5 节点流和处理流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8A%9F%E8%83%BD"><span class="toc-text">提供反序列化功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E5%BA%8F%E5%88%97%E5%8C%96%E5%8A%9F%E8%83%BD"><span class="toc-text">提供序列化功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-6-%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-text">19.6 打印流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-7-Properties%E7%B1%BB"><span class="toc-text">19.7 Properties类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">第二十一章：网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-1-%E7%BD%91%E7%BB%9C%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">21.1 网络的相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-2-InetAddress%E7%B1%BB"><span class="toc-text">21.2 InetAddress类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-3-Socket"><span class="toc-text">21.3 Socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-4-TCP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A8%8B"><span class="toc-text">21.4 TCP网络通信编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-5-UDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">21.5 UDP网络编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%8F%8D%E5%B0%84"><span class="toc-text">第二十三章：反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#23-1-%E5%BC%95%E5%87%BA%E8%83%8C%E6%99%AF"><span class="toc-text">23.1 引出背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-2-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-text">23.2 反射机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-3-Class%E7%B1%BB"><span class="toc-text">23.3 Class类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-4-%E8%8E%B7%E5%8F%96Class%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">23.4 获取Class类对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-5-%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E6%9C%89Class%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">23.5 哪些类型有Class对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-6-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-text">23.6 类加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-7-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%BF%A1%E6%81%AF"><span class="toc-text">23.7 通过反射获取类的结构信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-8-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">23.8 通过反射创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-9-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%AE%BF%E9%97%AE%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-text">23.9 通过反射访问类中的成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9AJava8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">补充：Java8新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8%E5%92%8C%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8"><span class="toc-text">构造器引用和数组引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StreamAPI"><span class="toc-text">StreamAPI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optional%E7%B1%BB"><span class="toc-text">Optional类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E6%97%A5%E6%9C%9FAPI"><span class="toc-text">新日期API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK%E5%BA%95%E5%B1%82%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-text">JDK底层代码优化</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/Web-Development-Sky-Takeout/" title="Web Development -- Sky Takeout">Web Development -- Sky Takeout</a><time datetime="2025-03-02T10:51:57.000Z" title="Created 2025-03-02 18:51:57">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/Springfox-Swagger/" title="Springfox Swagger">Springfox Swagger</a><time datetime="2025-03-02T10:42:33.000Z" title="Created 2025-03-02 18:42:33">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/Database-and-SQL-Basic-Concepts-and-Usage/" title="Database and SQL: Basic Concepts and Usage">Database and SQL: Basic Concepts and Usage</a><time datetime="2025-03-02T10:29:51.000Z" title="Created 2025-03-02 18:29:51">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/MyBatis-Plus-Basic-Usage/" title="MyBatis Plus Basic Usage">MyBatis Plus Basic Usage</a><time datetime="2025-03-02T10:19:09.000Z" title="Created 2025-03-02 18:19:09">2025-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/MIT-The-Missing-Semester-Lec10-Potpourri/" title="[MIT The Missing Semester] Lec10: Potpourri">[MIT The Missing Semester] Lec10: Potpourri</a><time datetime="2025-03-02T10:10:46.000Z" title="Created 2025-03-02 18:10:46">2025-03-02</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(to right, rgb(198, 255, 221), rgb(251, 215, 134), rgb(247, 121, 125));"><div id="footer-wrap"><div class="copyright">&copy;2025 By yl</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search through all posts and pages" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>