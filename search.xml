<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web Development -- Sky Takeout</title>
      <link href="/2025/03/02/Web-Development-Sky-Takeout/"/>
      <url>/2025/03/02/Web-Development-Sky-Takeout/</url>
      
        <content type="html"><![CDATA[<h1>苍穹外卖</h1><h2 id="基础数据模块">基础数据模块</h2><h3 id="项目概述">项目概述</h3><h4 id="软件开发整体介绍">软件开发整体介绍</h4><h5 id="软件开发流程（从上至下）">软件开发流程（从上至下）</h5><ol><li>需求分析：需求规格说明书、产品原型</li><li>设计：UI设计、数据库设计、接口设计</li><li>编码：项目代码、单元测试</li><li>测试：测试用例、测试报告</li><li>上线运维：软件环境安装、配置</li></ol><h5 id="角色分工">角色分工</h5><ul><li>项目经理：对整个项目负责，<strong>任务分配、把控进度</strong></li><li>产品经理：进行<strong>需求调研</strong>，输出需求调研文档、产品原型等</li><li>UI设计师：根据产品原型输出<strong>界面效果图</strong></li><li>架构师：项目整体<strong>架构设计、技术选型</strong>等</li><li>开发工程师：代码实现</li><li>测试工程师：编写测试用例、输出测试报告</li><li>运维工程师：软件环境搭建、项目上线</li></ul><h5 id="软件环境">软件环境</h5><ul><li>开发环境（development）：开发人员在开发阶段使用的环境，一般外部用户无法访问</li><li>测试环境（tesing）：专门给测试人员使用的环境，用于测试项目，一般外部用户无法访问</li><li>生产环境（production）：即线上环境，正式提供对外服务的环境</li></ul><h4 id="苍穹外卖项目介绍">苍穹外卖项目介绍</h4><h5 id="项目介绍">项目介绍</h5><p>**定位：**专门为餐饮企业（餐厅、饭店）定制的一款软件产品</p><p>功能架构：体现项目中的业务功能模块</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%8A%9F%E8%83%BD%E6%9E%B6%E6%9E%84.png" class=""><h5 id="产品原型">产品原型</h5><p><strong>用于展示项目的业务功能，一般由产品经理进行设计</strong></p><p>一般为一组 HTML 网页，内含页面原型和需求介绍以及设计要求</p><h5 id="技术选型">技术选型</h5><p><strong>展示项目中使用到的技术框架和中间件等</strong></p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B.png" class=""><h6 id="用户层（主要是前端技术）：">用户层（主要是前端技术）：</h6><ul><li>Node.js</li><li>Vue.js</li><li>ElementUI</li><li>微信小程序</li><li>Apache Echarts</li></ul><h6 id="网关层：Nginx">网关层：Nginx</h6><h6 id="应用层（主要是后端技术）：">应用层（主要是后端技术）：</h6><ul><li>Spring Boot</li><li>Spring MVC</li><li>Spring Task（订单计时）</li><li>HttpClient（发送 HTTP 请求）</li><li>Spring Cache（缓存框架）</li><li>JWT</li><li>阿里云OSS</li><li>Swagger</li><li>POI（操作 Excel 表格）</li><li>WebSocket（实现催单，来单提醒。一种网络协议）</li></ul><h6 id="数据层：">数据层：</h6><ul><li>MySQL</li><li>Redis（数据库缓存中间件）</li><li>MyBatis</li><li>PageHelper</li><li>Spring Data Redis（简化操作 Redis 的一组 API）</li></ul><h6 id="工具：">工具：</h6><ul><li>Git</li><li>JUnit</li><li>Maven</li><li>Postman</li></ul><h3 id="环境搭建">环境搭建</h3><h4 id="开发环境搭建">开发环境搭建</h4><h5 id="前端环境搭建">前端环境搭建</h5><h6 id="整体结构">整体结构</h6><img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%89%8D%E7%AB%AF%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png" class=""><ul><li><p>双击前端环境 <code>Nginx</code> 文件夹中的 <code>nginx.exe</code> 启动 nginx 服务，访问端口号为 <code>80</code></p></li><li><p>前端项目已经部署到了 <code>Nginx</code> 文件夹中，通过 <code>localhost:80</code> 即可访问到前端项目</p></li></ul><h5 id="后端环境搭建">后端环境搭建</h5><p>后端工程基于 <strong>Maven</strong> 进行项目构建，并且进行<strong>分模块</strong>开发</p><h6 id="项目结构：">项目结构：</h6><img src="/2025/03/02/Web-Development-Sky-Takeout/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" class=""><h6 id="项目各模块说明：">项目各模块说明：</h6><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>sky-take-out</td><td>Maven 父工程，统一管理依赖版本，聚合其他子模块</td></tr><tr><td>sky-common</td><td>子模块，存放公共类，例如：工具类、常量类、异常类等</td></tr><tr><td>sky-pojo</td><td>子模块，存放实体类、VO、DTO 等</td></tr><tr><td>sky-server</td><td>子模块，后端服务，存放配置文件、Controller、Service、Mapper 等</td></tr></tbody></table><h6 id="sky-common-模块目录结构：">sky-common 模块目录结构：</h6><img src="/2025/03/02/Web-Development-Sky-Takeout/sky-common.png" class=""><p>存放公共类，可以供其他模块使用</p><h6 id="sky-pojo-模块目录结构：">sky-pojo 模块目录结构：</h6><img src="/2025/03/02/Web-Development-Sky-Takeout/sky-pojo.png" class=""><p>存放 entity、DTO、VO</p><ul><li><p>名词解释：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Entity</td><td>实体，通常和数据库中的表对应</td></tr><tr><td>DTO</td><td>数据传输对象，通常用于程序中各层之间传递数据</td></tr><tr><td>VO</td><td>视图对象，为前端展示数据提供的对象</td></tr><tr><td>POJO</td><td>普通 Java 对象，只有属性和对应的 getter 和 setter</td></tr></tbody></table></li></ul><h6 id="sky-server-模块目录结构：">sky-server 模块目录结构：</h6><img src="/2025/03/02/Web-Development-Sky-Takeout/sky-server.png" class=""><p>存放配置文件、配置类、拦截器、controller、service、mapper、启动类等</p><h6 id="使用-Git-进行版本控制">使用 Git 进行版本控制</h6><ol><li>创建本地仓库</li><li>提交本地仓库</li><li>推送到远程仓库</li></ol><h6 id="数据库环境搭建">数据库环境搭建</h6><p>执行提供的 sql 脚本</p><h6 id="前后端联调">前后端联调</h6><blockquote><p><strong>nginx 反向代理：</strong></p><p>nginx 反向代理，就是将前端发送的动态请求由 nginx 转发到后端服务器</p><p>nginx 反向代理的好处：</p><ul><li><p>提高访问速度</p></li><li><p>进行负载均衡</p><blockquote><p>所谓负载均衡，就是把大量的请求按照我们指定的方式均衡地分配给集群中的每台服务器</p></blockquote></li><li><p>保证后端服务安全（外界无法直接访问后端服务，不对外开放，只能由公司内网请求）</p></li></ul><p><strong>反向代理配置方式：</strong></p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"><span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /api/ &#123; <span class="comment"># 当请求路径中含有/api/时，将/api/前面的部分改为http://localhost:8080/admin/，后面的部分拼在其后</span></span><br><span class="line"><span class="attribute">proxy_pass</span> http://localhost:8080/admin/; <span class="comment"># 反向代理</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>负载均衡配置方式：</strong></p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> webservers &#123; <span class="comment"># 服务器集群每台服务器ip</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.100.128:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.100.129:8080</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /api/ &#123; <span class="comment"># 具体转发给哪台主机，哪台主机转发多，哪台转发少，由负载均衡策略决定</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://webservers/admin/; <span class="comment"># 负载均衡</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>负载均衡策略：</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>轮询</td><td>默认方式</td></tr><tr><td>weight</td><td>权重方式，默认为1，权重越高，被分配的客户端请求就越多</td></tr><tr><td>ip_hash</td><td>根据 ip 分配方式，这样每个访客可以固定访问一个后端服务</td></tr><tr><td>least_conn</td><td>依据最少连接方式，把请求优先分配给连接数少的后端服务</td></tr><tr><td>url_hash</td><td>根据 url 分配方式，这样相同的 url 会被分配到同一个后端服务</td></tr><tr><td>fair</td><td>依据响应时间方式，响应时间短的服务将会被优先分配</td></tr></tbody></table></blockquote><h5 id="完善登录功能">完善登录功能</h5><p>问题：员工表中的密码是明文存储，安全性太低</p><p>思路：</p><ol><li><p>将密码加密后存储，提高安全性</p></li><li><p>使用 MD5 加密方式对明文密码加密</p><blockquote><p>MD5（Message Digest Algorithm 5）是一种哈希函数，而不是加密算法。哈希函数是一种将任意长度的输入数据映射为固定长度散列值的算法。MD5 产生的散列值通常是128位长，通常以32个十六进制字符的形式表示。</p><p>MD5 算法的特点是快速且具有固定输出长度。然而，由于其设计上的一些弱点，MD5 已经被认为不安全，不建议在安全性要求较高的场景中使用。在现代加密和安全标准中，通常推荐使用更安全的哈希函数，如SHA-256（Secure Hash Algorithm 256-bit）等。</p></blockquote></li><li><p>验证时将明文加密为密文，再与数据库中已有密码比较</p></li></ol><p>步骤：</p><ol><li><p>修改数据库中明文密码，改为 MD5 加密后的密文</p></li><li><p>修改 Java 代码，前端提交的密码进行 MD5 加密后再跟数据库中密码比对</p><blockquote><p>Spring 框架提供了对字符串进行 MD5 加密的工具类，使用如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">password = DigestUtils.md5DigestAsHex(password.getBytes());</span><br><span class="line"><span class="keyword">if</span> (!password.equals(employee.getPassword())) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PassWordErrorException</span>(MessageConstant.PASSWORD_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><h4 id="导入接口文档">导入接口文档</h4><h5 id="前后端分离开发流程">前后端分离开发流程</h5><img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.png" class=""><h5 id="操作步骤">操作步骤</h5><p>将资料中提供的项目接口导入 YApi</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E9%A1%B9%E7%9B%AE%E6%8E%A5%E5%8F%A3.png" class=""><p>管理端共47个接口，用户端共25个接口</p><h4 id="Swagger">Swagger</h4><h5 id="介绍">介绍</h5><p>使用 Swagger，你只需要按照它的规范去定义接口及接口相关的信息，就可以做到生成接口文档，以及<strong>在线接口调试</strong>页面。</p><p>官网：[<a href="http://swagger.io">http://swagger.io</a>](Swagger 官网)</p><p><strong>Knife4j</strong> 是为 Java MVC 框架集成 Swagger 生成 Api 文档的增强解决方案</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="使用方式">使用方式</h5><ol><li>导入 knife4j 的 maven 坐标</li><li>在配置类中加入 knife4j 相关配置</li><li>设置静态资源映射，否则接口文档页面无法访问</li></ol><blockquote><p>Swagger 和 YApi</p><ul><li>YApi 是设计阶段使用的工具，用于管理和维护接口</li><li>Swagger 是开发阶段使用的框架，帮助后端开发人员做后端的接口测试</li><li>YApi 和 Swagger 的侧重点不同，不能说谁替代了谁，在项目开发中两者都是必要的</li></ul></blockquote><h5 id="常用注解">常用注解</h5><p><code>@Api</code>：对 controller 类的说明</p><p><code>@ApiModel</code>：对 pojo 类的说明</p><p><code>@ApiModelProperty</code> ：对 pojo 类的属性的说明</p><p><code>@ApiOperation</code>：对方法用途、作用等的说明</p><h3 id="员工管理">员工管理</h3><h4 id="新增员工">新增员工</h4><h5 id="需求分析">需求分析</h5><ul><li><p>分析传递参数限制</p></li><li><p>设计接口</p><blockquote><p>为方便后端区分，管理端发出的请求，统一使用 /admin 作为前缀，用户端发出的请求，统一使用 /user 作为前缀</p></blockquote></li><li><p>查看对应数据库，来明晰数据约束</p></li></ul><h5 id="代码开发">代码开发</h5><p>根据新增员工接口设计对应的 DTO</p><blockquote><p>注意：当前端提交的数据和实体类中对应的属性差别比较大时，建议使用 DTO 来封装数据</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDTO</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String idNumber;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="功能测试">功能测试</h5><h5 id="代码完善">代码完善</h5><ul><li><p>录入的用户名已存在，抛出异常后没有处理</p><p>用全局异常处理类来捕获相应异常，并返回给前端异常信息。</p></li><li><p>新增员工时，创建人 ID 和修改人 ID 设置为了固定值</p><ol><li>从请求头中拿到 token，读取出 token 中的员工 id</li><li>第一步操作是在 JwtTokenAdminInterceptor 类中完成的，如何将拿到的员工 id 传给 service 层的 save 方法？</li><li>使用 ThreadLocal 类，由于客户端的一次请求会在同一个线程中进行，所以我们可以先把员工 id 存到 ThreadLocal 类中，然后在之后需要的时候再取出来用</li></ol><img src="/2025/03/02/Web-Development-Sky-Takeout/ThreadLocal.png" class=""></li></ul><h4 id="员工分页查询">员工分页查询</h4><p>使用 EmployeePageQueryDTO 接收前端参数，返回 Result<PageResult> 对象，泛型中含有查询的总条数和该页的员工列表。</p><p>问题：查询返回的日期格式不符合预期</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%BC%82%E5%B8%B8%E6%A0%BC%E5%BC%8F%E6%97%A5%E6%9C%9F.png" class=""><p>解决方法：</p><ul><li><p>在属性上加入注解，对日期进行格式化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createTime;</span><br></pre></td></tr></table></figure></li><li><p>在 WebMvcConfiguration 中扩展 Spring MVC 的消息转换器，统一对日期类型进行格式化处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个消息转换器对象</span></span><br><span class="line">    <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json对象</span></span><br><span class="line">    converter.setObjectMapper(<span class="keyword">new</span> <span class="title class_">JacksonObjectMapper</span>());</span><br><span class="line">    <span class="comment">// 将自己的消息转换器加入到容器中，并设置优先级为0（第一）</span></span><br><span class="line">    converters.add(<span class="number">0</span>, converter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="启用禁用员工账号">启用禁用员工账号</h4><p>无新增技术</p><h4 id="编辑员工">编辑员工</h4><p>无新增技术</p><h3 id="分类管理">分类管理</h3><h4 id="导入分类模块功能代码">导入分类模块功能代码</h4><h3 id="菜品管理">菜品管理</h3><h4 id="公共字段自动填充">公共字段自动填充</h4><p>**问题：**每次增加菜品、分类等都要填充创建时间、修改时间、创建人id和修改人id，代码冗余</p><p><strong>解决思路：</strong></p><ol><li><p>明确操作时机</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85-%E6%98%8E%E7%A1%AE%E6%93%8D%E4%BD%9C%E6%97%B6%E6%9C%BA.png" class=""></li><li><p>使用 AOP 来为公共字段填充值，具体做法是：</p><ol><li>自定义注解 AutoFill，用于表示需要进行公共字段自动填充的方法</li><li>自定义切面类 AutoFillAspect，统一拦截加入了 AutoFill 注解的方法，通过反射为公共字段赋值</li><li>在对应方法上加入注解</li></ol></li></ol><p>技术点：枚举、注解、AOP、反射</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoFillAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.sky.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">servicePointCut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mapperPointCut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;(servicePointCut() || mapperPointCut()) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFillAspect</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;autoFillAspect()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFill</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 日志记录</span></span><br><span class="line">        log.info(<span class="string">&quot;进行公共字段自动填充&quot;</span>);</span><br><span class="line">        <span class="comment">// 拿到操作类型</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        <span class="type">AutoFill</span> <span class="variable">annotation</span> <span class="operator">=</span> (AutoFill) signature.getMethod().getAnnotation(AutoFill.class);</span><br><span class="line">        <span class="type">OperationType</span> <span class="variable">type</span> <span class="operator">=</span> annotation.value();</span><br><span class="line">        <span class="comment">// 拿到方法参数</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">entity</span> <span class="operator">=</span> joinPoint.getArgs()[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 数据准备</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line">        <span class="comment">// 通过反射来设置值</span></span><br><span class="line">        <span class="keyword">if</span> (type == OperationType.INSERT) &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">setCreateTime</span> <span class="operator">=</span> entity.getClass().getMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">setCreateUser</span> <span class="operator">=</span> entity.getClass().getMethod(AutoFillConstant.SET_CREATE_USER, Long.class);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);</span><br><span class="line"></span><br><span class="line">            setCreateTime.invoke(entity, now);</span><br><span class="line">            setUpdateTime.invoke(entity, now);</span><br><span class="line">            setCreateUser.invoke(entity, id);</span><br><span class="line">            setUpdateUser.invoke(entity, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == OperationType.UPDATE) &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);</span><br><span class="line"></span><br><span class="line">            setUpdateTime.invoke(entity, now);</span><br><span class="line">            setUpdateUser.invoke(entity, id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新增菜品">新增菜品</h4><ol><li>使用 DTO 接收前端传参</li><li>公共字段自动填充</li><li>完成新增菜品</li><li>拿到返回的新增菜品的id</li><li>新增口味</li></ol><h4 id="菜品分页查询">菜品分页查询</h4><h4 id="删除菜品">删除菜品</h4><p>业务规则：</p><ul><li>可以一次删除一个菜品，也可以批量删除菜品</li><li>起售中的菜品不能删除</li><li>被套餐关联的菜品不能删除</li><li>删除菜品后，关联的口味数据也需要删除掉</li></ul><p><strong>重要</strong></p><p>前端请求路径为 <code>..?ids=1,2,3</code></p><p>我们如果想要用 List 来接收这些 id，就需要在参数前面加上注解 <code>@RequestParam</code>，这样，springMVC 会帮我们把形如 <code>1,2,3</code> 的数据格式以列表的方式封装到我们的 List 中</p><h4 id="修改菜品">修改菜品</h4><p>先修改菜品信息，再统一删除关联口味信息，最后添加上修改后的口味信息</p><h3 id="套餐管理实战">套餐管理实战</h3><h4 id="新增套餐">新增套餐</h4><p>分析需求：</p><ul><li>套餐状态默认为停售</li><li>一个套餐可以对应多个菜品</li><li>一个菜品可以对应多个套餐</li><li>新增后要维护 setmeal_dish 表</li><li>categoryId 即为套餐所属分类的 id</li></ul><h4 id="分页查询套餐">分页查询套餐</h4><p>分析需求：</p><ul><li>用 SetmealVO 来包装数据</li><li>返回 PageResult 对象</li><li>根据 categoryId 查出分类名，使用多表查询</li><li>分类被禁用后，前台不展示</li></ul><p><strong>使用别名进行多表查询时，select 后面跟的字段名也一定要起与实体类对应的别名，否则查询结果无法映射到实体类的属性上</strong></p><h4 id="删除套餐">删除套餐</h4><p>分析需求：</p><ul><li>批量删除，使用 ids 接收前端传参，用 @RequestParam 让 SpringMVC 自动封装到 List 中</li><li>起售的套餐不能删除</li><li>能够删除的套餐，关联的菜品也要一并删除</li><li>包含起售的套餐，则最后抛异常，并不予删除</li></ul><h4 id="修改套餐">修改套餐</h4><p>分析需求：</p><ul><li>实现根据 id 查询用于页面回显</li><li>用 setmealDTO 接收前端传参</li><li>自动填充公共字段</li><li>先统一删除关联菜品再添加修改后的菜品</li></ul><h4 id="起售停售套餐">起售停售套餐</h4><p>分析需求：</p><ul><li>套餐内有停售菜品，则套餐无法起售</li></ul><h3 id="Redis">Redis</h3><h4 id="Redis-入门">Redis 入门</h4><h5 id="Redis-简介">Redis 简介</h5><p>Redis 是一个基于内存的 key-value 结构数据库</p><ul><li>基于内存存储，读写性能高</li><li>适合存储热点数据（热点商品、咨询、新闻，在某一时间段会被用户大量访问的数据）</li><li>企业应用广泛</li></ul><p>官网：<a href="https://redis.io">https://redis.io</a></p><p>中文网：<a href="https://www.redis.net.cn/">https://www.redis.net.cn/</a></p><h5 id="Redis-下载与安装">Redis 下载与安装</h5><p>Windows 版本下的 Redis 目录结构</p><img src="/2025/03/02/Web-Development-Sky-Takeout/Redis-win%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" class=""><h5 id="Redis-服务启动与停止">Redis 服务启动与停止</h5><p>服务启动：<code>redis-server</code></p><p>服务停止：<code>ctrl+c or command+c</code></p><p>客户端登录：<code>redis-cli -h ipaddress -p port</code></p><p>客户端退出：<code>exit</code></p><p>Redis 默认登录没有密码，为提高安全性，在配置文件中配置登录密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 找到这一行配置项</span><br><span class="line">requirepass yourPassword</span><br></pre></td></tr></table></figure><p><strong>Redis 中没有用户这一概念</strong></p><h4 id="Redis-数据类型">Redis 数据类型</h4><h5 id="5-种常用数据类型介绍">5 种常用数据类型介绍</h5><p>Redis 使用键值对 key-value 结构来存储数据，其中 key 规定是字符串类型，而 value 有 5 种常用类型：</p><ul><li>字符串 string</li><li>哈希 hash （适合存储对象）</li><li>列表 list</li><li>集合 set</li><li>有序集合 sorted set / zet</li></ul><h5 id="各种数据类型的特点">各种数据类型的特点</h5><img src="/2025/03/02/Web-Development-Sky-Takeout/redis%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9.png" class=""><h4 id="Redis-常用命令">Redis 常用命令</h4><p>==Redis 命令不区分大小写==</p><h5 id="字符串操作命令">字符串操作命令</h5><table><thead><tr><th>命令</th><th>意义</th></tr></thead><tbody><tr><td><code>SET key value</code></td><td>设置指定 key 的value</td></tr><tr><td><code>GET key</code></td><td>获取指定 key 的 value</td></tr><tr><td><code>SETEX key seconds value</code></td><td>设置指定 key 的value， 并将 key 的过期时间设为 seconds 秒</td></tr><tr><td><code>SETNX key value</code></td><td>只有当 key 不存在时设置 key 的value（防覆盖）</td></tr></tbody></table><h5 id="哈希操作命令">哈希操作命令</h5><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，常用命令：</p><table><thead><tr><th>命令</th><th>意义</th></tr></thead><tbody><tr><td><code>HSET key field value</code></td><td>将名为 key 的哈希表中的字段 field 的值设为 value</td></tr><tr><td><code>HSET key field</code></td><td>获取存储在哈希表 key 中的指定 field 的 value</td></tr><tr><td><code>HDEL key field</code></td><td>删除存储在哈希表 key 中的指定 field</td></tr><tr><td><code>HKEYS key</code></td><td>获取哈希表中所有 field</td></tr><tr><td><code>HVALS key</code></td><td>获取哈希表中所有 value</td></tr></tbody></table><p>哈希表的 key-value 的形象图示</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%93%88%E5%B8%8C%E8%A1%A8key-value%E5%9B%BE%E7%A4%BA.png" class=""><h5 id="列表操作命令">列表操作命令</h5><p>Redis 列表是简单的<strong>字符串</strong>列表，按照插入顺序排序，常用命令：</p><table><thead><tr><th>命令</th><th>意义</th></tr></thead><tbody><tr><td><code>LPUSH key value1 [value2]</code></td><td>将一个或多个值插入到列表头部</td></tr><tr><td><code>LRANGE key start stop</code></td><td>获取列表指定范围内的元素（0 表示开头，-1 表示结尾）</td></tr><tr><td><code>RPOP key</code></td><td>移除并获取列表最后一个元素</td></tr><tr><td><code>LLEN key</code></td><td>获取列表长度</td></tr></tbody></table><img src="/2025/03/02/Web-Development-Sky-Takeout/redis%E5%88%97%E8%A1%A8%E5%9B%BE%E7%A4%BA.png" class=""><h5 id="集合操作命令">集合操作命令</h5><p>Redis set 是 string 类型的无序集合。集合成员是唯一的，集合中不能出现重复的数据，常用命令：</p><table><thead><tr><th>命令</th><th>意义</th></tr></thead><tbody><tr><td><code>SADD key member1 [member2]</code></td><td>向集合 key 中添加一个或多个 member</td></tr><tr><td><code>SMEMBERS key</code></td><td>返回集合 key 中的所有 member</td></tr><tr><td><code>SCARD key</code></td><td>获取集合 key 中的 member 数量</td></tr><tr><td><code>SINTER key1 [key2]</code></td><td>返回集合 key1 [key2] 等的交集</td></tr><tr><td><code>SUNION key1 [key2]</code></td><td>返回集合 key1 [key2] 等的并集</td></tr><tr><td><code>SREM key member1 [member2]</code></td><td>删除集合 key 中的一个或多个 member</td></tr></tbody></table><img src="/2025/03/02/Web-Development-Sky-Takeout/redis%E9%9B%86%E5%90%88%E5%9B%BE%E7%A4%BA.png" class=""><h5 id="有序集合操作命令">有序集合操作命令</h5><p>Redis 有序集合是 string 类型元素的集合，且不允许有重复成员。每个元素都会关联一个 double 类型的分数。常用命令：</p><table><thead><tr><th>命令</th><th>意义</th></tr></thead><tbody><tr><td><code>ZADD key score1 member1 [score2 member2]</code></td><td>向有序集合 key 中添加一个或多个带 score 的 member</td></tr><tr><td><code>ZRANGE key start stop [WITHSCORES]</code></td><td>通过索引区间返回有序集合 key 中指定区间内的 member （及其 score）（分数升序）</td></tr><tr><td><code>ZINCRBY key increment member</code></td><td>对有序集合 key 中对指定 member 成员的 score 加上增量 increment</td></tr><tr><td><code>ZREM key member [member...]</code></td><td>删除有序集合 key 中的一个或多个 member</td></tr></tbody></table><img src="/2025/03/02/Web-Development-Sky-Takeout/redis%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%9B%BE%E7%A4%BA.png" class=""><h5 id="通用命令">通用命令</h5><p>Redis 的通用命令是不区分数据类型的，都可以使用的命令：</p><table><thead><tr><th>命令</th><th>意义</th></tr></thead><tbody><tr><td><code>KEYS pattern</code></td><td>查找所有符合给定 pattern 的 key（支持通配符）</td></tr><tr><td><code>EXISTS key</code></td><td>检查给定的 key 是否存在</td></tr><tr><td><code>TYPE key</code></td><td>返回 key 所储存的值的类型</td></tr><tr><td><code>DEL key</code></td><td>当 key 存在时将 key 删除，可一次删除多个，用空格隔开 key</td></tr></tbody></table><h4 id="在-Java-中操作-Redis">在 Java 中操作 Redis</h4><h5 id="Redis-的-Java-客户端">Redis 的 Java 客户端</h5><p>Redis 的 Java 客户端很多，常用的有以下几种：</p><ul><li>Jedis（Redis 官方推荐）</li><li>Lettuce（性能高效）</li><li>Spring Data Redis</li></ul><p>Spring Data Redis 是 Spring 的一部分，对 Redis 底层开发包（包括 Jedis 和 Lettuce） 进行了高度封装。</p><p>在 Spring 项目中，可以使用 Spring Data Redis 来简化操作</p><h5 id="Spring-Data-Redis-使用方式">Spring Data Redis 使用方式</h5><h6 id="步骤：">步骤：</h6><ol><li><p>导入 Spring Data Redis 的 maven 坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置 Redis 数据源</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">...re</span></span><br></pre></td></tr></table></figure></li><li><p>编写配置类，创建 RedisTemplate 对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始创建RedisTemplate对象&quot;</span>);</span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">// 设置序列化器</span></span><br><span class="line">        redisTemplate.setDefaultSerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过 RedisTemplate 对象操作 Redis</p><p>该对象提供了操作五种数据类型的对象</p><img src="/2025/03/02/Web-Development-Sky-Takeout/SpringDataRedis%E6%93%8D%E4%BD%9C%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%B9%E8%B1%A1.png" class=""></li></ol><h6 id="字符串操作">字符串操作</h6><img src="/2025/03/02/Web-Development-Sky-Takeout/SpringDataRedis%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2.png" class=""><p>set 中的多个重载方法就对应了 set setex，setIfAbsent 对应了 setnx，get 对应了 get</p><h6 id="哈希操作">哈希操作</h6><img src="/2025/03/02/Web-Development-Sky-Takeout/SpringDataRedis%E5%93%88%E5%B8%8C%E6%93%8D%E4%BD%9C.png" class=""><p>hset 对应 put，hget 对应 get，hdel 对应 delete，hkeys 对应 keys，hvals 对应 values</p><h6 id="列表操作">列表操作</h6><img src="/2025/03/02/Web-Development-Sky-Takeout/SpringDataRedis%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9C.png" class=""><h6 id="集合操作">集合操作</h6><img src="/2025/03/02/Web-Development-Sky-Takeout/SpringDataRedis%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C.png" class=""><h6 id="有序集合">有序集合</h6><img src="/2025/03/02/Web-Development-Sky-Takeout/SpringDataRedis%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C.png" class=""><h6 id="通用命令-2">通用命令</h6><img src="/2025/03/02/Web-Development-Sky-Takeout/SpringDataRedis%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C.png" class=""><h2 id="点餐业务模块">点餐业务模块</h2><h3 id="店铺营业状态设置">店铺营业状态设置</h3><h4 id="需求分析和设计">需求分析和设计</h4><p>接口设计：</p><ul><li>设置营业状态</li><li>管理端查询营业状态</li><li>用户端查询营业状态</li></ul><p>项目约定（设置两个查询接口的原因）：</p><ul><li>管理端发出的请求，统一使用 /admin 作为前缀</li><li>用户端发出的请求，统一使用 /user 作为前缀</li></ul><p>营业状态数据存储方式：基于 Redis 的字符串来进行存储</p><h4 id="代码开发-2">代码开发</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController(&quot;adminShopController&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/shop&quot;)</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor(onConstructor_ = &#123;@Autowired&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShopService shopService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;status&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">updateStatus</span><span class="params">(<span class="meta">@PathVariable</span> Integer status)</span> &#123;</span><br><span class="line">        <span class="comment">// 日志记录</span></span><br><span class="line">        log.info(<span class="string">&quot;将店铺的营业状态设置为：&#123;&#125;&quot;</span>, status);</span><br><span class="line">        <span class="comment">// 调用service完成状态更新</span></span><br><span class="line">        shopService.updateStatus(status.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/status&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Integer&gt; <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 日志记录</span></span><br><span class="line">        log.info(<span class="string">&quot;管理端获取店铺状态&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用service获取状态</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> shopService.getStatus();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController(&quot;userShopController&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/shop&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor(onConstructor_ = &#123;@Autowired&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShopService shopService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/status&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Integer&gt; <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 日志记录</span></span><br><span class="line">        log.info(<span class="string">&quot;用户端获取店铺状态&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用service获取状态</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> shopService.getStatus();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor(onConstructor_ = &#123;@Autowired&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ShopService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStatus</span><span class="params">(String status)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(StatusConstant.SHOP_STATUS, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(redisTemplate.opsForValue().get(StatusConstant.SHOP_STATUS).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="功能测试-2">功能测试</h4><h3 id="微信登录">微信登录</h3><h4 id="HttpClient">HttpClient</h4><h5 id="介绍-2">介绍</h5><p>HttpClient 是 Apache Jakarta Common 下的子项目，可以用来提供高效的、最新的、功能丰富的支持 HTTP 协议的<strong>客户端编程工具包</strong>，并且它支持 HTTP 协议最新的版本和建议。</p><p>Maven 坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>核心 API</p><ul><li>HttpClient</li><li>HttpClients</li><li>CloseableHttpClient</li><li>HttpGet</li><li>HttpPost</li></ul><p>发送请求步骤：</p><ul><li>创建 HttpClient 对象</li><li>创建 Http 请求对象</li><li>调用 HttpClient 的 execute 方法发送请求</li></ul><h5 id="入门案例">入门案例</h5><h6 id="GET-请求">GET 请求</h6><img src="/2025/03/02/Web-Development-Sky-Takeout/HttpGet.png" class=""><h6 id="POST-请求">POST 请求</h6> <img src="/2025/03/02/Web-Development-Sky-Takeout/HttpPost.png" class=""><p>记得关闭资源</p><h6 id="代码中提供的工具类">代码中提供的工具类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpClientUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span>  <span class="type">int</span> <span class="variable">TIMEOUT_MSEC</span> <span class="operator">=</span> <span class="number">5</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送GET方式请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paramMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">doGet</span><span class="params">(String url,Map&lt;String,String&gt; paramMap)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建Httpclient对象</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">URIBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URIBuilder</span>(url);</span><br><span class="line">            <span class="keyword">if</span>(paramMap != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (String key : paramMap.keySet()) &#123;</span><br><span class="line">                    builder.addParameter(key,paramMap.get(key));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> builder.build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建GET请求</span></span><br><span class="line">            <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(uri);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//发送请求</span></span><br><span class="line">            response = httpClient.execute(httpGet);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断响应状态</span></span><br><span class="line">            <span class="keyword">if</span>(response.getStatusLine().getStatusCode() == <span class="number">200</span>)&#123;</span><br><span class="line">                result = EntityUtils.toString(response.getEntity(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.close();</span><br><span class="line">                httpClient.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送POST方式请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paramMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">doPost</span><span class="params">(String url, Map&lt;String, String&gt; paramMap)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建Httpclient对象</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resultString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Http Post请求</span></span><br><span class="line">            <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建参数列表</span></span><br><span class="line">            <span class="keyword">if</span> (paramMap != <span class="literal">null</span>) &#123;</span><br><span class="line">                List&lt;NameValuePair&gt; paramList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; param : paramMap.entrySet()) &#123;</span><br><span class="line">                    paramList.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(param.getKey(), param.getValue()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 模拟表单</span></span><br><span class="line">                <span class="type">UrlEncodedFormEntity</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlEncodedFormEntity</span>(paramList);</span><br><span class="line">                httpPost.setEntity(entity);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            httpPost.setConfig(builderRequestConfig());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行http请求</span></span><br><span class="line">            response = httpClient.execute(httpPost);</span><br><span class="line"></span><br><span class="line">            resultString = EntityUtils.toString(response.getEntity(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送POST方式请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paramMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">doPost4Json</span><span class="params">(String url, Map&lt;String, String&gt; paramMap)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建Httpclient对象</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resultString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Http Post请求</span></span><br><span class="line">            <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(url);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (paramMap != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//构造json格式数据</span></span><br><span class="line">                <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; param : paramMap.entrySet()) &#123;</span><br><span class="line">                    jsonObject.put(param.getKey(),param.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">StringEntity</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringEntity</span>(jsonObject.toString(),<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                <span class="comment">//设置请求编码</span></span><br><span class="line">                entity.setContentEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                <span class="comment">//设置数据类型</span></span><br><span class="line">                entity.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">                httpPost.setEntity(entity);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            httpPost.setConfig(builderRequestConfig());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行http请求</span></span><br><span class="line">            response = httpClient.execute(httpPost);</span><br><span class="line"></span><br><span class="line">            resultString = EntityUtils.toString(response.getEntity(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultString;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RequestConfig <span class="title function_">builderRequestConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RequestConfig.custom()</span><br><span class="line">                .setConnectTimeout(TIMEOUT_MSEC)</span><br><span class="line">                .setConnectionRequestTimeout(TIMEOUT_MSEC)</span><br><span class="line">                .setSocketTimeout(TIMEOUT_MSEC).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="微信小程序开发">微信小程序开发</h4><h5 id="介绍-3">介绍</h5><p>微信小程序，一种新的开放能力，可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p><p>官方介绍：<a href="https://mp.weixin.qq.com/cgi-bin/wx">公众号 (qq.com)</a></p><p>接入流程：</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B.png" class=""><p>开放注册范围：</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E6%94%BE%E6%B3%A8%E5%86%8C%E8%8C%83%E5%9B%B4.png" class=""><p>不同的注册范围享有不同的权限，个人注册范围无法接入微信支付功能</p><h5 id="准备工作">准备工作</h5><p>开发微信小程序之前需要做如下准备工作：</p><ul><li>注册小程序</li><li>完善小程序信息</li><li>下载开发者工具</li></ul><h5 id="入门案例-2">入门案例</h5><p>步骤</p><ul><li>了解小程序目录结构</li><li>编写小程序代码</li><li>编译小程序</li></ul><h6 id="目录结构">目录结构</h6><p>小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。</p><p>一个小程序的主体部分由三个文件组成，必须放在项目的根目录，如下：</p><table><thead><tr><th>文件</th><th>必需</th><th>作用</th></tr></thead><tbody><tr><td>app.js</td><td>是</td><td>小程序逻辑</td></tr><tr><td>app.json</td><td>是</td><td>小程序公共配置</td></tr><tr><td>app.wxss</td><td>否</td><td>小程序公共样式表</td></tr></tbody></table><img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" class=""><p>一个小程序的页面由四个文件组成：</p><table><thead><tr><th>文件类型</th><th>必需</th><th>作用</th></tr></thead><tbody><tr><td>js</td><td>是</td><td>页面逻辑</td></tr><tr><td>wxml</td><td>是</td><td>页面结构</td></tr><tr><td>json</td><td>否</td><td>页面配置</td></tr><tr><td>wxss</td><td>否</td><td>页面样式表</td></tr></tbody></table><h6 id="导入小程序代码">导入小程序代码</h6><h4 id="微信登录-2">微信登录</h4><h5 id="微信登录流程">微信登录流程</h5><p>帮助文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">开放能力 / 用户信息 / 小程序登录 (qq.com)</a></p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" class=""><h5 id="需求分析与设计">需求分析与设计</h5><h5 id="代码开发-3">代码开发</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserLoginVO <span class="title function_">login</span><span class="params">(UserLoginDTO userLoginDTO)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过前端code获得用户的openid（微信用户唯一标识）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> getOpenid(userLoginDTO.getCode());</span><br><span class="line">    <span class="comment">// 验证openid是否为空，为空则传递参数code有误，登录失败</span></span><br><span class="line">    <span class="keyword">if</span> (openid == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LoginFailedException</span>(MessageConstant.LOGIN_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取数据库中的该user信息</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.getByOpenId(openid);</span><br><span class="line">    <span class="comment">// 如果user为空，则该用户为新用户，为其注册</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        user = User.builder().openid(openid).createTime(LocalDateTime.now()).build();</span><br><span class="line">        save(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成jwt令牌</span></span><br><span class="line">    Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    claims.put(JwtClaimsConstant.USER_ID, user.getId());</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtil.createJWT(jwtProperties.getUserSecretKey(), jwtProperties.getUserTtl(), claims);</span><br><span class="line">    <span class="comment">// 返回UserLoginVO对象</span></span><br><span class="line">    <span class="keyword">return</span> UserLoginVO.builder().id(user.getId()).openid(user.getOpenid()).token(token).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getOpenid</span><span class="params">(String code)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过前端code获得用户的openid（微信用户唯一标识）</span></span><br><span class="line">    HashMap&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    params.put(<span class="string">&quot;appid&quot;</span>, weChatProperties.getAppid());</span><br><span class="line">    params.put(<span class="string">&quot;secret&quot;</span>, weChatProperties.getSecret());</span><br><span class="line">    params.put(<span class="string">&quot;js_code&quot;</span>, code);</span><br><span class="line">    params.put(<span class="string">&quot;grant_type&quot;</span>, <span class="string">&quot;authorization_code&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> HttpClientUtil.doGet(LOGIN_URL, params);</span><br><span class="line"></span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSON.parseObject(response);</span><br><span class="line">    <span class="keyword">return</span> jsonObject.getString(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="功能测试-3">功能测试</h5><h4 id="导入商品浏览功能模块">导入商品浏览功能模块</h4><h5 id="需求分析与设计-2">需求分析与设计</h5><h6 id="接口设计">接口设计</h6><ul><li>查询分类</li><li>根据分类 id 查询菜品（关联口味数据）</li><li>根据分类 id 查询套餐</li><li>根据套餐 id 查询包含的菜品</li></ul><h5 id="代码开发-4">代码开发</h5><h5 id="功能测试-4">功能测试</h5><h3 id="缓存商品">缓存商品</h3><h4 id="缓存菜品">缓存菜品</h4><h5 id="问题说明">问题说明</h5><p>用户端小程序展示的菜品数据都是通过查询数据库来获得，如果短时间内有大量查询请求，则数据库访问压力过大，会造成查询响应慢，用户体验差。</p><h5 id="实现思路">实现思路</h5><p>通过 Redis 来缓存菜品数据，减少数据库查询操作（内存访问速度比磁盘 IO 访问速度快得多）</p><p>查询思路：</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E6%9F%A5%E8%AF%A2%E6%80%9D%E8%B7%AF.png" class=""><p>缓存逻辑分析：</p><ul><li>每个分类下的菜品缓存一份数据，即一个分类对应一个 key-value 键值对</li><li>数据库中菜品数据有变更时要清理缓存数据</li></ul><h5 id="代码开发-5">代码开发</h5><h6 id="查询时添加缓存">查询时添加缓存</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据分类id查询菜品&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;List&lt;DishVO&gt;&gt; <span class="title function_">list</span><span class="params">(Long categoryId)</span> &#123;</span><br><span class="line">    <span class="comment">// 构造key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;dish_&quot;</span> + categoryId;</span><br><span class="line">    <span class="comment">// 查询redis中是否存在缓存数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">list</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(key);</span><br><span class="line">    List&lt;DishVO&gt; data = JSON.parseArray(list, DishVO.class);</span><br><span class="line">    <span class="comment">// 存在缓存数据，直接返回给前端</span></span><br><span class="line">    <span class="keyword">if</span> (data != <span class="literal">null</span> &amp;&amp; !data.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.success(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在缓存数据，则查询数据库，并添加到redis中</span></span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dish</span>();</span><br><span class="line">    dish.setCategoryId(categoryId);</span><br><span class="line">    dish.setStatus(StatusConstant.ENABLE);<span class="comment">//查询起售中的菜品</span></span><br><span class="line"></span><br><span class="line">    data = dishService.listWithFlavor(dish);</span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    redisTemplate.opsForValue().set(key, JSON.toJSONString(data));</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.success(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="修改时清理缓存">修改时清理缓存</h6><p>修改管理端接口 DishController 的相关方法，加入清理缓存逻辑，需要改造的方法：</p><ul><li>新增菜品</li><li>修改菜品</li><li>删除菜品</li><li>起售、停售菜品</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清理redis缓存方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cleanUpCache</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    <span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> redisTemplate.keys(pattern);</span><br><span class="line">    redisTemplate.delete(keys);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="功能测试-5">功能测试</h5><h4 id="缓存套餐">缓存套餐</h4><h5 id="SpringCache">SpringCache</h5><h6 id="介绍-4">介绍</h6><p>SpringCache 是一个框架，实现了基于==注解==的缓存功能，只需要简单地加一个注解，就能实现缓存功能</p><p>SpringCache 提供了一层抽象，底层可以切换不同的缓存实现，例如：</p><ul><li>EHCache</li><li>Caffeine</li><li>Redis</li></ul><p>Maven 坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该框架会根据 maven 项目中导入的数据库来选择缓存实现，即如果项目中导入了 redis 的 Java 客户端，就无需其他配置，该框架会自动选择 redis 作为底层缓存实现。</p><h6 id="常用注解-2">常用注解</h6><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td><code>@EnableCaching</code></td><td>开启缓存注解功能，通常加在启动类上</td></tr><tr><td><code>@Cacheable</code></td><td>在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中</td></tr><tr><td><code>CachePut</code></td><td>将方法的返回值放到缓存中</td></tr><tr><td><code>CacheEvict</code></td><td>将一条或多条数据从缓存中删除</td></tr></tbody></table><h6 id="入门案例-3">入门案例</h6><p>案例一</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E6%A1%88%E4%BE%8B%E4%B8%80.png" class=""><ul><li>使用 spring 的 el 表达式来动态地生成插入 redis 的 key 的名称</li><li>使用 <code>@CachePut</code> 注解来将方法的返回值保存到 redis 中</li><li>执行顺序：先执行方法，方法执行完之后再执行注解操作缓存</li></ul><p>案例二</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E6%A1%88%E4%BE%8B%E4%BA%8C.png" class=""><ul><li><code>@Cacheable</code> 注解的属性同上</li><li>使用该注解来完成在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中</li><li>该注解中 el 表达式不能用 result 关键字</li></ul><p>案例三</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E6%A1%88%E4%BE%8B%E4%B8%89.png" class=""><ul><li><code>@CacheEvict</code> 注解的属性也同上</li><li>执行顺序：先执行方法，方法执行完之后再执行注解</li><li>删除单条缓存数据</li></ul><p>案例四</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E6%A1%88%E4%BE%8B%E5%9B%9B.png" class=""><ul><li>删除全部缓存数据</li><li>不使用 key 属性来指定单个 key，使用 <code>allEntries = true</code> 来指定全部前缀为 userCache 的 key</li></ul><h5 id="实现思路-2">实现思路</h5><p>具体的实现思路如下：</p><ul><li>导入 SpringCache 和 Redis 的相关 maven 坐标</li><li>在启动类上加入 <code>@EnableCaching</code> 注解</li><li>在用户端接口 SetmealController 的 list 方法上加入 <code>@Cacheable</code> 注解</li><li>在管理端 SetmealController 的 sava、delete、update、startOrStop 等方法上加入 <code>@CacheEvict</code> 注解</li></ul><h5 id="代码开发-6">代码开发</h5><h5 id="功能测试-6">功能测试</h5><h3 id="购物车">购物车</h3><h4 id="添加到购物车">添加到购物车</h4><h5 id="需求分析和设计-2">需求分析和设计</h5><p>接口设计：</p><ul><li>请求方式：POST</li><li>请求路径：/user/shoppingCart/add</li><li>请求参数：套餐 id、菜品 id、口味</li><li>返回结果：code、data、msg</li></ul><h5 id="代码开发-7">代码开发</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToCart</span><span class="params">(ShoppingCartDTO shoppingCartDTO)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前加入购物车的商品是否已存在，已存在的话更新商品的数量+1</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">setmealId</span> <span class="operator">=</span> shoppingCartDTO.getSetmealId();</span><br><span class="line">    <span class="type">Long</span> <span class="variable">dishId</span> <span class="operator">=</span> shoppingCartDTO.getDishId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">dishFlavor</span> <span class="operator">=</span> shoppingCartDTO.getDishFlavor();</span><br><span class="line">    LambdaQueryWrapper&lt;ShoppingCart&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;ShoppingCart&gt;()</span><br><span class="line">        .eq(id != <span class="literal">null</span>, ShoppingCart::getUserId, id)</span><br><span class="line">        .eq(setmealId != <span class="literal">null</span>, ShoppingCart::getSetmealId, setmealId)</span><br><span class="line">        .eq(dishId != <span class="literal">null</span>, ShoppingCart::getDishId, dishId)</span><br><span class="line">        .eq(dishFlavor != <span class="literal">null</span>, ShoppingCart::getDishFlavor, dishFlavor);</span><br><span class="line">    List&lt;ShoppingCart&gt; list = list(wrapper);</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="literal">null</span> &amp;&amp; !list.isEmpty()) &#123;</span><br><span class="line">        LambdaUpdateWrapper&lt;ShoppingCart&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;ShoppingCart&gt;()</span><br><span class="line">            .eq(ShoppingCart::getId, list.get(<span class="number">0</span>).getId())</span><br><span class="line">            .set(ShoppingCart::getNumber, list.get(<span class="number">0</span>).getNumber() + <span class="number">1</span>);</span><br><span class="line">        update(updateWrapper);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前商品不存在，则插入到购物车表中，默认数量为1</span></span><br><span class="line">    <span class="type">ShoppingCart</span> <span class="variable">shoppingCart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppingCart</span>();</span><br><span class="line">    <span class="keyword">if</span> (setmealId != <span class="literal">null</span> &amp;&amp; dishId == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Setmeal</span> <span class="variable">setmeal</span> <span class="operator">=</span> setMealService.getById(setmealId);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> setmeal.getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">image</span> <span class="operator">=</span> setmeal.getImage();</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">price</span> <span class="operator">=</span> setmeal.getPrice();</span><br><span class="line">        shoppingCart = ShoppingCart.builder().userId(id).name(name).setmealId(setmealId)</span><br><span class="line">            .number(<span class="number">1</span>).amount(price).image(image).createTime(LocalDateTime.now()).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setmealId == <span class="literal">null</span> &amp;&amp; dishId != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> dishService.getById(dishId);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dish.getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">image</span> <span class="operator">=</span> dish.getImage();</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">price</span> <span class="operator">=</span> dish.getPrice();</span><br><span class="line">        shoppingCart = ShoppingCart.builder().userId(id).name(name).dishId(dishId)</span><br><span class="line">            .number(<span class="number">1</span>).amount(price).image(image).dishFlavor(dishFlavor).createTime(LocalDateTime.now()).build();</span><br><span class="line">    &#125;</span><br><span class="line">    save(shoppingCart);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="功能测试-7">功能测试</h5><h4 id="查看购物车">查看购物车</h4><h4 id="清空购物车">清空购物车</h4><h3 id="用户下单">用户下单</h3><h4 id="导入地址薄功能代码">导入地址薄功能代码</h4><h5 id="需求分析和设计-3">需求分析和设计</h5><p>业务功能</p><ul><li>查询地址列表</li><li>新增地址</li><li>修改地址</li><li>删除地址</li><li>设置默认地址</li><li>查询默认地址</li></ul><p>接口设计</p><ul><li>新增地址</li><li>查询当前登录用户的所有地址信息</li><li>查询默认地址</li><li>根据 id 修改地址</li><li>根据 id 删除地址</li><li>根据 id 查询地址</li><li>设置默认地址</li></ul><h5 id="导入代码">导入代码</h5><h5 id="功能测试-8">功能测试</h5><h4 id="用户下单-2">用户下单</h4><h5 id="需求分析与设计-3">需求分析与设计</h5><h6 id="用户下单业务说明：">用户下单业务说明：</h6><p>在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货</p><h6 id="用户下单后会产生订单相关数据，订单数据需要能够体现如下信息：">用户下单后会产生订单相关数据，订单数据需要能够体现如下信息：</h6><ul><li>买的哪些商品？每个商品的数量是多少（查询用户购物车获得）</li><li>订单总金额是多少？（程序计算得出）</li><li>收获地址是哪？（下单地址簿中查询）</li><li>哪个用户下的单？（下单地址簿中查询）</li><li>用户手机号是多少？（下单地址簿中查询）</li></ul><h6 id="用户点餐业务流程：">用户点餐业务流程：</h6><img src="/2025/03/02/Web-Development-Sky-Takeout/%E7%94%A8%E6%88%B7%E7%82%B9%E9%A4%90%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B.png" class=""><h6 id="接口分析：">接口分析：</h6><p>请求方式：POST</p><p>请求路径：/user/order/submit</p><p>参数：</p><ul><li>地址薄 id</li><li>配送状态（立即送出、选择送出时间）</li><li>打包费</li><li>总金额</li><li>（配送费固定为6元，本项目中不考虑了）</li><li>备注</li><li>餐具数量</li></ul><p>返回数据：</p><ul><li>用户下单时间（用于前端倒计时）</li><li>订单总金额</li><li>订单号</li><li>订单 id（用于支付时确定订单）</li></ul><p>数据库设计：</p><ul><li>订单表（存储订单基本信息）<ul><li>谁的订单？</li><li>送哪去？</li><li>打哪个电话联系？</li><li>多少钱？</li><li>什么时间下的单？</li><li>什么时间支付的？</li><li>订单的状态？</li><li>订单号是多少？</li></ul></li><li>订单明细表（存储订单菜品信息）<ul><li>当前明细属于哪个订单？</li><li>具体点的是什么商品？</li><li>这个商品点了几份？</li></ul></li></ul><h5 id="代码开发-8">代码开发</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> OrderSubmitVO <span class="title function_">submit</span><span class="params">(OrdersSubmitDTO ordersSubmitDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 各种业务异常</span></span><br><span class="line">        <span class="comment">// 地址薄为空</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">addressBookId</span> <span class="operator">=</span> ordersSubmitDTO.getAddressBookId();</span><br><span class="line">        <span class="type">AddressBook</span> <span class="variable">address</span> <span class="operator">=</span> addressBookMapper.getById(addressBookId);</span><br><span class="line">        <span class="keyword">if</span> (address == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderBusinessException</span>(MessageConstant.ADDRESS_BOOK_IS_NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 购物车数据为空</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line">        LambdaQueryWrapper&lt;ShoppingCart&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;ShoppingCart&gt;()</span><br><span class="line">                .eq(userId != <span class="literal">null</span>, ShoppingCart::getUserId, userId);</span><br><span class="line">        List&lt;ShoppingCart&gt; shoppingCarts = shoppingCartService.list(wrapper);</span><br><span class="line">        <span class="keyword">if</span> (shoppingCarts == <span class="literal">null</span> || shoppingCarts.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderBusinessException</span>(MessageConstant.SHOPPING_CART_IS_NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向订单表插入一条数据</span></span><br><span class="line">        <span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Orders</span>();</span><br><span class="line">        BeanUtils.copyProperties(ordersSubmitDTO, orders);</span><br><span class="line">        orders.setNumber(String.valueOf(System.currentTimeMillis()));</span><br><span class="line">        orders.setStatus(Orders.PENDING_PAYMENT);</span><br><span class="line">        orders.setUserId(userId);</span><br><span class="line">        orders.setOrderTime(LocalDateTime.now());</span><br><span class="line">        orders.setPayStatus(Orders.UN_PAID);</span><br><span class="line">        orders.setUserName(userService.getById(userId).getName());</span><br><span class="line">        orders.setPhone(address.getPhone());</span><br><span class="line">        orders.setAddress(address.getDetail());</span><br><span class="line">        orders.setConsignee(address.getConsignee());</span><br><span class="line"></span><br><span class="line">        save(orders);</span><br><span class="line">        <span class="comment">// 向订单明细表插入多条数据</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">ordersId</span> <span class="operator">=</span> orders.getId();</span><br><span class="line">        ArrayList&lt;OrderDetail&gt; orderDetails = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ShoppingCart shoppingCart : shoppingCarts) &#123;</span><br><span class="line">            <span class="type">OrderDetail</span> <span class="variable">orderDetail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderDetail</span>();</span><br><span class="line">            BeanUtils.copyProperties(shoppingCart, orderDetail);</span><br><span class="line">            orderDetail.setOrderId(ordersId);</span><br><span class="line">            orderDetails.add(orderDetail);</span><br><span class="line">        &#125;</span><br><span class="line">        orderDetailService.saveBatch(orderDetails);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空购物车</span></span><br><span class="line">        shoppingCartService.remove(wrapper);</span><br><span class="line">        <span class="comment">// 封装返回结果</span></span><br><span class="line">        <span class="keyword">return</span> OrderSubmitVO.builder().id(ordersId).orderAmount(ordersSubmitDTO</span><br><span class="line">                .getAmount()).orderNumber(orders.getNumber()).orderTime(orders.getOrderTime()).build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="功能测试-9">功能测试</h5><h3 id="订单支付和管理">订单支付和管理</h3><h4 id="微信支付介绍">微信支付介绍</h4><h5 id="微信支付产品：">微信支付产品：</h5><img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E4%BA%A7%E5%93%81.png" class=""><p>参考文档：<a href="https://pay.weixin.qq.com/static/product/product_index.shtml">https://pay.weixin.qq.com/static/product/product_index.shtml</a></p><h5 id="小程序微信支付接入流程：">小程序微信支付接入流程：</h5><img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B.png" class=""><h5 id="微信小程序支付时序图：">微信小程序支付时序图：</h5><img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E6%97%B6%E5%BA%8F%E5%9B%BE.png" class=""><h5 id="请求下单接口：">请求下单接口：</h5><ul><li>url：<a href="https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi">https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi</a></li><li>请求方式：POST</li><li>提交参数：<img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3%E6%8F%90%E4%BA%A4%E5%8F%82%E6%95%B0.png" class=""><ul><li>mchid：商户号</li><li>out_trade_no：订单号（自己定义的）</li><li>appid：小程序的 appid</li><li>description：描述</li><li>notify_url：回调地址，即调用成功后商户接收返回响应数据的地址</li><li>amount<ul><li>total：总金额</li><li>currency：货币</li></ul></li><li>payer<ul><li>openid：支付者的 openid</li></ul></li></ul></li></ul><h5 id="关键阶段：">关键阶段：</h5><ul><li>商户系统调用下单接口</li><li>小程序调用 <code>wx.requestPayment</code> 方法完成支付</li><li>商户系统获取到支付结果，更新订单状态</li></ul><h5 id="JSAPI-下单详细说明">JSAPI 下单详细说明</h5><p>接口文档：<a href="https://pay.weixin.qq.com/docs/merchant/apis/jsapi-payment/direct-jsons/jsapi-prepay.html">JSAPI下单 - JSAPI支付 | 微信支付商户文档中心 (qq.com)</a></p><p>请求参数：详见接口文档</p><p>请求示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">  https<span class="punctuation">:</span><span class="comment">//api.mch.weixin.qq.com/v3/pay/transactions/jsapi \</span></span><br><span class="line">  -H <span class="string">&quot;Authorization: WECHATPAY2-SHA256-RSA2048 mchid=\&quot;1900000001\&quot;,...&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;Accept: application/json&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -d &#x27;<span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;appid&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;wxd678efh567hg6787&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mchid&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1230000109&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Image形象店-深圳腾大-QQ公仔&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;out_trade_no&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1217752501201407033233368018&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;time_expire&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2018-06-08T10:34:56+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;attach&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;自定义数据说明&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;notify_url&quot;</span> <span class="punctuation">:</span> <span class="string">&quot; https://www.weixin.qq.com/wxpay/pay.php&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;goods_tag&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;WXG&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;support_fapiao&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;amount&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;total&quot;</span> <span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;currency&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CNY&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;payer&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;openid&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;oUpF8uMuAJO_M2pxb1Q9zNjWeS6o\t&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;detail&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;cost_price&quot;</span> <span class="punctuation">:</span> <span class="number">608800</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;invoice_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;微信123&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;goods_detail&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;merchant_goods_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1246464644&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;wechatpay_goods_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1001&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;goods_name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;iPhoneX 256G&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;quantity&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;unit_price&quot;</span> <span class="punctuation">:</span> <span class="number">528800</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;scene_info&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;payer_client_ip&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;14.23.150.211&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;device_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;013467007045764&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;store_info&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;0001&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;腾讯大厦分店&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;area_code&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;440305&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;address&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;广东省深圳市南山区科技中一道10000号&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;settle_info&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;profit_sharing&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span>&#x27;</span><br></pre></td></tr></table></figure><p>响应参数：</p><ul><li><p>200  OK</p></li><li><p><strong>prepay_id</strong> 必填 string(64)</p><blockquote><p><strong>【预支付交易会话标识】</strong> 预支付交易会话标识。用于后续接口调用中使用，该值有效期为2小时</p></blockquote></li></ul><p>响应示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;prepay_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;wx201410272009395522657a690389285100&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="微信小程序调起支付">微信小程序调起支付</h5><p>通过JSAPI下单接口获取到发起支付的必要参数prepay_id，然后使用微信支付提供的小程序方法调起小程序支付。</p><p>接口名称：wx.requestPayment</p><p>请求参数：</p><ul><li><p>**timeStamp **必填 string(32)</p><blockquote><p>时间戳，标准北京时间，时区为东八区，自1970年1月1日 0点0分0秒以来的秒数。注<br>意：部分系统取到的值为毫秒级，需要转换成秒(10位数字)。</p></blockquote></li><li><p><strong>nonceStr</strong> 必填 string(32)</p><blockquote><p>随机字符串，不长于32位。</p></blockquote></li><li><p>**package **必填 string(128)</p><blockquote><p>小程序下单接口返回的<code>prepay_id</code>参数值，提交格式如：<code>prepay_id=***</code></p></blockquote></li><li><p>**signType **必填 string(32)</p><blockquote><p>签名类型，默认为RSA，仅支持RSA。</p></blockquote></li><li><p>**paySign **必填 string(512)</p><blockquote><p>签名，使用字段<code>appid</code>、<code>timeStamp</code>、<code>nonceStr</code>、<code>package</code>计算得出的签名值<br>签名所使用的<code>appid</code>，为【小程序下单】时传入的<code>appid</code>，微信支付会校验下单与调<br>起支付所使用的<code>appid</code>的一致性。</p></blockquote></li></ul><p>请求示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">wx.requestPayment</span><br><span class="line">(</span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;timeStamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1414561699&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;nonceStr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5K8264ILTKCH16CQ2502SI8ZNMTM67VS&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;package&quot;</span><span class="punctuation">:</span> <span class="string">&quot;prepay_id=wx201410272009395522657a690389285100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;signType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RSA&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;paySign&quot;</span><span class="punctuation">:</span> <span class="string">&quot;oR9d8PuhnIc+YZ8cBHFCwfgpaK9gd7vaRvkYD7rthRAZ\/X+QBhcCYL21N7cHCTUxbQ+EAt6Uy+lwSN22f5YZvI45MLko8Pfso0jm46v5hqcVwrk6uddkGuT+Cdvu4WBqDzaDjnNa5UK3GfE1Wfl2gHxIIY5lLdUgWFts17D4WuolLLkiFZV+JSHMvH7eaLdT9N5GBovBwu5yYKUR7skR8Fu+LozcSqQixnlEZUfyE55feLOQTUYzLmR9pNtPbPsu6WVhbNHMS3Ss2+AehHvz+n64GDmXxbX++IOBvm2olHu3PsOUGRwhudhVf7UcGcunXt8cqNjKNqZLhLw4jq\/xDg==&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span>function(res)<span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fail&quot;</span><span class="punctuation">:</span>function(res)<span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;complete&quot;</span><span class="punctuation">:</span>function(res)<span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>回调结果：</p><table><thead><tr><th style="text-align:left">回调类型</th><th style="text-align:left">errMsg</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">success</td><td style="text-align:left">requestPayment:ok</td><td style="text-align:left">调用支付成功</td></tr><tr><td style="text-align:left">fail</td><td style="text-align:left">requestPayment:fail cancel</td><td style="text-align:left">用户取消支付</td></tr><tr><td style="text-align:left">fail</td><td style="text-align:left">requestPayment:fail (detail message)</td><td style="text-align:left">调用支付失败，其中 <code>detail message</code> 为后台返回的详细失败原因</td></tr></tbody></table><h4 id="微信支付准备工作">微信支付准备工作</h4><h6 id="调用过程如何保证数据安全？">调用过程如何保证数据安全？</h6><p>获取微信支付平台证书、商户私钥文件：</p><img src="/2025/03/02/Web-Development-Sky-Takeout/image-20240320202602246.png" class=""><h6 id="微信后台如何调用到商户系统？">微信后台如何调用到商户系统？</h6><p>获取临时域名：支付成功后微信服务通过该域名回调我们的程序</p><p>使用 cpolar 进行内网穿透获得临时公网 ip</p><h4 id="代码导入">代码导入</h4><h4 id="功能测试-10">功能测试</h4><h3 id="历史订单">历史订单</h3><h3 id="订单状态定时处理">订单状态定时处理</h3><p>待实现功能：</p><ul><li>支付超时订单自动取消</li><li>派送过久订单自动完成</li><li>来单提醒</li><li>催单提醒</li></ul><h4 id="Spring-Task">Spring Task</h4><h5 id="介绍-5">介绍</h5><p>Spring Task 是 Spring 框架提供的任务调度工具，可以按照约定的时间<strong>自动执行</strong>某个代码逻辑</p><p>应用场景：</p><ul><li>信用卡每月还款提醒</li><li>银行贷款每月还款提醒</li><li>火车票售票系统处理未支付订单</li><li>入职纪念日为用户发送通知</li><li>只要是需要定时处理的场景都可以使用</li></ul><h5 id="cron-表达式">cron 表达式</h5><p>cron 表达式其实就是一个字符串，通过 cron 表达式可以<strong>定义任务触发的时间</strong></p><p>构成规则：分为 6 或 7 个域，由空格分隔开，每个域代表一个含义</p><p>每个域的含义分别为：秒、分、时、日、月、周、年（可选）</p><p>例如：2022 年 10 月 12 日上午 9 点整对应的表达式为：“0 0 9 12 10 ? 2022”</p><p>日和周往往只能定义一个：因为日和星期几不一定能对应</p><p>cron 表达式在线生成器：<a href="https://cron.ciding.cc/">Cron - 在线Cron表达式生成器 (ciding.cc)</a></p><h5 id="入门案例-4">入门案例</h5><p>使用步骤：</p><ol><li>导入 maven 坐标 spring-context（已被包含在 <code>org.springframework.boot:spring-boot-starter</code> 中）</li><li>启动类添加注解 <code>@EnableScheduling</code> 开启任务调度</li><li>自定义定时任务类</li></ol><h4 id="订单状态定时处理-2">订单状态定时处理</h4><h5 id="需求分析-2">需求分析</h5><p>用户下单后可能存在的情况</p><ul><li>下单后未支付，订单一直处于 “待支付” 状态</li><li>用户收货后管理端未点击完成按钮，订单一直处于 “派送中” 状态</li></ul><p>解决办法为：</p><ul><li>通过定时任务每分钟检查一次是否存在支付超时的订单（下单后超过 15 分钟仍未支付则判定为支付超时订单），如果存在则修改订单状态为 “已取消”</li><li>通过定时任务每天凌晨 1 点检查一次是否存在 “派送中” 的订单，如果存在则修改订单状态为 “已完成”</li></ul><h5 id="代码开发-9">代码开发</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理超时订单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 每分钟触发一次</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0/1 * * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleTimeoutOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到全部超时未付款的订单的id</span></span><br><span class="line">    LambdaQueryWrapper&lt;Orders&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;Orders&gt;()</span><br><span class="line">        <span class="comment">// 超时的订单</span></span><br><span class="line">        .le(Orders::getOrderTime, LocalDateTime.now().minusMinutes(<span class="number">15</span>))</span><br><span class="line">        <span class="comment">// 未付款的订单</span></span><br><span class="line">        .eq(Orders::getStatus, Orders.PENDING_PAYMENT);</span><br><span class="line">    List&lt;Long&gt; ids = orderService.list(wrapper).stream().map(Orders::getId).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 更新这些订单的状态为已取消</span></span><br><span class="line">    orderService.cancelTimeoutOrder(ids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理派送中订单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 每天凌晨一点触发一次</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 1 * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDeliveryInProgressOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到全部处于派送中状态的订单的id</span></span><br><span class="line">    LambdaQueryWrapper&lt;Orders&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;Orders&gt;()</span><br><span class="line">        <span class="comment">// 派送中的订单</span></span><br><span class="line">        .eq(Orders::getStatus, Orders.DELIVERY_IN_PROGRESS)</span><br><span class="line">        <span class="comment">// 前一天的订单</span></span><br><span class="line">        .ge(Orders::getOrderTime, LocalDateTime.now().minusDays(<span class="number">1</span>));</span><br><span class="line">    List&lt;Long&gt; ids = orderService.list(wrapper).stream().map(Orders::getId).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 更新这些订单的状态为已完成</span></span><br><span class="line">    orderService.completeDeliveryInProgressOrder(ids);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="功能测试-11">功能测试</h5><h3 id="来单提醒和客户催单">来单提醒和客户催单</h3><h4 id="WebSocket">WebSocket</h4><h5 id="介绍-6">介绍</h5><p>WebSocket 是基于 TCP 的一种新的<strong>网络协议</strong>。它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建<strong>持久性</strong>的连接，并进行<strong>双向</strong>数据传输。</p><p>WebSocket 协议和 HTTP 协议的异同点：</p><img src="/2025/03/02/Web-Development-Sky-Takeout/WebSocket%E5%92%8CHttp.png" class=""><p>应用场景：</p><ul><li>视频弹幕</li><li>网页聊天</li><li>体育实况更新</li><li>股票基金报价实时更新</li></ul><h5 id="入门案例-5">入门案例</h5><p>实现步骤：</p><ul><li>直接使用 websocket.html 页面作为 WebSocket 客户端</li><li>导入 WebSocket 的 maven 坐标</li><li>导入 WebSocket 服务端组件 webSocketServer，用于和客户端通信</li><li>导入配置类 WebSocketConfiguration，注册 WebSocket 的服务端组件</li><li>导入定时任务类 WebSocketTask，定时向客户端推送数据</li></ul><h4 id="来单提醒">来单提醒</h4><h5 id="需求分析与设计-4">需求分析与设计</h5><p>用户下单并且支付成功后，需要第一时间通知外卖商家。通知的形式有如下两种：</p><ul><li>语音播报</li><li>弹出提示框</li></ul><p>设计：</p><ul><li>通过 WebSocket 实现管理端页面和服务端保持长连接</li><li>当客户支付后，调用 WebSocket 的相关 API 实现服务端向管理端页面推送消息</li><li>管理端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行响应的消息提示和语音播报</li><li>约定服务端发送给管理端浏览器的数据格式为 JSON，字段包括：type, orderId, content<ul><li>type 为消息类型，1 为来单提醒，2 为客户催单</li><li>orderId 为订单 Id</li><li>content 为消息内容</li></ul></li></ul><h5 id="代码开发-10">代码开发</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 来单提醒</span></span><br><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;type&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;orderId&quot;</span>, ordersDB.getId());</span><br><span class="line">map.put(<span class="string">&quot;content&quot;</span>, <span class="string">&quot;订单号：&quot;</span> + outTradeNo);</span><br><span class="line"><span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSON.toJSONString(map);</span><br><span class="line">webSocketServer.sendToAllClient(jsonString);</span><br></pre></td></tr></table></figure><h5 id="功能测试-12">功能测试</h5><h4 id="客户催单">客户催单</h4><h5 id="需求分析与设计-5">需求分析与设计</h5><p>用户在小程序点击催单按钮后，需要第一时间通知外卖商家。通知的形式有如下两种：</p><ul><li>语音播报</li><li>弹出提示框</li></ul><p>设计：</p><ul><li>通过 WebSocket 实现管理端页面和服务端保持长连接</li><li>当客户点击催单按钮后，调用 WebSocket 的相关 API 实现服务端向管理端页面推送消息</li><li>管理端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行响应的消息提示和语音播报</li><li>约定服务端发送给管理端浏览器的数据格式为 JSON，字段包括：type, orderId, content<ul><li>type 为消息类型，1 为来单提醒，2 为客户催单</li><li>orderId 为订单 Id</li><li>content 为消息内容</li></ul></li></ul><h5 id="代码开发-11">代码开发</h5><p>设计催单接口</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%82%AC%E5%8D%95%E6%8E%A5%E5%8F%A3.png" class=""><p>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remindOrder</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="keyword">if</span> (orders == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderBusinessException</span>(MessageConstant.ORDER_NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;type&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    map.put(<span class="string">&quot;orderId&quot;</span>, id);</span><br><span class="line">    map.put(<span class="string">&quot;content&quot;</span>, <span class="string">&quot;订单号：&quot;</span> + orders.getNumber());</span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSON.toJSONString(map);</span><br><span class="line"></span><br><span class="line">    webSocketServer.sendToAllClient(jsonString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="功能测试-13">功能测试</h5><h2 id="统计报表模块">统计报表模块</h2><h3 id="图形报表设计">图形报表设计</h3><h4 id="Apache-EChatrs">Apache EChatrs</h4><h5 id="介绍-7">介绍</h5><p>Apache ECharts 是一款基于 JavaScrpit 的数据可视化图表库，提供直观、生动、可交互、可个性化定制的数据可视化图表</p><p>官网：<a href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a></p><h5 id="入门案例-6">入门案例</h5><p>根据官方提供的快速入门案例：<a href="https://echarts.apache.org/handbook/zh/get-started/">https://echarts.apache.org/handbook/zh/get-started/</a></p><p>总结：使用 ECharts，重点在于研究当前图表所需的数据格式。通常是需要后端提供符合格式要求的动态数据，然后响应给前端来展示图表。</p><h4 id="营业额统计">营业额统计</h4><h5 id="需求分析与设计-6">需求分析与设计</h5><p>需求分析：</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.png" class=""><p>接口设计：</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1.png" class=""><h5 id="代码开发-12">代码开发</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> TurnoverReportVO <span class="title function_">turnoverReport</span><span class="params">(LocalDate begin, LocalDate end)</span> &#123;</span><br><span class="line">    <span class="comment">// 封装返回的list集合</span></span><br><span class="line">    ArrayList&lt;LocalDate&gt; times = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    times.add(begin);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">added</span> <span class="operator">=</span> begin.plusDays(count++);</span><br><span class="line">        <span class="keyword">if</span> (added.isAfter(end)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        times.add(added);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询在begin和end之间每天的营业额</span></span><br><span class="line">    ArrayList&lt;Double&gt; turnovers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (LocalDate time : times) &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> LocalDateTime.of(time, LocalTime.MIN);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> LocalDateTime.of(time, LocalTime.MAX);</span><br><span class="line">        <span class="type">Double</span> <span class="variable">turnover</span> <span class="operator">=</span> reportMapper.getTurnover(beginTime, endTime);</span><br><span class="line">        turnover = turnover == <span class="literal">null</span> ? <span class="number">0.0</span> : turnover;</span><br><span class="line">        turnovers.add(turnover);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装返回数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TurnoverReportVO</span>(StringUtils.join(times, <span class="string">&quot;,&quot;</span>), StringUtils.join(turnovers, <span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="功能测试-14">功能测试</h5><h4 id="用户统计">用户统计</h4><h5 id="需求分析与设计-7">需求分析与设计</h5><p>需求分析：</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E7%94%A8%E6%88%B7%E7%BB%9F%E8%AE%A1%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.png" class=""><p>接口设计：</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E7%94%A8%E6%88%B7%E7%BB%9F%E8%AE%A1%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1.png" class=""><h5 id="代码开发-13">代码开发</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserReportVO <span class="title function_">userReport</span><span class="params">(LocalDate begin, LocalDate end)</span> &#123;</span><br><span class="line">    <span class="comment">// 封装返回的list集合</span></span><br><span class="line">    ArrayList&lt;LocalDate&gt; times = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    times.add(begin);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">added</span> <span class="operator">=</span> begin.plusDays(count++);</span><br><span class="line">        <span class="keyword">if</span> (added.isAfter(end)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        times.add(added);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到每日用户总量和新增用户数量</span></span><br><span class="line">    ArrayList&lt;Integer&gt; newUserNums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; totalUserNums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (LocalDate time : times) &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> LocalDateTime.of(time, LocalTime.MIN);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> LocalDateTime.of(time, LocalTime.MAX);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">newUserNum</span> <span class="operator">=</span> reportMapper.newUserNum(beginTime, endTime);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">totalUserNum</span> <span class="operator">=</span> reportMapper.totalUserNum(endTime);</span><br><span class="line">        <span class="comment">// count不会返回null，只会返回0，所以不需要三元运算符判断</span></span><br><span class="line">        newUserNums.add(newUserNum);</span><br><span class="line">        totalUserNums.add(totalUserNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UserReportVO.builder()</span><br><span class="line">            .dateList(StringUtils.join(times, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">            .newUserList(StringUtils.join(newUserNums, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">            .totalUserList(StringUtils.join(totalUserNums, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="功能测试-15">功能测试</h5><h4 id="订单统计">订单统计</h4><h5 id="需求分析与设计-8">需求分析与设计</h5><p>需求分析：</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E8%AE%A2%E5%8D%95%E7%BB%9F%E8%AE%A1%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.png" class=""><p>接口设计：</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E8%AE%A2%E5%8D%95%E7%BB%9F%E8%AE%A1%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1.png" class=""><h5 id="代码开发-14">代码开发</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> OrderReportVO <span class="title function_">orderReport</span><span class="params">(LocalDate begin, LocalDate end)</span> &#123;</span><br><span class="line">    <span class="comment">// 封装返回的list集合</span></span><br><span class="line">    ArrayList&lt;LocalDate&gt; times = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    times.add(begin);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">added</span> <span class="operator">=</span> begin.plusDays(count++);</span><br><span class="line">        <span class="keyword">if</span> (added.isAfter(end)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        times.add(added);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询需要的订单数据</span></span><br><span class="line">    ArrayList&lt;Integer&gt; totalOrderNums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; validOrderNums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Integer totalNums;</span><br><span class="line">    Integer validNums;</span><br><span class="line">    <span class="keyword">for</span> (LocalDate time : times) &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> LocalDateTime.of(time, LocalTime.MIN);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> LocalDateTime.of(time, LocalTime.MAX);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">totalOrderNum</span> <span class="operator">=</span> reportMapper.totalOrderNum(beginTime, endTime);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">validOrderNum</span> <span class="operator">=</span> reportMapper.validOrderNum(beginTime, endTime);</span><br><span class="line">        totalOrderNums.add(totalOrderNum);</span><br><span class="line">        validOrderNums.add(validOrderNum);</span><br><span class="line">    &#125;</span><br><span class="line">    totalNums = totalOrderNums.stream().mapToInt(Integer::intValue).sum();</span><br><span class="line">    validNums = validOrderNums.stream().mapToInt(Integer::intValue).sum();</span><br><span class="line">    <span class="type">Double</span> <span class="variable">completionRate</span> <span class="operator">=</span> totalNums == <span class="number">0</span> ? <span class="number">0.0</span> : <span class="number">1.0</span> * validNums / totalNums;</span><br><span class="line">    <span class="keyword">return</span> OrderReportVO.builder()</span><br><span class="line">            .dateList(StringUtils.join(times, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">            .orderCountList(StringUtils.join(totalOrderNums, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">            .validOrderCountList(StringUtils.join(validOrderNums, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">            .totalOrderCount(totalNums)</span><br><span class="line">            .validOrderCount(validNums)</span><br><span class="line">            .orderCompletionRate(completionRate)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="功能测试-16">功能测试</h5><h4 id="销量排名-top10">销量排名 top10</h4><h5 id="需求分析与设计-9">需求分析与设计</h5><p>需求分析：</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E9%94%80%E9%87%8F%E6%8E%92%E5%90%8D%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.png" class=""><p>接口设计：</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E9%94%80%E9%87%8F%E6%8E%92%E5%90%8D%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1.png" class=""><h5 id="代码开发-15">代码开发</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SalesTop10ReportVO <span class="title function_">salesTop10</span><span class="params">(LocalDate begin, LocalDate end)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到该时间段内的销量前十的菜品</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> LocalDateTime.of(begin, LocalTime.MIN);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> LocalDateTime.of(end, LocalTime.MAX);</span><br><span class="line">    List&lt;GoodsSalesDTO&gt; data = reportMapper.salesTop10(beginTime, endTime);</span><br><span class="line">    List&lt;String&gt; names = data.stream().map(GoodsSalesDTO::getName).collect(Collectors.toList());</span><br><span class="line">    List&lt;Integer&gt; numbers = data.stream().map(GoodsSalesDTO::getNumber).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SalesTop10ReportVO.builder()</span><br><span class="line">            .nameList(StringUtils.join(names, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">            .numberList(StringUtils.join(numbers, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="功能测试-17">功能测试</h5><h4 id="工作台设计与实现">工作台设计与实现</h4><h5 id="需求分析与设计-10">需求分析与设计</h5><p>工作台是系统运营的数据看板，并提供快捷的操作入口，可以有效提高商家的效率</p><p>工作台展示的数据：</p><ul><li>今日数据</li><li>订单总览</li><li>菜品总览</li><li>套餐总览</li><li>订单信息</li></ul><p>接口设计：</p><ul><li>今日数据接口</li><li>订单总览接口</li><li>菜品总览接口</li><li>套餐总览接口</li><li>订单搜索接口（已完成）</li><li>各个状态订单数量接口（已完成）</li></ul><h5 id="代码导入-2">代码导入</h5><h5 id="功能测试-18">功能测试</h5><h3 id="Excel-报表统计">Excel 报表统计</h3><h4 id="Apache-POI">Apache POI</h4><h5 id="介绍-8">介绍</h5><p>Apache POI 是一个处理 Microsoft Office 各种文件格式的开源项目。简单来说，我们可以使用 POI 在 Java 程序中对 Microsoft Office 各种文件进行读写操作</p><p>一般情况下，POI 用于操作 Excel 文件。</p><p>应用场景：</p><ul><li>银行网银系统导出交易明细</li><li>各种业务系统导出 Excel 报表</li><li>批量导入业务数据</li></ul><h5 id="入门案例-7">入门案例</h5><ol><li><p>导入 maven 坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过 POI 来向 Excel 文件中写入内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过POI创建Excel文件并且写入文件内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//在内存中创建一个Excel文件</span></span><br><span class="line">    <span class="type">XSSFWorkbook</span> <span class="variable">excel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XSSFWorkbook</span>();</span><br><span class="line">    <span class="comment">//在Excel文件中创建一个Sheet页</span></span><br><span class="line">    <span class="type">XSSFSheet</span> <span class="variable">sheet</span> <span class="operator">=</span> excel.createSheet(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">    <span class="comment">//在Sheet中创建行对象,rownum编号从0开始</span></span><br><span class="line">    <span class="type">XSSFRow</span> <span class="variable">row</span> <span class="operator">=</span> sheet.createRow(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//创建单元格并且写入文件内容</span></span><br><span class="line">    row.createCell(<span class="number">1</span>).setCellValue(<span class="string">&quot;姓名&quot;</span>);</span><br><span class="line">    row.createCell(<span class="number">2</span>).setCellValue(<span class="string">&quot;城市&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个新行</span></span><br><span class="line">    row = sheet.createRow(<span class="number">2</span>);</span><br><span class="line">    row.createCell(<span class="number">1</span>).setCellValue(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    row.createCell(<span class="number">2</span>).setCellValue(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">    row = sheet.createRow(<span class="number">3</span>);</span><br><span class="line">    row.createCell(<span class="number">1</span>).setCellValue(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    row.createCell(<span class="number">2</span>).setCellValue(<span class="string">&quot;南京&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过输出流将内存中的Excel文件写入到磁盘</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\info.xlsx&quot;</span>));</span><br><span class="line">    excel.write(out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    out.close();</span><br><span class="line">    excel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过 POI 从 Excel 中读取数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过POI读取Excel文件中的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\info.xlsx&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取磁盘上已经存在的Excel文件</span></span><br><span class="line">    <span class="type">XSSFWorkbook</span> <span class="variable">excel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XSSFWorkbook</span>(in);</span><br><span class="line">    <span class="comment">//读取Excel文件中的第一个Sheet页</span></span><br><span class="line">    <span class="type">XSSFSheet</span> <span class="variable">sheet</span> <span class="operator">=</span> excel.getSheetAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Sheet中最后一行的行号</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRowNum</span> <span class="operator">=</span> sheet.getLastRowNum();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= lastRowNum ; i++) &#123;</span><br><span class="line">        <span class="comment">//获得某一行</span></span><br><span class="line">        <span class="type">XSSFRow</span> <span class="variable">row</span> <span class="operator">=</span> sheet.getRow(i);</span><br><span class="line">        <span class="comment">//获得单元格对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cellValue1</span> <span class="operator">=</span> row.getCell(<span class="number">1</span>).getStringCellValue();</span><br><span class="line">        <span class="type">String</span> <span class="variable">cellValue2</span> <span class="operator">=</span> row.getCell(<span class="number">2</span>).getStringCellValue();</span><br><span class="line">        System.out.println(cellValue1 + <span class="string">&quot; &quot;</span> + cellValue2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    in.close();</span><br><span class="line">    excel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="导出运营数据-Excel-报表">导出运营数据 Excel 报表</h4><h5 id="需求分析与设计-11">需求分析与设计</h5><p>需求分析</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%AF%BC%E5%87%BAexcel%E6%8A%A5%E8%A1%A8%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.png" class=""><p>接口设计：</p><img src="/2025/03/02/Web-Development-Sky-Takeout/%E5%AF%BC%E5%87%BAexcel%E6%8A%A5%E8%A1%A8%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1.png" class=""><h5 id="代码开发-16">代码开发</h5><p>实现步骤：</p><ol><li>设计表格的样板文件（使得在 Java 程序中不需要担心繁琐的表格样式设计，只专注于数据的填充）</li><li>查询近 30 天的运营数据</li><li>将查询到的数据写入到样板文件中</li><li>通过输出流将 Excel 文件输出到浏览器客户端供下载</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">export</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    InputStream in;</span><br><span class="line">    ServletOutputStream out;</span><br><span class="line">    XSSFWorkbook excel;</span><br><span class="line">    <span class="comment">// 1. 查询数据库，获得营业数据</span></span><br><span class="line">    <span class="comment">// 拿到概览数据</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">begin</span> <span class="operator">=</span> LocalDate.now().minusDays(<span class="number">30</span>);</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">end</span> <span class="operator">=</span> LocalDate.now().minusDays(<span class="number">1</span>);</span><br><span class="line">    <span class="type">BusinessDataVO</span> <span class="variable">businessDataVO</span> <span class="operator">=</span> workspaceService.getBusinessData(LocalDateTime.of(begin, LocalTime.MIN),</span><br><span class="line">            LocalDateTime.of(end, LocalTime.MAX));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 将营业数据通过POI写入到Excel样板中</span></span><br><span class="line">        in = <span class="built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;template/Excel-Template.xlsx&quot;</span>);</span><br><span class="line">        <span class="comment">// 基于模版文件创建一个workbook</span></span><br><span class="line">        excel = <span class="keyword">new</span> <span class="title class_">XSSFWorkbook</span>(in);</span><br><span class="line">        <span class="comment">//获取表格文件的Sheet页</span></span><br><span class="line">        <span class="type">XSSFSheet</span> <span class="variable">sheet</span> <span class="operator">=</span> excel.getSheet(<span class="string">&quot;Sheet1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充数据--时间</span></span><br><span class="line">        sheet.getRow(<span class="number">1</span>).getCell(<span class="number">1</span>).setCellValue(<span class="string">&quot;时间：&quot;</span> + begin + <span class="string">&quot;至&quot;</span> + end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得第4行</span></span><br><span class="line">        <span class="type">XSSFRow</span> <span class="variable">row</span> <span class="operator">=</span> sheet.getRow(<span class="number">3</span>);</span><br><span class="line">        row.getCell(<span class="number">2</span>).setCellValue(businessDataVO.getTurnover());</span><br><span class="line">        row.getCell(<span class="number">4</span>).setCellValue(businessDataVO.getOrderCompletionRate());</span><br><span class="line">        row.getCell(<span class="number">6</span>).setCellValue(businessDataVO.getNewUsers());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得第5行</span></span><br><span class="line">        row = sheet.getRow(<span class="number">4</span>);</span><br><span class="line">        row.getCell(<span class="number">2</span>).setCellValue(businessDataVO.getValidOrderCount());</span><br><span class="line">        row.getCell(<span class="number">4</span>).setCellValue(businessDataVO.getUnitPrice());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充明细数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> begin.plusDays(i);</span><br><span class="line">            <span class="comment">//查询某一天的营业数据</span></span><br><span class="line">            <span class="type">BusinessDataVO</span> <span class="variable">businessData</span> <span class="operator">=</span> workspaceService.getBusinessData(LocalDateTime.of(date, LocalTime.MIN), LocalDateTime.of(date, LocalTime.MAX));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获得某一行</span></span><br><span class="line">            row = sheet.getRow(<span class="number">7</span> + i);</span><br><span class="line">            row.getCell(<span class="number">1</span>).setCellValue(date.toString());</span><br><span class="line">            row.getCell(<span class="number">2</span>).setCellValue(businessData.getTurnover());</span><br><span class="line">            row.getCell(<span class="number">3</span>).setCellValue(businessData.getValidOrderCount());</span><br><span class="line">            row.getCell(<span class="number">4</span>).setCellValue(businessData.getOrderCompletionRate());</span><br><span class="line">            row.getCell(<span class="number">5</span>).setCellValue(businessData.getUnitPrice());</span><br><span class="line">            row.getCell(<span class="number">6</span>).setCellValue(businessData.getNewUsers());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 通过输出流将文件输出到客户端浏览器</span></span><br><span class="line">        out = response.getOutputStream();</span><br><span class="line">        excel.write(out);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 关闭资源</span></span><br><span class="line">        out.close();</span><br><span class="line">        excel.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="功能测试-19">功能测试</h5>]]></content>
      
      
      <categories>
          
          <category> Web Development Projects </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web Development </tag>
            
            <tag> Vue </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springfox Swagger</title>
      <link href="/2025/03/02/Springfox-Swagger/"/>
      <url>/2025/03/02/Springfox-Swagger/</url>
      
        <content type="html"><![CDATA[<h1>Springfox-Swagger</h1><h2 id="OpenAPI-与-Swagger">OpenAPI 与 Swagger</h2><h3 id="OpenAPI-简介">OpenAPI 简介</h3><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fswagger.io%2Fresources%2Fopen-api%2F">OpenAPI</a> 规范（OAS）为 RESTful API 定义了一个标准、与编程语言无关的 API 描述规范。它允许人类和计算机在不查看源码、文档或通过监控网络流量的情况下发现和理解服务。正确使用 OpenAPI ，可以让使用者在不需要或更少的理解服务实现逻辑情况下，更好更轻松的理解服务并与之交互。</p><p>完整的 OpenAPI 规范请看：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FOAI%2FOpenAPI-Specification%2Fblob%2Fmain%2Fversions%2F3.0.3.md">OpenAPI Specification</a></p><h3 id="Swagger-简介">Swagger 简介</h3><p>上述说到 OpenAPI 是一个规范，而 Swagger 也是一个规范，是 OpenAPI 规范的前身。Swagger 规范已于 2015 年捐赠给 Linux 基金会后改名为 OpenAPI，并定义最新的规范为 OpenAPI 3.0。所以现在的 Swagger 3.0 就是 OpenAPI 3.0。</p><p>通常我们所说的 Swagger 是指由 SmartBear Software 开发维护的一套用于实现 OpenAPI 规范的工具组合名称。Swagger 工具包含开源、免费和商用工具的组合，可用于整个 API 生命周期的开发。</p><p>关于这两者区别的详细信息可查看：<a href="https://link.juejin.cn?target=https%3A%2F%2Fsmartbear.com%2Fblog%2Fwhat-is-the-difference-between-swagger-and-openapi%2F">What Is the Difference Between Swagger and OpenAPI?</a></p><p>Swagger 官方：<a href="https://link.juejin.cn?target=https%3A%2F%2Fswagger.io%2F">swagger.io/</a></p><p><strong>一句话总结：OpenAPI 是一个规范，而 Swagger 是用于实现规范的工具组合。</strong></p><h2 id="SpringFox-与-SpringDoc">SpringFox 与 SpringDoc</h2><h3 id="SpringFox-简介">SpringFox 简介</h3><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fspringfox%2Fspringfox">SpringFox</a> 是 Spring 社区维护的一个项目（非官方），帮助使用者将 Swagger 2 集成到 Spring 中。常常用于 Spring 中帮助开发者生成文档，并可以轻松的在 Spring Boot 中使用。</p><p><strong>SpringFox 3.0 相关特性</strong></p><ul><li><p>支持 Spring 5，Webflux（仅请求映射支持，尚不支持功能端点）、Spring Integration</p></li><li><p>补充官方在 Spring Boot 的自动装配 <code>springfox-boot-starter</code>， 以后只需依赖一个 <code>dependency</code></p></li><li><p>与2.0相比更好的规范兼容性</p></li><li><p>支持OpenApi 3.0.3</p></li><li><p>轻依赖 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fspring-projects%2Fspring-plugin">spring-plugin</a>，<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fswagger-api%2Fswagger-core">swagger-core</a></p></li><li><p>现有的 Swagger 2 注解继续有效并丰富 OpenAPI 3.0 规范</p></li></ul><p>Github: <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fspringfox%2Fspringfox">github.com/springfox/s…</a></p><h3 id="SpringDoc-简介">SpringDoc 简介</h3><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fspringdoc.org%2F">SpringDoc</a> 也是 Spring 社区维护的一个项目（非官方），帮助使用者将 Swagger 3 集成到 Spring 中。</p><p>SpringDoc 支持 Swagger 页面 Oauth2 登录，相较于 SpringFox 而言，它的支撑时间更长，<strong>无疑是更好的选择</strong>。但是在国内发展较慢，很少看到太多有用的文档，百度出来的基本全是 Swagger 2 的内容，不过 <a href="https://link.juejin.cn?target=https%3A%2F%2Fspringdoc.org%2F">官网文档</a> 也给出了详细的使用说明。SpringDoc 使用了 Swagger 3（OpenAPI 3），但 Swagger 3 并未对 Swagger 2 的注解做兼容，不易迁移。</p><h4 id="从-SpringFox-迁移到-SpringDoc">从 SpringFox 迁移到 SpringDoc</h4><p>官网文档有介绍：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fspringdoc.org%2F%23migrating-from-springfox">Migrating from SpringFox</a></p><p>这里就不做过多介绍了。</p><p>以下将介绍使用 Springfox 来集成 Swagger 3 到 Spring Boot 中，并使用 Swagger 3 的注解。</p><h2 id="Spring-Boot-中使用-Springfox-整合-Swagger-3（OpenAPI-3）">Spring Boot 中使用 Springfox 整合 Swagger 3（OpenAPI 3）</h2><h3 id="Swagger-3（OpenAPI-3）常用注解介绍">Swagger 3（OpenAPI 3）常用注解介绍</h3><h4 id="1-OpenAPIDefinition">1. <code>@OpenAPIDefinition</code></h4><p>用于描述标签、文档信息、安全配置及外部文档，用在类上。</p><p>常用参数：</p><ul><li><code>info</code>：描述文档信息，详情见以下的 <code>@Info</code></li><li><code>tags</code>：定义标签列表，详情见以下的 <code>@Tag</code></li><li><code>servers</code>：目标服务器连接列表，详情见以下的 <code>@Server</code></li><li><code>externalDocs</code>：API 的一些外部文档，详情见以下的 <code>@ExternalDocumentation</code></li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OpenAPIDefinition(</span></span><br><span class="line"><span class="meta">    tags = &#123;</span></span><br><span class="line"><span class="meta">        @Tag(name = &quot;用户管理&quot;, description = &quot;用户模块操作&quot;),</span></span><br><span class="line"><span class="meta">        @Tag(name = &quot;角色管理&quot;, description = &quot;角色模块操作&quot;)</span></span><br><span class="line"><span class="meta">    &#125;,</span></span><br><span class="line"><span class="meta">    info = @Info(</span></span><br><span class="line"><span class="meta">        title = &quot;用户接口 API 文档&quot;,</span></span><br><span class="line"><span class="meta">        description = &quot;用户数据管理......&quot;,</span></span><br><span class="line"><span class="meta">        version = &quot;1.0.0&quot;,</span></span><br><span class="line"><span class="meta">        contact = @Contact(</span></span><br><span class="line"><span class="meta">            name = &quot;lanweihong&quot;,</span></span><br><span class="line"><span class="meta">            email = &quot;986310747@qq.com&quot;,</span></span><br><span class="line"><span class="meta">            url = &quot;https://www.lanweihong.com&quot;</span></span><br><span class="line"><span class="meta">        ),</span></span><br><span class="line"><span class="meta">        license = @License(</span></span><br><span class="line"><span class="meta">            name = &quot;Apache 2.0&quot;,</span></span><br><span class="line"><span class="meta">            url = &quot;http://www.apache.org/licenses/LICENSE-2.0.html&quot;</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">    ),</span></span><br><span class="line"><span class="meta">    servers = &#123;</span></span><br><span class="line"><span class="meta">        @Server(description = &quot;生产环境服务器&quot;, url = &quot;https://xxxx.com/api/v1&quot;),</span></span><br><span class="line"><span class="meta">        @Server(description = &quot;测试环境服务器&quot;, url = &quot;https://test.xxxx.com/api/v1&quot;)</span></span><br><span class="line"><span class="meta">    &#125;,</span></span><br><span class="line"><span class="meta">    security = @SecurityRequirement(name = &quot;Oauth2&quot;),</span></span><br><span class="line"><span class="meta">    externalDocs = @ExternalDocumentation(</span></span><br><span class="line"><span class="meta">        description = &quot;项目编译部署说明&quot;,</span></span><br><span class="line"><span class="meta">        url = &quot;http://localhost/deploy/README.md&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="2-Info">2. <code>@Info</code></h4><p>用于说明文档信息，用在 <code>@OpenAPIDefinition</code> 中。</p><p>常用参数：</p><ul><li><code>title</code>：应用标题</li><li><code>description</code>：应用描述</li><li><code>contact</code>：联系信息，详情看 <code>@Contact</code></li><li><code>license</code>：许可信息，详情看 <code>@License</code></li><li><code>version</code>：版本</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OpenAPIDefinition(</span></span><br><span class="line"><span class="meta">        info = @Info(</span></span><br><span class="line"><span class="meta">            title = &quot;用户接口 API 文档&quot;,</span></span><br><span class="line"><span class="meta">            description = &quot;用户数据管理......&quot;,</span></span><br><span class="line"><span class="meta">            version = &quot;1.0.0&quot;,</span></span><br><span class="line"><span class="meta">            contact = @Contact(name = &quot;lanweihong&quot;, email = &quot;986310747@qq.com&quot;, url = &quot;https://www.lanweihong.com&quot;),</span></span><br><span class="line"><span class="meta">            license = @License(name = &quot;Apache 2.0&quot;, url = &quot;http://www.apache.org/licenses/LICENSE-2.0.html&quot;)</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Tag">3. <code>@Tag</code></h4><p>对一个 operation 进行说明或定义的标签，用在类或方法上，也可以用在 <code>@OpenAPIDefinition</code> 中定义标签。</p><p>常用参数：</p><ul><li><code>name</code>：名称</li><li><code>description</code>：描述</li></ul><p>示例：</p><p>用在类上：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Tag(name = &quot;用户管理&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用在 <code>@OpenAPIDefinition</code> 中定义标签：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OpenAPIDefinition(</span></span><br><span class="line"><span class="meta">        tags = &#123;</span></span><br><span class="line"><span class="meta">            @Tag(name = &quot;用户管理&quot;, description = &quot;用户模块操作&quot;),</span></span><br><span class="line"><span class="meta">            @Tag(name = &quot;角色管理&quot;, description = &quot;角色模块操作&quot;)</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>值得注意的是，<code>@Tag</code> 在使用 Springfox 整合时，配置在 Controller 上使用并没有生效，在 Swagger UI 中没有看到相关显示。</strong>  这似乎是个 BUG，相关 issues： <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fspringfox%2Fspringfox%2Fissues%2F3668">@Tag annotation not work as expected on the Controller class.</a> 。</p><p><strong>目前还未修复，解决方法是使用 2.X 版本的注解替代：<code>@Api(tags = &quot;用户管理&quot;)</code> 。</strong></p><p>这个问题在 Springdoc 中不存在，通过 Springdoc 来生成 API 文档时，<code>@Tag</code> 使用正常，在 Swagger UI 中正常显示</p><h4 id="4-Contact">4. <code>@Contact</code></h4><p>用于描述联系人信息，用在 <code>@Info</code> 中。</p><p>常用参数：</p><ul><li><code>name</code>：唯一名称（个人/组织）</li><li><code>url</code>：指向联系人信息的 URL</li><li><code>email</code>：邮箱</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OpenAPIDefinition(</span></span><br><span class="line"><span class="meta">    info = @Info(</span></span><br><span class="line"><span class="meta">        contact = @Contact(</span></span><br><span class="line"><span class="meta">                name = &quot;Li.chen&quot;, </span></span><br><span class="line"><span class="meta">                email = &quot;mail&quot;, </span></span><br><span class="line"><span class="meta">                url = &quot;www&quot;</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-License">5. <code>@License</code></h4><p>用于描述许可证信息，用在 <code>@Info</code> 中。</p><p>常用参数：</p><ul><li><code>name</code>：许可证名称</li><li><code>url</code>：指向许可证的 URL</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OpenAPIDefinition(</span></span><br><span class="line"><span class="meta">    servers = &#123;</span></span><br><span class="line"><span class="meta">        @Server(description = &quot;生产环境服务器&quot;, url = &quot;https://xxxx.com/api/v1&quot;),</span></span><br><span class="line"><span class="meta">        @Server(description = &quot;测试环境服务器&quot;, url = &quot;https://test.xxxx.com/api/v1&quot;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-Server">6. <code>Server</code></h4><p>用于配置目标主机，用在 <code>@OpenAPIDefinition</code> 中。</p><p>常用参数：</p><ul><li><code>url</code>：主机地址</li><li><code>description</code>：主机描述</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OpenAPIDefinition(</span></span><br><span class="line"><span class="meta">    servers = &#123;</span></span><br><span class="line"><span class="meta">        @Server(description = &quot;生产环境服务器&quot;, url = &quot;https://xxxx.com/api/v1&quot;),</span></span><br><span class="line"><span class="meta">        @Server(description = &quot;测试环境服务器&quot;, url = &quot;https://test.xxxx.com/api/v1&quot;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-Operation">7. <code>@Operation</code></h4><p>用于说明方法用途，用在方法上。</p><p>参数：</p><ul><li><code>summary</code>：方法概要，方法的一个简单介绍，建议 120 个字符内</li><li><code>description</code>：方法描述，一般是很长的内容</li><li><code>hidden</code>：是否隐藏</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Operation(summary = &quot;查询用户列表&quot;, description = &quot;返回所有用户数据&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUseList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-Parameter">8. <code>@Parameter</code></h4><p>用于说明方法参数，用在方法参数上。</p><p>参数：</p><ul><li><code>name</code>：指定的参数名</li><li><code>in</code>：参数位置，可选 <code>query</code>、<code>header</code>、<code>path</code> 或 <code>cookie</code>，默认为空，表示忽略</li><li><code>description</code>：参数描述</li><li><code>required</code>：是否必填，默认为 <code>false</code></li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Operation(summary = &quot;删除用户&quot;)</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/users/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JsonResult&lt;UserVO&gt; <span class="title function_">deleteUserByName</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Parameter(name = &quot;username&quot;, in = ParameterIn.PATH, description = &quot;用户名&quot;, required = true)</span> </span></span><br><span class="line"><span class="params">        <span class="meta">@PathVariable(&quot;username&quot;)</span> String userName</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="keyword">return</span> JsonResult.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-ApiResponse">9. <code>@ApiResponse</code></h4><p>用于说明一个响应信息，用在 <code>@ApiResponses</code> 中。</p><p>参数：</p><ul><li><code>responseCode</code>：HTTP 响应码</li><li><code>description</code>：描述</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Operation(summary = &quot;通过用户名查询用户&quot;, description = &quot;根据用户名查询用户详细信息&quot;)</span></span><br><span class="line"><span class="meta">@ApiResponses(value = &#123;</span></span><br><span class="line"><span class="meta">        @ApiResponse(responseCode = &quot;200&quot;, description = &quot;请求成功&quot;),</span></span><br><span class="line"><span class="meta">        @ApiResponse(responseCode = &quot;404&quot;, description = &quot;用户不存在&quot;, content = @Content)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JsonResult&lt;UserVO&gt; <span class="title function_">getUserByName</span><span class="params">(<span class="meta">@Parameter(description = &quot;用户名&quot;, required = true)</span> <span class="meta">@PathVariable(&quot;username&quot;)</span> String userName)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="keyword">return</span> JsonResult.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-ApiResponses">10. <code>@ApiResponses</code></h4><p>用于说明一组响应信息，比如一个请求可能返回多种响应情况，比如成功信息（200），也有可能抛参数异常（400），用在方法上。</p><p>参数：</p><ul><li><code>value</code>：<code>@ApiResponse</code> 数组</li></ul><p>示例参考以上的 <code>@ApiResponse</code>。</p><h4 id="11-Schema">11. <code>@Schema</code></h4><p>用于描述数据对象信息或数据对象属性，比如各种 POJO 类及属性，用在类或类属性上。</p><p>参数：</p><ul><li><code>name</code>：属性名称</li><li><code>description</code>：属性描述</li><li><code>required</code>：是否必须</li><li><code>minLength</code>：字符最小长度</li><li><code>maxLength</code>：字符最大长度</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Schema(description = &quot;用户实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserVO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;用户名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter And Setter ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>值得注意的是，当使用 Springfox 整合时， <code>@Schema</code> 配置在类上时在 Swagger UI 中并未生成其配置的信息，但是配置在类属性上却是正常的。配置在类上时可使用 <code>@ApiModel(description = &quot;用户参数对象&quot;)</code> 来替代。</strong></p><p>这个问题在使用 Springdoc 整合时不存在，在 Springdox 整合使用时，<code>@Schema</code> 配置在类和属性上均正常。</p><h4 id="12-Hidden">12. <code>@Hidden</code></h4><p>用于隐藏资源、类或属性，用在类、方法或属性上。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/roles&quot;)</span></span><br><span class="line"><span class="comment">// 隐藏整个 RoleController</span></span><br><span class="line"><span class="meta">@Hidden</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult&lt;String&gt; <span class="title function_">queryRoleList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JsonResult.ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般常用的也就这几个注解，若想要了解更多的注解，请参阅 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FOAI%2FOpenAPI-Specification%2Fblob%2Fmain%2Fversions%2F3.0.3.md">OpenAPI Specification</a> 。</p><p><strong>以下使用教程使用 Springfox 整合，可能对新注解支持不是特别好，有些注解添加了也不生效，因此以下配置中的代码并非全用到新注解。所以，我还是推荐使用 Springdoc 来整合生成文档。</strong></p><h3 id="整合-Swagger-3（OpenAPI-3）">整合 Swagger 3（OpenAPI 3）</h3><h4 id="添加依赖">添加依赖</h4><p>编辑 <code>pom.xml</code>，添加依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="添加-Swagger-配置类">添加 Swagger 配置类</h4><ol><li>添加 Swagger 属性配置类，用于封装 Swagger 配置参数：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.swagger&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean enable;</span><br><span class="line">    <span class="keyword">private</span> String groupName;</span><br><span class="line">    <span class="keyword">private</span> String basePackage;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> String contactName;</span><br><span class="line">    <span class="keyword">private</span> String contactEmail;</span><br><span class="line">    <span class="keyword">private</span> String contactUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>添加 Swagger 配置类，添加注解 <code>@EnableOpenApi</code>：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableOpenApi</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(value = &#123;SwaggerProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    SwaggerProperties swaggerProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSwaggerProperties</span><span class="params">(SwaggerProperties swaggerProperties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.swaggerProperties = swaggerProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * API</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">adminApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// OAS_30：区别于 V2，（OpenAPI Specification 的简称 OAS）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(</span><br><span class="line">                <span class="comment">// 使用 OpenAPI 3.0</span></span><br><span class="line">                DocumentationType.OAS_30)</span><br><span class="line">                .enable(swaggerProperties.getEnable())</span><br><span class="line">                <span class="comment">// API 信息</span></span><br><span class="line">                .apiInfo(getAdminApiInfo())</span><br><span class="line">                <span class="comment">// API 分组</span></span><br><span class="line">                .groupName(swaggerProperties.getGroupName())</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">// 对某个包的接口进行监听</span></span><br><span class="line">     .apis(RequestHandlerSelectors.basePackage(swaggerProperties.getBasePackage()))</span><br><span class="line">                <span class="comment">// 监听所有接口</span></span><br><span class="line">                <span class="comment">// .apis(RequestHandlerSelectors.any())</span></span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * API 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">getAdminApiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                <span class="comment">// 文档标题</span></span><br><span class="line">                .title(swaggerProperties.getTitle())</span><br><span class="line">                <span class="comment">// 文档描述</span></span><br><span class="line">                .description(swaggerProperties.getDescription())</span><br><span class="line">                <span class="comment">// 联系人信息</span></span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(swaggerProperties.getContactName(), swaggerProperties.getContactUrl(), swaggerProperties.getContactEmail()))</span><br><span class="line">                <span class="comment">// 文档版本</span></span><br><span class="line">                .version(swaggerProperties.getVersion())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-Swagger-3">使用 Swagger 3</h4><ol><li>添加 Controller：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="comment">// @Tag 注解不生效，似乎是 BUG，相关 issues：https://github.com/springfox/springfox/issues/3668，因此这里使用 2.X 的注解 @Api</span></span><br><span class="line"><span class="comment">// @Tag(name = &quot;用户管理&quot;, description = &quot;用户数据增删改查&quot;)</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;用户管理&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;查询用户列表&quot;, description = &quot;返回所有用户数据&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult&lt;List&lt;UserVO&gt;&gt; <span class="title function_">getUserList</span><span class="params">(<span class="meta">@Parameter(description = &quot;用户名&quot;)</span> <span class="meta">@RequestParam(value = &quot;username&quot;, required = false)</span> String userName)</span> &#123;</span><br><span class="line">        List&lt;UserVO&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">UserVO</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;zhangsan@lanweihong.com&quot;</span>));</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">UserVO</span>(<span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;lisi@lanweihong.com&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> JsonResult.ok(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;通过用户名查询用户&quot;, description = &quot;根据用户名查询用户详细信息&quot;)</span></span><br><span class="line">    <span class="meta">@ApiResponses(value = &#123;</span></span><br><span class="line"><span class="meta">            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;请求成功&quot;),</span></span><br><span class="line"><span class="meta">            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;用户不存在&quot;, content = @Content)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult&lt;UserVO&gt; <span class="title function_">getUserByName</span><span class="params">(<span class="meta">@Parameter(description = &quot;用户名&quot;, required = true)</span> <span class="meta">@PathVariable(&quot;username&quot;)</span> String userName)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> JsonResult.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;新增用户&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult&lt;UserVO&gt; <span class="title function_">addUser</span><span class="params">(<span class="meta">@Parameter(required = true)</span> <span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserParam param)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> JsonResult.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;修改用户&quot;)</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult&lt;UserVO&gt; <span class="title function_">updateUser</span><span class="params">(<span class="meta">@Parameter(description = &quot;用户参数&quot;, required = true)</span> <span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserParam param)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> JsonResult.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;删除用户&quot;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult&lt;UserVO&gt; <span class="title function_">deleteUserByName</span><span class="params">(<span class="meta">@Parameter(name = &quot;username&quot;, in = ParameterIn.PATH, description = &quot;用户名&quot;, required = true)</span> <span class="meta">@PathVariable(&quot;username&quot;)</span> String userName)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> JsonResult.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Hidden</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult&lt;UserVO&gt; <span class="title function_">testAddUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserParam userParam)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">return</span> JsonResult.ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加 VO：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="comment">// @Schema 注解用在类上不生效，使用 @ApiModel 替代</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;用户实体&quot;)</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserVO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserVO</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserVO</span><span class="params">(String userName, String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(name = &quot;用户名&quot;, description = &quot;用户名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>编辑项目 <code>application.yml</code>，添加以下参数：</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">yml复制代码#</span> <span class="string">自定义</span> <span class="string">Swagger</span> <span class="string">配置</span></span><br><span class="line">    <span class="attr">spring:</span></span><br><span class="line">    <span class="attr">swagger:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">groupName:</span> <span class="string">前端</span></span><br><span class="line">    <span class="attr">basePackage:</span> <span class="string">com.lanweihong.springfox.swagger</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">前端</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">开发文档</span></span><br><span class="line">    <span class="attr">contactName:</span> <span class="string">lanweihong</span></span><br><span class="line">    <span class="attr">contactEmail:</span> <span class="number">986310747</span><span class="string">@qq.com</span></span><br><span class="line">    <span class="attr">contactUrl:</span> <span class="string">blog.lanweihong.com</span></span><br></pre></td></tr></table></figure><ol start="4"><li>项目中如果使用了 Spring Security 的，要添加以下配置放行 Swagger UI 的相关资源：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java复制代码<span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/v3/api-docs&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/v3/api-docs/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/swagger-resources/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/swagger-ui/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>启动项目进行测试。</li></ol><p>启动项目，浏览器访问：<a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A8080%2Fswagger-ui%2F">http://localhost:8080/swagger-ui/</a> （<strong>注意：Swagger 2.X 版本访问地址是 <a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A8080%2Fswagger-ui.html">http://localhost:8080/swagger-ui.html</a>，这和 3.0 不一样。</strong> ），可看到 Swagger UI 界面.</p><p>至此，Spring Boot 中使用 SpringFox 整合 Swagger 3 的使用已完成。</p><blockquote><p>作者：Ankou<br>链接：<a href="https://juejin.cn/post/6992149946988232734">https://juejin.cn/post/6992149946988232734</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>另附参考文档：<a href="https://blog.csdn.net/wangzhihao1994/article/details/108408420">Spring Boot 整合 springfox-swagger 3.0.0_springfox-boot-starter 3.0.0 匹配 springboot 哪个版本-CSDN博客</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Web Server Framework </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Database and SQL: Basic Concepts and Usage</title>
      <link href="/2025/03/02/Database-and-SQL-Basic-Concepts-and-Usage/"/>
      <url>/2025/03/02/Database-and-SQL-Basic-Concepts-and-Usage/</url>
      
        <content type="html"><![CDATA[<h1>MySQL</h1><h2 id="MySQL概述">MySQL概述</h2><h3 id="相关概念">相关概念</h3><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">全称</th><th style="text-align:center">简称</th></tr></thead><tbody><tr><td style="text-align:center">数据库</td><td style="text-align:center">存储数据的仓库，数据是有组织的进行存储</td><td style="text-align:center">DataBase(DB)</td></tr><tr><td style="text-align:center">数据库管理系统</td><td style="text-align:center">操纵和管理数据库的大型软件</td><td style="text-align:center">DataBase Management System(DBMS)</td></tr><tr><td style="text-align:center">SQL</td><td style="text-align:center">操作关系型数据库的编程语言，定义了一套操作关系型数据库统一<strong>标准</strong></td><td style="text-align:center">Structured Query Language(SQL)</td></tr></tbody></table><h3 id="数据模型">数据模型</h3><h4 id="关系型数据库-RDBMS">关系型数据库(RDBMS)</h4><p>概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库</p><p>特点：</p><ol><li>使用表存储数据，格式统一，便于维护</li><li>使用SQL语言操作，标准统一，使用方便</li></ol><h4 id="数据模型-2">数据模型</h4><p>MySQL模型如下：</p><img src="/2025/03/02/Database-and-SQL-Basic-Concepts-and-Usage/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png" class=""><p>客户端通过DBMS操作数据库，数据库中有多张表，如此串联操作。</p><hr><h2 id="SQL">SQL</h2><h3 id="SQL通用语法">SQL通用语法</h3><ol><li>SQL语句可以单行或多行书写，以分号结尾</li><li>SQL语句可以使用空格/缩进来增强语句的可读性</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写</li><li>注释：<ul><li>单行注释： – 注释内容 或 # 注释内容(MySQL特有)</li><li>多行注释： /* 注释内容 */</li></ul></li></ol><h3 id="SQL分类">SQL分类</h3><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">全称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">DDL</td><td style="text-align:center">Data Definition Language</td><td style="text-align:center">数据定义语言，用来定义数据库对象（数据库、表、字段）</td></tr><tr><td style="text-align:center">DML</td><td style="text-align:center">Data Manipulation Language</td><td style="text-align:center">数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td style="text-align:center">DQL</td><td style="text-align:center">Data Query Language</td><td style="text-align:center">数据查询语言，用来查询数据库中表的记录</td></tr><tr><td style="text-align:center">DCL</td><td style="text-align:center">Data Control Language</td><td style="text-align:center">数据控制语言，用来创建数据库用户，控制数据库的访问权限</td></tr></tbody></table><h3 id="DDL-数据定义语言">DDL - 数据定义语言</h3><h4 id="使用DDL操作数据库">使用DDL操作数据库</h4><p><strong>查询</strong>：</p><ol><li>查询所有数据库： <code>SHOW DATABASES;</code></li><li>查询当前数据库： <code>SELECT DATABASE();</code></li></ol><p><strong>创建</strong>：</p><figure class="highlight plaintext"><figcaption><span>DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]```;</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**删除**：</span><br><span class="line"></span><br><span class="line">```DROP DATABASE [IF EXISTS] 数据库名;```</span><br><span class="line"></span><br><span class="line">**使用**：</span><br><span class="line"></span><br><span class="line">```USE 数据库名;```</span><br><span class="line"></span><br><span class="line">#### 使用DDL操作数据库中的表</span><br><span class="line"></span><br><span class="line">**查询**：</span><br><span class="line"></span><br><span class="line">1. 查询当前数据库所有表：```SHOW TABLES;```</span><br><span class="line">2. 查询表结构： ```DESC 表名;```</span><br><span class="line">3. 查询指定表的建表语句： ```SHOW CREATE TABLE 表名;```</span><br><span class="line"></span><br><span class="line">**创建**：</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">CREATE TABLE 表名(</span><br><span class="line">    字段1 字段1类型[COMMENT 字段1注释],</span><br><span class="line">    字段2 字段2类型[COMMENT 字段2注释],</span><br><span class="line">    字段3 字段3类型[COMMENT 字段3注释],</span><br><span class="line">    ...</span><br><span class="line">    字段n 字段n类型[COMMENT 字段n注释]</span><br><span class="line">)[COMMENT 表注释];</span><br></pre></td></tr></table></figure><p><strong>修改</strong>：</p><ol><li>添加字段： <code>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</code></li><li>修改字段：<ul><li>修改数据类型：<code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</code></li><li>修改字段名和数据类型：<code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</code></li></ul></li><li>删除字段：<code>ALTER TABLE 表名 DROP 字段名;</code></li><li>修改表名：<code>ALTER TABLE 表名 RENAME TO 新表名;</code></li></ol><p><strong>删除</strong>：</p><ol><li>删除表：<code>DROP TABLE [IF EXISTS] 表名;</code></li><li>删除指定表，并重新创建该表：<code>TRUNCATE TABLE 表名;</code> （作用等效于清空表中的所有数据，保留表结构，最后留下的是一张空表）</li></ol><p><strong>数据类型</strong>：</p><ol><li>数值类型：</li></ol><img src="/2025/03/02/Database-and-SQL-Basic-Concepts-and-Usage/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B.png" class=""><ol start="2"><li><p>字符串类型：</p><img src="/2025/03/02/Database-and-SQL-Basic-Concepts-and-Usage/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B.png" class=""><p>char：定长字符串，占用的空间是一个定值，但是性能好</p><p>varchar：变长字符串，占用的空间随存储的内容大小变化，但是性能较差</p></li><li><p>日期时间类型：</p><img src="/2025/03/02/Database-and-SQL-Basic-Concepts-and-Usage/%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B.png" class=""></li></ol><h4 id="DDL小结">DDL小结</h4><p>DDL数据库操作：</p><ol><li>SHOW DATABASES;</li><li>CREATE DATABASE name;</li><li>USE name ;</li><li>SELECT DATABASE();</li><li>DROP DATABASE name;</li></ol><p>DDL表操作：</p><ol><li>SHOW TABLES;</li><li>CREATE TABLE name (field field_type, field field_type, …, field field_type);</li><li>DESC name;</li><li>SHOW CREATE TABLE name;</li><li>ALTER TABLE name ADD/MODIFY/CHANGE/DROP/RENAME TO …;</li><li>DROP TABLE name;</li></ol><h3 id="DML-数据操作语言">DML - 数据操作语言</h3><ul><li><p>介绍：DML 英文全称是 Data Manipulation Language（数据操作语言），用来对数据库中表的数据记录进行<strong>增删改</strong>操作。</p><ul><li>添加数据：INSERT</li><li>修改数据：UPDATE</li><li>删除数据：DELETE</li></ul></li><li><p>添加数据</p><ol><li><p>给指定字段添加数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名(字段名<span class="number">1</span>, 字段名<span class="number">2</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure></li><li><p>给全部字段添加数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名 <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure></li><li><p>批量添加数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名(字段名<span class="number">1</span>, 字段名<span class="number">2</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...), (值<span class="number">1</span>, 值<span class="number">2</span>, ...), (值<span class="number">1</span>, 值<span class="number">2</span>, ...), ...;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名 <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...), (值<span class="number">1</span>, 值<span class="number">2</span>, ...), (值<span class="number">1</span>, 值<span class="number">2</span>, ...), ...;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：</p><ol><li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</li><li>字符串和日期型数据应该包含在引号中。</li><li>插入的数据大小，应该在字段的规定范围内。</li></ol></blockquote></li><li><p>修改数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">    字段名<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span>，</span><br><span class="line">    字段名<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span>，</span><br><span class="line">    ...</span><br><span class="line">[<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure><blockquote><p>注意：修改语句的条件可以有，也可以没有。如果没有条件，则会修改整张表的所有数据。</p></blockquote></li><li><p>删除数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li>DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。</li><li>DELETE 语句不能删除某一个字段的值（用 UPDATE），只能删除一整行。</li></ol></blockquote></li><li><p>DML 小结</p><ul><li>添加：INSERT INTO tname(f1, f2, …) VALUES (v1, v2, …);</li><li>修改：UPDATE tname SET f1 = v1, f2 = v2, … WHERE condition;</li><li>删除：DELETE FROM tname WHERE condition;</li></ul></li></ul><h3 id="DQL-数据查询语言">DQL - 数据查询语言</h3><ul><li><p>DQL 介绍：DQL 英文全称是 Data Query Language（数据查询语言），用来查询数据库中表的记录。</p></li><li><p>DQL 语法结构：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  字段列表</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  表名列表</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">  分组字段列表</span><br><span class="line"><span class="keyword">HAVING</span> </span><br><span class="line">  分组后条件列表</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">  排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">  分页参数</span><br></pre></td></tr></table></figure></li><li><p>基本查询</p><ol><li><p>查询多个字段</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>, 字段<span class="number">2</span>, 字段<span class="number">3</span>, ... <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></li><li><p>设置别名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span> [<span class="keyword">AS</span> 别名<span class="number">1</span>], 字段<span class="number">2</span> [<span class="keyword">AS</span> 别名<span class="number">2</span>] .. <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></li><li><p>去除重复记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>条件查询（WHERE）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件列表;</span><br></pre></td></tr></table></figure><ul><li><p>条件：</p><ol><li><p>比较运算符</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>=</td><td>等于</td></tr><tr><td>!= 或 &lt;&gt;</td><td>不等于</td></tr><tr><td>BETWEEN … AND …</td><td>在某个范围之内（含边界）</td></tr><tr><td>IN(…)</td><td>在 IN 之后的列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配（_匹配单个，%匹配任意个）</td></tr><tr><td>IS NULL</td><td>是 NULL</td></tr></tbody></table></li><li><p>逻辑运算符</p><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>与</td></tr><tr><td>OR 或 ||</td><td>或</td></tr><tr><td>NOT 或 !</td><td>非</td></tr></tbody></table></li></ol></li></ul></li><li><p>聚合函数（count、max、min、avg、sum）</p><ul><li><p>介绍：聚合函数功能是将一列数据作为一个整体，进行纵向计算</p></li><li><p>常见聚合函数：</p><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">count</td><td style="text-align:center">统计数量</td></tr><tr><td style="text-align:center">max</td><td style="text-align:center">最大值</td></tr><tr><td style="text-align:center">min</td><td style="text-align:center">最小值</td></tr><tr><td style="text-align:center">avg</td><td style="text-align:center">平均值</td></tr><tr><td style="text-align:center">sum</td><td style="text-align:center">求和</td></tr></tbody></table></li><li><p>聚合函数语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 聚合函数(字段列表) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><blockquote><p>注意：null 值不参与所有聚合函数的运算。</p></blockquote></li></ul></li><li><p>分组查询（GROUP BY）</p><ul><li><p>语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件] <span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段名 [<span class="keyword">HAVING</span> 分组后过滤条件]</span><br></pre></td></tr></table></figure></li><li><p>WHERE 和 HAVING 的区别：</p><ul><li>执行时机不同：WHERE 是<strong>分组之前</strong>进行过滤，不满足WHERE 条件的不参与分组；而 HAVING 是<strong>分组之后</strong>对结果进行过滤。</li><li>判断条件不同：WHERE <strong>不能对聚合函数</strong>进行判断，而 HAVING <strong>可以</strong>。</li></ul></li><li><p>例子：</p><ol><li><p>根据性别分组，统计男性员工和女性员工的数量</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> gender, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br></pre></td></tr></table></figure></li><li><p>根据性别分组，统计男性员工和女性员工的平均年龄</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> gender, <span class="built_in">avg</span>(age) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br></pre></td></tr></table></figure></li><li><p>查询年龄小于 45 的员工，并根据工作地址分组，获取员工数量大于等于 3 的工作地址</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> workaddress, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> addr_count <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">45</span> <span class="keyword">group</span> <span class="keyword">by</span> workaddress <span class="keyword">having</span> addr_count <span class="operator">&gt;=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：</p><ol><li>执行顺序： where &gt; 聚合函数 &gt; having</li><li>分组之后，<strong>查询的字段一般为聚合函数和分组字段</strong>，<strong>查询其他字段无任何意义</strong></li></ol></blockquote></li></ul></li><li><p>排序查询（ORDER BY）</p><ul><li><p>语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span>, 字段<span class="number">2</span> 排序方式<span class="number">2</span>, ...;</span><br></pre></td></tr></table></figure></li><li><p>排序方式：</p><ol><li>ASC：升序（默认值）</li><li>DESC：降序</li></ol></li></ul><blockquote><p>注意：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。（字段排序优先级）</p></blockquote></li><li><p>分页查询（LIMIT）</p><ul><li><p>语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 LIMIT 起始索引, 查询记录数;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li>起始索引从 0 开始，起始索引 = （查询页码- 1）* 每页显示记录数</li><li>分页查询是数据库的方言，不同数据库有不同的实现，MySQL 中是 LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10</li></ol></blockquote></li></ul></li><li><p>DQL 语句执行顺序</p><ul><li><p>这是编写顺序：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    字段列表</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    表名列表</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    分组字段列表</span><br><span class="line"><span class="keyword">HAVING</span> </span><br><span class="line">    分组后条件列表</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">    分页参数</span><br></pre></td></tr></table></figure></li><li><p>这是执行顺序：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    表名列表</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    分组字段列表</span><br><span class="line"><span class="keyword">HAVING</span> </span><br><span class="line">    分组后条件列表</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    字段列表</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">    分页参数</span><br></pre></td></tr></table></figure><p>先确定是哪张表，再根据查询条件、分组字段及其条件得到查询结果，最后对查询结果排序并展示。</p></li></ul></li><li><p>DQL 小结</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>                     <span class="comment">----&gt;基础查询</span></span><br><span class="line">  字段列表</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  表名列表</span><br><span class="line"><span class="keyword">WHERE</span>                      <span class="comment">----&gt;条件查询，分组前过滤</span></span><br><span class="line">  条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>                   <span class="comment">----&gt;分组查询</span></span><br><span class="line">  分组字段列表</span><br><span class="line"><span class="keyword">HAVING</span>                     <span class="comment">----&gt;分组后过滤</span></span><br><span class="line">  分组后条件列表</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>                   <span class="comment">----&gt;排序查询， asc 和 desc</span></span><br><span class="line">  排序字段列表</span><br><span class="line">LIMIT                      <span class="comment">----&gt;分页查询</span></span><br><span class="line">  分页参数</span><br></pre></td></tr></table></figure></li></ul><h3 id="DCL-数据控制语言">DCL - 数据控制语言</h3><ol><li>控制数据库可以由哪些用户来访问</li><li>控制每一个用户具有什么样的权限</li></ol><h4 id="管理用户">管理用户</h4><ul><li><p>查询用户</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li><li><p>创建用户</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>如果主机名填为 ‘%’，表示用户可以任意主机上访问数据库</p></blockquote></li><li><p>修改用户密码</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除用户</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="权限控制">权限控制</h4><p>MySQL 中定义了很多种权限，常用的有以下几种：</p><table><thead><tr><th style="text-align:center">权限</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td style="text-align:center">SELECT</td><td>查询数据</td></tr><tr><td style="text-align:center">INSERT</td><td>插入数据</td></tr><tr><td style="text-align:center">UPDATE</td><td>修改数据</td></tr><tr><td style="text-align:center">DELETE</td><td>删除数据</td></tr><tr><td style="text-align:center">ALTER</td><td>修改表</td></tr><tr><td style="text-align:center">DROP</td><td>删除数据库/表/视图</td></tr><tr><td style="text-align:center">CREATE</td><td>创建数据库/表</td></tr></tbody></table><p>可参见官方文档：[<a href="https://www.mysqlzh.com/doc/44/175.html">https://www.mysqlzh.com/doc/44/175.html</a>](MySQL 权限官方文档)</p><ul><li><p>查询用户所拥有的权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>授予权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>撤销权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">FROM</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：</p><ul><li>多个权限之间，使用逗号分隔</li><li>授权时，数据库名和表名可以使用 * 进行通配，代表所有</li></ul></blockquote><h2 id="函数">函数</h2><p><strong>函数 是指一段可以直接被另一段程序调用的程序或代码</strong></p><h3 id="字符串函数">字符串函数</h3><p>MySQL 中内置了很多字符串函数，常用的几个如下：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(S1,S2,…,Sn)</td><td>字符串拼接</td></tr><tr><td>LOWER(str)</td><td>字符串转为小写</td></tr><tr><td>UPPER(str)</td><td>字符串转为大写</td></tr><tr><td>LPAD(str, n, pad)</td><td>左填充，用 pad 对 str 左边填充 n 个字符串长度（不会覆盖原字符串，原字符串长度也计入 n）</td></tr><tr><td>RPAD(str, n, pad)</td><td>右填充，用 pad 对 str 右边填充 n 个字符串长度（不会覆盖原字符串，原字符串长度也计入 n）</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str, start, len)</td><td>返回从 str 的 start 位置起的长度为 len 的字符串（索引从 1 开始）</td></tr></tbody></table><blockquote><p>SELECT 函数(字符串);</p></blockquote><h3 id="数值函数">数值函数</h3><p>常见的数值函数：</p><table><thead><tr><th style="text-align:center">函数</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">CEIL(x)</td><td>向上取整</td></tr><tr><td style="text-align:center">FLOOR(x)</td><td>向下取整</td></tr><tr><td style="text-align:center">MOD(x, y)</td><td>即 x 模 y 的值</td></tr><tr><td style="text-align:center">RAND()</td><td>返回 0~1 内的随机数</td></tr><tr><td style="text-align:center">ROUND(x, y)</td><td>求参数 x 的四舍五入的值，保留 y 位小数</td></tr></tbody></table><h3 id="日期函数">日期函数</h3><p>常见的日期函数：</p><table><thead><tr><th style="text-align:center">函数</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">CURDATE()</td><td>返回当前日期</td></tr><tr><td style="text-align:center">CURTIME()</td><td>返回当前时间</td></tr><tr><td style="text-align:center">NOW()</td><td>返回当前日期和时间</td></tr><tr><td style="text-align:center">YEAR(date)</td><td>获取 date 的年份</td></tr><tr><td style="text-align:center">MONTH(date)</td><td>获取 date 的月份</td></tr><tr><td style="text-align:center">DAY(date)</td><td>获取 date 的日期</td></tr><tr><td style="text-align:center">DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期/时间值加上一个以 type 为单位的时间间隔 expr 后的时间值</td></tr><tr><td style="text-align:center">DATEDIFF(date1, date2)</td><td>返回 date1 和 date2 之间相差的天数（date1 - date2）</td></tr></tbody></table><h3 id="流程函数">流程函数</h3><p>流程函数也是很常用的一类函数，可以在 SQL 语句中实现条件筛选，从而提高语句的效率</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value, t, f)</td><td>如果 value 为 true，则返回 t，否则返回 f</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果 value1 不为 null，返回 value1，否则返回 value2</td></tr><tr><td>CASE WHEN [val1] THEN [res1] … ELSE [default] END</td><td>如果 val1 为 true，返回 res1，…，否则返回 default 默认值</td></tr><tr><td>CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END</td><td>如果 expr 的值为 val1，返回 res1，…，否则返回 default 默认值</td></tr></tbody></table><h2 id="约束">约束</h2><h3 id="概述">概述</h3><ul><li><p>概念：约束是作用于<strong>表中字段上的规则</strong>，用于<strong>限制</strong>存储在表中的<strong>数据</strong></p></li><li><p>目的：保证数据库中数据的正确性、有效性和完整性</p></li><li><p>分类：</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为 null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束（8.0.16 版本之后）</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><blockquote><p>注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。</p></blockquote></li></ul><h3 id="约束演示">约束演示</h3><p>演示：根据需求，完成表结构的创建</p><table><thead><tr><th>字段名</th><th>字段含义</th><th>字段类型</th><th>约束条件</th><th>约束关键字</th></tr></thead><tbody><tr><td>id</td><td>ID 唯一标识</td><td>int</td><td>主键，并且自动增长</td><td>PRIMARY KEY, AUTO_INCREMENT</td></tr><tr><td>name</td><td>姓名</td><td>varchar(10)</td><td>不为空，并且唯一</td><td>NOT NULL, UNIQUE</td></tr><tr><td>age</td><td>年龄</td><td>int</td><td>大于 0，并且小于等于 120</td><td>CHECK(condition)</td></tr><tr><td>status</td><td>状态</td><td>char(1)</td><td>如果没有指定该值，默认为 1</td><td>DEFAULT</td></tr><tr><td>gender</td><td>性别</td><td>char(1)</td><td>无</td><td></td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> <span class="keyword">user</span>(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span> <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">int</span> <span class="keyword">CHECK</span>(age <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> age <span class="operator">&lt;=</span> <span class="number">120</span>) COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    status <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;状态&#x27;</span>, </span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>) COMMENT <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">) COMMENT <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>DataGrip 也提供了创建表的图形化界面，可以轻松选择约束项从而创建表</p></blockquote><h3 id="外键约束">外键约束</h3><ul><li><p>概念：外键用来让两张表的<strong>数据之间建立连接</strong>，保证数据的一致性和完整性，其图示如下：</p><img src="/2025/03/02/Database-and-SQL-Basic-Concepts-and-Usage/%E5%A4%96%E9%94%AE%E5%9B%BE%E7%A4%BA.png" class=""><blockquote><ul><li><p>具有外键的表称作 从表，外键关联的表称作 主表。</p></li><li><p>如果两张表不用外键连接，那么会仅仅是逻辑上有联系，但是数据库层面是没有联系的</p></li><li><p>添加外键约束可以避免从表关联的主表的数据被删除</p></li></ul></blockquote></li><li><p>语法：</p><ul><li><p>添加外键：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> name(</span><br><span class="line">    fname, dname,</span><br><span class="line">    ...</span><br><span class="line">    [<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN KEY</span>(外键字段名) <span class="keyword">REFERENCES</span> 主表(主表列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">ADD CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN KEY</span>(外键字段名) <span class="keyword">REFERENCES</span> 主表(主表列名);</span><br></pre></td></tr></table></figure></li><li><p>删除外键</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN KEY</span> 外键名称;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>删除/更新行为</p><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在主表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则不允许删除/更新。（与 RESTRICT 一致）（默认行为）</td></tr><tr><td>RESTRICT</td><td>当在主表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则不允许删除/更新。（与 NO ACTION 一致）（默认行为）</td></tr><tr><td>CASCADE</td><td>当在主表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在从表中的记录</td></tr><tr><td>SET NULL</td><td>当在主表中删除对应记录时，首先检查该记录是否有对应外键，如果有，则设置从表中该外键的值为 null （要求该外键值允许取 null）</td></tr><tr><td>SET DEFAULT</td><td>主表有变更时，从表将外键设置成一个默认的值（Innodb 不支持该功能）</td></tr></tbody></table><ul><li><p>指定外键约束的行为（如指定为 CASCADE 行为）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">ADD CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN KEY</span>(外键字段) <span class="keyword">REFERENCES</span> 主表名(主表字段名) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;</span><br></pre></td></tr></table></figure><ul><li>对于 DataGrip 图形化界面，可以直接右键表，选择 <code>Modify Table</code> ，选择 <code>Foreign Keys</code> 选项卡即可指定行为</li></ul></li></ul></li></ul><h2 id="多表查询">多表查询</h2><h3 id="多表关系">多表关系</h3><ul><li>概述：项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于<strong>业务之间相互关联</strong>，所以各个<strong>表结构之间也存在着各种联系</strong>，基本上分为三种：<ul><li><strong>一对多（多对一）</strong><ul><li>案例：部门 与 员工的关系</li><li>关系：一个部门对应多个员工，一个员工对应一个部门</li><li>实现：<strong>在多的一方建立外键，指向一的一方的主键</strong></li></ul></li><li><strong>多对多</strong><ul><li>案例：学生 与 课程的关系</li><li>关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择</li><li>实现：<strong>建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</strong></li></ul></li><li><strong>一对一</strong><ul><li>案例：用户 与 用户详情的关系</li><li>关系：一对一关系，多用于<strong>单表拆分</strong>，将一张表的<strong>基础字段</strong>放在一张表中，<strong>其他详情字段</strong>放在另一张表中，以提升操作效率</li><li>实现：<strong>在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</strong></li></ul></li></ul></li></ul><h3 id="多表查询概述">多表查询概述</h3><ul><li>概述：多表查询值从多张表中查询数据</li><li>笛卡尔积：笛卡尔乘积是指在数学中，两个集合的所有组合情况。<strong>（在多表查询时，需要消除无效的笛卡尔积，一种简单的办法是加上 WHERE 条件查询）</strong></li><li>多表查询的分类<ul><li>连接查询<ul><li>内连接：相当于查询 A 和 B 交集部分的数据</li><li>外连接：<ul><li>左外连接：查询<strong>左表</strong>所有数据，以及两张表交集部分数据</li><li>右外连接：查询<strong>右表</strong>所有数据，以及两张表交集部分数据</li></ul></li><li>子连接：当前表与自身的连接查询，自连接必须使用表别名</li></ul></li><li>子查询</li></ul></li></ul><h3 id="内连接">内连接</h3><ul><li><p>内连接查询的是两张表交集的部分</p></li><li><p>查询语法：</p><ul><li><p>隐式内连接：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>, 表<span class="number">2</span> <span class="keyword">WHERE</span> 条件 ...;</span><br></pre></td></tr></table></figure></li><li><p>显式内连接</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> [<span class="keyword">INNER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件 ...;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="外连接">外连接</h3><p>外连接查询语法：</p><ul><li><p>左外连接：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件 ...;</span><br></pre></td></tr></table></figure><p>相当于查询表1的所有数据和表1、表2交集部分的数据</p></li><li><p>右外连接：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件 ...;</span><br></pre></td></tr></table></figure><p>相当于查询表2的所有数据和表1、表2交集部分的数据</p></li></ul><h3 id="自连接">自连接</h3><p>自连接查询语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A 别名A <span class="keyword">JOIN</span> 表A 别名B <span class="keyword">ON</span> 条件 ...;</span><br></pre></td></tr></table></figure><p>自连接查询，可以是内连接查询，也可以是外连接查询</p><h3 id="联合查询-union-union-all">联合查询 - union, union all</h3><ul><li><p>对于 union 查询，就是把多次查询的结果合并起来，形成一个新的查询结果集</p></li><li><p>语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A ...</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表B ...;</span><br></pre></td></tr></table></figure><ul><li><p><strong>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致（即查询出来的表结构必须一致）</strong></p></li><li><p><strong>union all 会直接将全部的数据合并在一起，union 会对合并之后的数据去重</strong></p></li></ul></li></ul><h3 id="子查询">子查询</h3><ul><li><p>概念：SQL 语句中的嵌套 SELCT 语句，称为<strong>嵌套查询</strong>，又称<strong>子查询</strong>，其常见形式如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">WHERE</span> column1 <span class="operator">=</span> (<span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> 表<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>子查询外部的语句可以是 INSERT/UPDATE/DELETE/SELECT（增删改查）中的任意一个</strong></p></li><li><p>根据子查询结果不同，分为：</p><ul><li><p>标量子查询（子查询结果为单个值）</p><ul><li><p>常用的操作符：= &lt;&gt; &gt; &gt;= &lt; &lt;=</p></li><li><p>例子：</p><ul><li><pre><code class="language-sql">SELECT * FROM emp WHERE dept_id = (SELECT id FROM dept where name = '销售部');<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```sql</span><br><span class="line">  SELECT * FROM emp WHERE entrydate &gt; (SELECT entrydate FROM emp WHERE name = &#x27;方东白&#x27;);</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>列子查询（子查询结果为一列）</p><ul><li><p>常用的操作符：IN、NOT IN、ANY、SOME、ALL</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围之内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与 ANY 等同，可相互替换</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table></li><li><p>例子：</p><ul><li><pre><code class="language-sql">SELECT * FROM emp WHERE dept_id IN (SELECT dept_id WHERE name = '销售部' OR name = '市场部');<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```sql</span><br><span class="line">  SELECT * FROM emp WHERE salary &gt; ALL (SELECT salary FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = &#x27;财务部&#x27;));</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="language-sql">SELECT * FROM emp WHERE salary &gt; ANY (SELECT salary FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = '研发部'));<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 行子查询（子查询结果为一行）</span><br><span class="line"></span><br><span class="line">  - 常用的操作符：=、&lt;&gt;、IN、NOT IN</span><br><span class="line"></span><br><span class="line">  - 例子：</span><br><span class="line"></span><br><span class="line">    - ```sql</span><br><span class="line">      SELECT * FROM emp WHERE (salary, managerid) = (SELECT salary, managerid FROM emp WHERE name = &#x27;张无忌&#x27;);</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>表子查询（子查询结果为多行多列）</p><ul><li><p>常用的操作符：IN</p></li><li><p>经常将表子查询返回的表当作临时表，与其他表一起做联查操作</p></li><li><p>例子：</p><ul><li><pre><code class="language-sql">SELECT * FROM emp WHERE (job, salary) IN (SELECT job, salary FROM emp WHERE name = '鹿杖客' OR name = '宋远桥');<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```sql</span><br><span class="line">  SELECT * FROM (SELECT * FROM emp LEFT JOIN dept ON emp.dept_id = dept.id) WHERE entrydate &gt; &#x27;2006-01-01&#x27;;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul></li><li><p>根据子查询位置，分为：WHERE 之后、FROM 之后、SELECT 之后</p></li></ul><h3 id="多表查询案例">多表查询案例</h3><p><strong>核心是找到连接条件</strong></p><img src="/2025/03/02/Database-and-SQL-Basic-Concepts-and-Usage/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%A1%88%E4%BE%8B.png" class=""><ol><li><pre><code class="language-sql">SELECT name, age, job, deptname FROM emp, dept WHERE emp.dept_id = dept.id;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```sql</span><br><span class="line">   SELECT * FROM (SELECT name, age, job, deptname FROM emp, dept WHERE emp.dept_id = dept.id) WHERE age &lt; 30;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="language-sql">SELECT DISTINCT dept_id, deptname FROM emp, dept WHERE emp.dept_id = dept.id;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. ```sql</span><br><span class="line">   SELECT emp.*, deptname FROM emp LEFT JOIN dept ON emp.dept_id = dept.id WHERE age &gt; 40;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="language-sql">SELECT emp.*, salgrade.grade From emp, salgrade where emp.salary &gt;= salgrade.losal and emp.salary &lt;= salgrade.hisal;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. ```sql</span><br><span class="line">   SELECT emp.*, salgrade.grade FROM emp, dept, salgrade WHERE (emp.dept_id = dept.id) and (emp.salary BETWEEN salgrade.losal AND salgrade.hisal) and (dept.deptname = &#x27;研发部&#x27;);</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="language-sql">SELECT avg(salary) From emp, dept WHERE emp.dept_id = dept.id AND dept.deptname = '研发部';<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">8. ```sql</span><br><span class="line">   SELECT * FROM emp WHERE salary &gt; (SELECT salary FROM emp WHERE name = &#x27;灭绝&#x27;);</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="language-sql">SELECT * FROM emp WHERE salary &gt; (SELECT avg(salary) FROM emp);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">10. ```sql</span><br><span class="line">    SELECT * FROM emp e1 WHERE salary &lt; (SELECT avg(salary) From emp e2, dept WHERE emp.dept_id = dept.id and e1.dept_id = e2.dept_id);</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="language-sql">SELECT id, deptname, (SELECT count(*) FROM emp e WHERE e.dept_id = d.id) '人数' FROM dept d;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">12. ```sql</span><br><span class="line">    SELECT s.name s.no c.name FROM student s, course c, student_course sc WHERE s.id = sc.studentid AND sc.courseid = c.id;</span><br></pre></td></tr></table></figure></code></pre></li></ol><h2 id="事务">事务</h2><h3 id="事务简介">事务简介</h3><p><strong>事务</strong> 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为<strong>一个整体</strong>一起向系统提交或撤销操作请求，即这些操作<strong>要么同时成功，要么同时失效</strong>。</p><img src="/2025/03/02/Database-and-SQL-Basic-Concepts-and-Usage/%E4%BA%8B%E5%8A%A1-%E4%BB%A5%E9%93%B6%E8%A1%8C%E4%B8%BA%E4%BE%8B.png" class=""><blockquote><p>默认 MySQL 的事务是自动提交的，也就是说，当执行一条 DML 语句，MySQL 会立即隐式地提交事务</p></blockquote><h3 id="事务操作">事务操作</h3><p><strong>方式一：手动禁止事务自动提交</strong></p><ul><li><p>查看/设置事务提交方式</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>提交事务</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li><li><p>回滚事务</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>方式二：手动开启提交事务</strong></p><ul><li><p>开启事务</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION 或 <span class="keyword">BEGIN</span></span><br></pre></td></tr></table></figure></li><li><p>提交事务</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li><li><p>回滚事务</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="事务四大特性（ACID）">事务四大特性（ACID）</h3><ul><li>原子性（Atomaicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h3 id="并发事务问题">并发事务问题</h3><p>并发事务引发的问题常见的有如下几个：</p><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另外一个事务还没有提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同（可能由于其他事务此时已经更新了数据并提交了），称之为不可重复读</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 “幻影”（可能由于其他事务在该事务查询后插入前已经插入了数据并提交了）</td></tr></tbody></table><h3 id="事务隔离级别">事务隔离级别</h3><p><strong>用于解决并发事务问题而引入的机制</strong></p><p>数据库中隔离级别主要有以下四种：</p><table><thead><tr><th>隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>Read committed</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td>Repeatable Read（默认）</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td>Serializable</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><p>√ 表示该问题能够发生，× 表示该问题不可能发生</p><blockquote><ul><li><p>查看事务隔离级别</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@TRANSACTION_ISOLATION</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置事务隔离级别</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> [SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED<span class="operator">|</span>READ COMMITTED<span class="operator">|</span>REPEATABLE READ<span class="operator">|</span>SERIALIZABLE&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p><strong>注意：事务隔离级别越高，  数据越安全，但是性能越低</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> SQL </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis Plus Basic Usage</title>
      <link href="/2025/03/02/MyBatis-Plus-Basic-Usage/"/>
      <url>/2025/03/02/MyBatis-Plus-Basic-Usage/</url>
      
        <content type="html"><![CDATA[<h1>MyBatisPlus</h1><h2 id="快速入门">快速入门</h2><h3 id="入门案例">入门案例</h3><p>需求：基于可签资料提供的项目，实现下列功能</p><ol><li>新增用户功能</li><li>根据 id 查询用户</li><li>根据 id 批量查询用户</li><li>根据 id 更新用户</li><li>根据 id 删除用户</li></ol><p>步骤：</p><ol><li><p>引入 MyBatisPlus 的起步依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MyBatisPlus 官方提供了起步依赖，其中集成了 Mybatis 和 MybatisPlus 的所有功能，并且实现了自动装配效果</p><p>因此我们可以用 MybatisPlus 的 起步依赖代替 Mybatis 的起步依赖</p></li><li><p>定义 Mapper</p><p>自定义的 Mapper 继承 MybatisPlus 提供的 BaseMapper 接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>继承的时的泛型为操作的实体类的类型</p></blockquote><p>继承后，就可以使用父类提供的方法来对数据库单表进行增删改查</p></li></ol><h3 id="常见注解">常见注解</h3><p>MybatisPlus 通过扫描实体类，并<strong>基于反射获取实体类信息作为数据库表信息</strong></p><ul><li><p>如果不进行配置，则实体类属性和数据库表字段的对应关系如下：</p><ul><li>类名驼峰转下划线作为表名</li><li>名为 id 的字段作为主键（属性中必须有一个字段作为主键！）</li><li>变量名驼峰转下划线作为表的字段名</li></ul></li><li><p>如果要配置类名与表名、属性与字段的对应关系，则常用到如下几个注解：</p><ul><li><p><code>@TableName</code>：用来指定表名</p></li><li><p><code>@TableId</code>：用来指定表中的主键字段信息</p><p>属性 type 有三个常用值：</p><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td><code>idType.AUTO</code></td><td>id 的值交由数据库自增长</td></tr><tr><td><code>idType.INPUT</code></td><td>id 的值需要在插入时由程序员自己赋值</td></tr><tr><td><code>idType.ASSIGN_ID</code>(默认值)</td><td>id 的值由接口 IdentifierGenerator 的默认实现类 DefaultIdentifiterGenerator 中方法 nextId 通过雪花算法来生成</td></tr></tbody></table><blockquote><p>自增主键必须加上 <code>@TableId(type = idType.AUTO)</code></p></blockquote></li><li><p><code>@TableField</code>：用来指定表中的普通字段信息</p><p>使用场景：</p><ul><li><p>成员名与数据库字段名不一致</p></li><li><p>成员变量名以 is 开头，且是布尔类型，必须加上该注解来对应字段</p><blockquote><p>反射时，is 开头，且是布尔类型的成员变量名的 is 会被去掉，导致无法与数据库字段对应</p></blockquote></li><li><p>成员变量名与数据库关键字冲突，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(&quot;&#x27;order&#x27;&quot;)</span> <span class="comment">// 加上 &#x27;&#x27; 作为转义字符</span></span><br><span class="line"><span class="keyword">private</span> Integer order;</span><br></pre></td></tr></table></figure></li><li><p>成员变量不是数据库字段，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(exist = false)</span></span><br><span class="line"><span class="keyword">private</span> String address;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="常见配置">常见配置</h3><p>MyBatisPlus 的配置项继承了 MyBatis 原生配置和一些自己特有的配置，例如：</p><img src="/2025/03/02/MyBatis-Plus-Basic-Usage/MybatisPlus%E9%85%8D%E7%BD%AE%E9%A1%B9.png" class=""><p>官网配置说明文档：<a href="https://baomidou.com/pages/56bac0/">使用配置 | MyBatis-Plus (baomidou.com)</a></p><h2 id="核心功能">核心功能</h2><h3 id="条件构造器">条件构造器</h3><p>MyBatisPlus 支持各种复杂的 where 条件，可以满足日常开发的所有需求</p><h4 id="案例：基于-QueryWrapper-的查询">案例：基于 QueryWrapper 的查询</h4><p>需求：</p><ol><li><p>查询出名字中带 o 的，存款大于等于 1000 的人的 id、username、info、balance 字段</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.构建查询条件</span></span><br><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">    .select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;balance&quot;</span>)</span><br><span class="line">    .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">    .ge(<span class="string">&quot;balance&quot;</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 2.查询</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure></li><li><p>更新用户名为 jack 的用户余额为 2000</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.要更新的数据</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setBalance(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">// 2.更新的条件</span></span><br><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">    .eq(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line"><span class="comment">// 3.执行更新</span></span><br><span class="line">userMapper.update(user, wrapper);</span><br></pre></td></tr></table></figure></li></ol><h4 id="案例：基于-UpdateWrapper-的更新">案例：基于 UpdateWrapper 的更新</h4><p>需求：更新 id 为 1、2、4的用户的余额，扣 200</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.设置需要更新的 id</span></span><br><span class="line">List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line"><span class="comment">// 2.构造条件</span></span><br><span class="line">UpdateWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;User&gt;()</span><br><span class="line">    .setSql(<span class="string">&quot;balance = balance - 200&quot;</span>)</span><br><span class="line">    .in(<span class="string">&quot;id&quot;</span>, ids);</span><br><span class="line"><span class="comment">// 3.更新数据</span></span><br><span class="line">userMapper.update(<span class="literal">null</span>, wrapper);</span><br></pre></td></tr></table></figure><p><strong>避免字符串硬编码</strong>，所以推荐使用 <strong>LambdaWrapper</strong> 来动态获取 column，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.构建查询条件</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;()</span><br><span class="line">    .select(User::getId, User::getUsername. User::getInfo, User::getBalance)</span><br><span class="line">    .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">    .ge(User::getBalance, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 2.查询</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure><blockquote><p>可以避免因实体类属性名变更而需要大幅改动原代码的情况</p></blockquote><h3 id="自定义-SQL">自定义 SQL</h3><p>我们可以利用 MyBatisPlus 的 Wrapper 来构建复杂的 where 条件，然后<strong>自己定义 SQL 语句中剩下的部分</strong></p><p>步骤：</p><ol><li><p>基于 Wrapper 构建 where 条件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="comment">// 1.构建条件</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;()</span><br><span class="line">    .in(User:getId, ids);</span><br><span class="line"><span class="comment">// 2.自定义SQL方法调用</span></span><br><span class="line">userMapper.updateBalanceByIds(wrapper, amount);</span><br></pre></td></tr></table></figure></li><li><p>在 mapper 方法参数中用 @Param 声明 wrapper 变量名称，必须是 ew</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">updateBalanceByIds</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> LambdaQueryWrapper&lt;User&gt; wrapper, <span class="meta">@Param(&quot;amount&quot;)</span> <span class="type">int</span> amount)</span>;</span><br></pre></td></tr></table></figure></li><li><p>自定义 SQL，并使用 wrapper 条件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBalanceByIds&quot;</span>&gt;</span></span><br><span class="line">UPDATE tb_user SET balance = balance - #&#123;amount&#125; $&#123;ew.customSqlSegment&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Service-接口">Service 接口</h3><h4 id="基本用法">基本用法</h4><p>如果想要在 <strong>Service 实现类中减少代码</strong>，<strong>controller 直接调 service 实现类就可以实现基本的增删改查功能</strong>，其余的代码都不用写，就可以选择让 service 继承 MyBatisPlus 的一个接口 <code>IService</code>，具体步骤如下：</p><ol><li><p>让 Service 接口 继承 <code>IService</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> UserService <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt;&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>Service 的实现类继承类 <code>ServiceImpl</code>（实现了 IService 接口的所有方法）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> UserServiceImpl <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><ul><li><code>IService</code> 泛型填 Service 要操作的实体类</li><li><code>ServiceImpl</code> 泛型第一个填 Service 实现业务功能要调用的 Mapper，第二个填 Service 要操作的实体类</li></ul></blockquote><h4 id="开发基本业务接口">开发基本业务接口</h4><p>需求：基于 Restful 风格实现下面的接口：</p><img src="/2025/03/02/MyBatis-Plus-Basic-Usage/%E6%A1%88%E4%BE%8B.png" class=""><ol><li><p>新增用户</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;新增用户接口&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> UserFormDTO userDTO)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.把DTO拷贝到PO</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> BeanUtil.copyProperties(userDTO, User.class);</span><br><span class="line">    <span class="comment">// 2.新增</span></span><br><span class="line">    userService.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除用户</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;删除用户接口&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUserById</span><span class="params">(<span class="meta">@ApiParam(&quot;用户id&quot;)</span> <span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    userService.removeById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据id查询用户</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;根据id查询用户接口&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> UserVO <span class="title function_">deleteUserById</span><span class="params">(<span class="meta">@ApiParam(&quot;用户id&quot;)</span> <span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(id);</span><br><span class="line">    <span class="comment">// 2.把PO拷贝到VO</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyProperties(user, UserVO.class)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据id批量查询</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;根据id批量查询用户接口&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">deleteUserByIds</span><span class="params">(<span class="meta">@ApiParam(&quot;批量用户id&quot;)</span> <span class="meta">@RequestParam</span> List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询</span></span><br><span class="line">    List&lt;User&gt; users = userService.listByIds(ids);</span><br><span class="line">    <span class="comment">// 2.把PO拷贝到VO</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="开发复杂业务接口">开发复杂业务接口</h4><ol><li><p>根据id扣减余额</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// controller</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;扣减用户余额接口&quot;)</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/&#123;id&#125;/deduction/&#123;money&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduceBalanceById</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@ApiParam(&quot;用户id&quot;)</span> <span class="meta">@PathVariable(&quot;id&quot;)</span> Long id </span></span><br><span class="line"><span class="params">    <span class="meta">@ApiParam(&quot;扣减金额&quot;)</span> <span class="meta">@PathVariable(&quot;money&quot;)</span> Integer money)</span> &#123;</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    userService.deduceBalanceById(id, money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// service interface</span></span><br><span class="line"><span class="keyword">public</span> UserService <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduceBalanceById</span><span class="params">(Long id, Integer money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// serviceimpl</span></span><br><span class="line"><span class="keyword">public</span> UserServiceImpl <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduceBalanceById</span><span class="params">(Long id, Integer money)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">// 2.校验用户状态</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.校验余额是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户余额不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.扣减余额</span></span><br><span class="line">        baseMapper.deduceBalanceById(id, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mapper</span></span><br><span class="line"><span class="meta">@Update(&quot;UPDATE tb_user SET balance = balance - #&#123;money&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deduceBalanceById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;money&quot;)</span> Integer money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="IService-中的-Lambda-方法-——-复杂条件查询或复杂更新">IService 中的 Lambda 方法 —— 复杂条件查询或复杂更新</h4><h5 id="IService-中的-Lambda-查询">IService 中的 Lambda 查询</h5><p>需求：实现一个根据复杂条件查询用户的接口，查询条件如下：</p><ul><li>name：用户名关键字，可以为空</li><li>status：用户状态，可以为空</li><li>minBalance：最小余额，可以为空</li><li>maxBalance：最大余额，可以为空</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// serviceimpl</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryUsers</span><span class="params">(String name, Integer status, Integer minBalance, Integer maxBalance)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lambdaQuery()</span><br><span class="line">        .like(name != <span class="literal">null</span>, User::getUsername, name)</span><br><span class="line">        .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">        .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">        .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance)</span><br><span class="line">        .list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="IService-中的-Lambda-更新">IService 中的 Lambda 更新</h5><p>需求：改造根据id修改用户余额的接口，要求如下：</p><ol><li>完成对用户状态校验</li><li>完成对用户余额校验</li><li>如果扣减口余额为 0，则将用户 status 修改为冻结状态（2）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// serviceimpl</span></span><br><span class="line"><span class="keyword">public</span> UserServiceImpl <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduceBalanceById</span><span class="params">(Long id, Integer money)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">// 2.校验用户状态</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.校验余额是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户余额不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.扣减余额</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remainBalance</span> <span class="operator">=</span> user.getBalance() - money;</span><br><span class="line">        lambdaUpdate()</span><br><span class="line">            .set(User:getBalance, remainBalance)</span><br><span class="line">            .set(remainBalance == <span class="number">0</span>, User:getStatus, <span class="number">2</span>)</span><br><span class="line">            .eq(User:getId, id)</span><br><span class="line">            <span class="comment">// 防止并发风险，乐观锁</span></span><br><span class="line">            .eq(User:getBalance, user.getBalance)</span><br><span class="line">            <span class="comment">// 前面的语句只是在构建SQL语句，最后一定要加上update方法，这样SQL语句才会执行</span></span><br><span class="line">            .update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>补充：业务中 vo、dto 等的关系</p><img src="/2025/03/02/MyBatis-Plus-Basic-Usage/%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1.webp" class=""></blockquote><h4 id="IService-批量新增">IService 批量新增</h4><p>需求：批量插入 10万 条用户数据，并作出对比：</p><ul><li><p>普通 for 循环插入：耗时200秒左右</p><ul><li>该方式一条一条数据插入，总共提交了 10万 次的请求，十分低效</li></ul></li><li><p>IService 的批量插入：耗时20秒左右</p><ul><li><p>该方式每 1000 条数据插入一次，IService 的 saveBatch 方法会对这一千条数据进行 SQL 预编译，编译为 1000 条 SQL 语句，这样，总共提交的请求次数减少为 100000/1000 = 100 次，大大提高了效率</p></li><li><p>现在我们想进一步优化时间，于是我们想要 IService 预编译的 1000 SQL 语句合并为一条，这样，MySQL 总共会处理 100 条 SQL 语句，处理 100 次请求，相较于 100000 条 SQL语句和 100 次请求，耗时又可以减少，两种办法：</p><ul><li><p>手写 SQL 语句，使用 <code>foreach</code> 标签，将 1000 条数据写在一条 SQL 语句中</p></li><li><p>启用 MySQL 的<em>重写批处理语句</em>属性，在 <code>application.properties</code> 的数据库连接区域配置</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/tlias?rewriteBatchedStatements=true</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>启用<em>重写批处理语句</em>属性后，执行时间只需要6秒，大大提高了批量插入效率</p></li></ul></li></ul><h2 id="扩展功能">扩展功能</h2><h3 id="代码生成">代码生成</h3><ol><li>使用插件——MyBatisPlus</li><li>在顶部工具栏的 Other 选项中配置数据库信息</li><li>在 Other 选项卡中选择 <code>code generator</code>，配置代码生成信息<ul><li>module 填所属模块，若只有一个模块则空出</li><li>TablePrefix 处填表名前缀，如表名为 tb_user，想要生成的实体类名为User，则填入 tb_</li><li>Entity、Mapper等表单中填写想要对应生成类所属包的包名</li></ul></li></ol><h3 id="Db-静态工具">Db 静态工具</h3><p>用法与 IService 接口完全一致，区别在于 <code>Db</code> 是<strong>静态类</strong>，无法使用泛型，所以在方法中需要给出实体类的 class 对象。</p><p>Db静态工具的作用：避免 Service 实现类中的<strong>循环依赖</strong>问题</p><p>用法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Db.methodName(parameters);</span><br></pre></td></tr></table></figure><h3 id="逻辑删除">逻辑删除</h3><p>介绍：逻辑删除就是基于代码逻辑模拟删除效果，但并不会真正删除数据。思路如下：</p><ul><li><p>在表中添加一个字段，标记数据是否被删除</p></li><li><p>当删除数据时把标记设置为 1，即将删除语句改为更新语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> deleted <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> #&#123;id&#125; <span class="keyword">AND</span> deleted <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询时只查询标记为 0 的数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> deleted <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><p>但如果采用逻辑删除，则 MyBatisPlus 提供的方法将无法实现需求。</p><p>于是，MyBatisPlus 提供了逻辑删除功能，<strong>无需改变方法调用的方式</strong>，而是在底层自动修改 CRUD 语句。</p><p>我们需要做的，就是在 <code>application.properties</code> 文件中<strong>配置逻辑删除的字段名称和值</strong>即可：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局逻辑删除的实体字段名，字段类型可以是Boolean和Integer </span></span><br><span class="line"><span class="attr">mybatis-plus.global-config.db-config.logic-delete-field</span>=<span class="string">flag</span></span><br><span class="line"><span class="comment"># 表明逻辑已删除的值(默认为1)</span></span><br><span class="line"><span class="attr">mybatis-plus.global-config.db-config.logic-delete-value</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 表明逻辑未删除的值(默认为0)</span></span><br><span class="line"><span class="attr">mybatis-plus.global-config.db-config.logic-not-delete-value</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：逻辑删除本身也有自己的问题，比如：</p><ul><li>会导致数据库表垃圾数据越来越多，影响查询效率</li><li>SQL 中全都需要对逻辑删除字段做判断，影响查询效率</li></ul><p>因此，逻辑删除不太推荐，如果实在需要，可以考虑将删除数据迁移到其他表来实现</p></blockquote><h3 id="枚举处理器">枚举处理器</h3><p>在用户实体类中，我们常常会用定义表示 <em>状态</em> 的整数类型的字段，但这样做难以记忆，且不直观，又因为枚举类型可以直接用 <code>==</code> 进行比较，所以我们通过用<strong>枚举类型</strong>来代替整数类型来表示用户状态。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他字段</span></span><br><span class="line">    <span class="keyword">private</span> UserStatus status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户状态枚举类</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserStatus</span> &#123;</span><br><span class="line">    NORMAL(<span class="number">1</span>, <span class="string">&quot;正常&quot;</span>),</span><br><span class="line">    FREEZE(<span class="number">2</span>, <span class="string">&quot;冻结&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line">    </span><br><span class="line">    UserStatus(<span class="type">int</span> value, String description) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做虽然可以直观地表示用户的状态了，但是在将用户实体类插入数据库时又会遇到问题——<strong>枚举类型无法转换为数据库中的表示状态的数据类型</strong>（一般为 int），所以，为了解决这一问题，MyBatisPlus 为我们提供了枚举处理器 <code>MybatisEnumTypeHandler</code> 来实现枚举类型和数据库类型的转换。</p><p>使用步骤：</p><ol><li><p>在枚举类定义中指明与数据库字段值对应的属性，如 <code>UserStatus</code> 类型中 <code>value</code> 属性对应数据库中的 <code>status</code> 值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户状态枚举类</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserStatus</span> &#123;</span><br><span class="line">    NORMAL(<span class="number">1</span>, <span class="string">&quot;正常&quot;</span>),</span><br><span class="line">    FREEZE(<span class="number">2</span>, <span class="string">&quot;冻结&quot;</span>);</span><br><span class="line">    <span class="meta">@EnumValue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line">    </span><br><span class="line">    UserStatus(<span class="type">int</span> value, String description) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使枚举处理器生效</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus.configuration.default-enum-type-handler</span>=<span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>以上配置后，查询返回的值是枚举成员名 NORMAL 或 FREEZE，如果想要返回枚举类中的某个属性的值，则可以在想要返回的属性上加上 <code>@JsonValue</code> 注解，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户状态枚举类</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserStatus</span> &#123;</span><br><span class="line"> NORMAL(<span class="number">1</span>, <span class="string">&quot;正常&quot;</span>),</span><br><span class="line"> FREEZE(<span class="number">2</span>, <span class="string">&quot;冻结&quot;</span>);</span><br><span class="line"> <span class="meta">@EnumValue</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"> <span class="meta">@JsonValue</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line"></span><br><span class="line"> UserStatus(<span class="type">int</span> value, String description) &#123;</span><br><span class="line">     <span class="built_in">this</span>.value = value;</span><br><span class="line">     <span class="built_in">this</span>.description = description;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="JSON-处理器">JSON 处理器</h3><p>数据库数据类型中有 <code>JSON</code> 类型，保存为 <code>JSON</code> 字符串，插入数据时我们只需要将插入的数据声明为 <code>String</code> 类型，``Mybatis<code>会自动将</code>String` 类型转换为 JSON 类型。</p><p>但如果要从数据库中取出 <code>JSON</code> 类型的数据并做业务处理，由于<strong>取出的是字符串而不是一个对象，就要转换为对象才能做业务处理</strong>，十分繁琐，为了解决这个问题，``MyBatisPlus<code>为我们提供了 JSON 处理器</code>AbstractJsonTypeHandler` 抽象类，其有三个子类</p><ul><li><code>GsonTypeHandler</code></li><li><code>JacksonTypeHandler</code>：SpringMVC 底层使用的 JSON 处理器，推荐使用</li><li><code>FastjsonTypeHandler</code></li></ul><p>使用步骤：</p><ol><li><p>在需要从 <code>JSON</code> 转换为对象的属性上加上注解 <code>@TableField(typeHandler = JacksonTypeHandler.class)</code></p></li><li><p>在该属性所属实体类的 <code>@TableName</code> 注解中补充 <code>autoResultMap</code> 属性为<code>true</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;user&quot;, autoResultMap = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@TableField(typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line">    <span class="keyword">private</span> UserInfo info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String intro;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;..&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>如此，即可完成 <code>JSON</code> 到对象的转换</p><h2 id="插件功能">插件功能</h2><h3 id="分页插件">分页插件</h3><p>步骤：</p><ol><li><p>首先，要在配置类中注册 MyBatisPlus 的核心插件，同时添加分页插件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBatisPlusInterceptor <span class="title function_">myBatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.初始化核心插件</span></span><br><span class="line">        <span class="type">MyBatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 2.添加分页插件</span></span><br><span class="line">        <span class="type">PaginationInnerInterceptor</span> <span class="variable">pageInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL);</span><br><span class="line">        pageInterceptor.setMaxLimit(<span class="number">1000L</span>); <span class="comment">// 设置分页上限</span></span><br><span class="line">        interceptor.addInnerInterceptor(pageInterceptor);</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接着，就可以使用分页的 API 了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 分页参数</span></span><br><span class="line">Page&lt;User&gt; page = Page.of(pageNo, pageSize);</span><br><span class="line"><span class="comment">// 排序参数，true升序，false降序</span></span><br><span class="line">page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>().setColumn(sortBy).setAsc(isAsc));</span><br><span class="line"><span class="comment">// 分页查询</span></span><br><span class="line">Page&lt;User&gt; p = userService.page(page);</span><br><span class="line"><span class="comment">// 总条数</span></span><br><span class="line">System.out.println(<span class="string">&quot;total = &quot;</span> + p.getTotal());</span><br><span class="line"><span class="comment">// 总页数</span></span><br><span class="line">System.out.println(<span class="string">&quot;total = &quot;</span> + p.getPages());</span><br><span class="line"><span class="comment">// 分页数据</span></span><br><span class="line">List&lt;User&gt; records = p.getRecords();</span><br><span class="line">records.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li></ol><h3 id="通用分页实体">通用分页实体</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用分页实体</span></span><br><span class="line"><span class="comment">// 其他需要分页查询的实体类继承该类即可完成分页查询</span></span><br><span class="line"><span class="comment">// 可以将</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;分页查询实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;页码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer pageNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;每页条数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer pageSize;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;排序字段&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;是否升序&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer isAsc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以进行如下优化，封装重复的逻辑，提高代码复用性</p><img src="/2025/03/02/MyBatis-Plus-Basic-Usage/image-20240301225257041.png" class="">]]></content>
      
      
      <categories>
          
          <category> Web Server Framework </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MIT The Missing Semester] Lec10: Potpourri</title>
      <link href="/2025/03/02/MIT-The-Missing-Semester-Lec10-Potpourri/"/>
      <url>/2025/03/02/MIT-The-Missing-Semester-Lec10-Potpourri/</url>
      
        <content type="html"><![CDATA[<h1>Lec10：大杂烩</h1><h2 id="目录">目录</h2><ul><li><a href="https://missing-semester-cn.github.io/2020/potpourri/#%E4%BF%AE%E6%94%B9%E9%94%AE%E4%BD%8D%E6%98%A0%E5%B0%84">修改键位映射</a></li><li><a href="https://missing-semester-cn.github.io/2020/potpourri/#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">守护进程</a></li><li><a href="https://missing-semester-cn.github.io/2020/potpourri/#fuse">FUSE</a></li><li><a href="https://missing-semester-cn.github.io/2020/potpourri/#%E5%A4%87%E4%BB%BD">备份</a></li><li><a href="https://missing-semester-cn.github.io/2020/potpourri/#API%EF%BC%88%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3%EF%BC%89">API（应用程序接口）</a></li><li><a href="https://missing-semester-cn.github.io/2020/potpourri/#%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A0%87%E5%BF%97%E5%8F%82%E6%95%B0%E5%8F%8A%E6%A8%A1%E5%BC%8F">常见命令行标志参数及模式</a></li><li><a href="https://missing-semester-cn.github.io/2020/potpourri/#%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%99%A8">窗口管理器</a></li><li><a href="https://missing-semester-cn.github.io/2020/potpourri/#vpn">VPN</a></li><li><a href="https://missing-semester-cn.github.io/2020/potpourri/#markdown">Markdown</a></li><li><a href="https://missing-semester-cn.github.io/2020/potpourri/#Hammerspoon" title="macOS桌面自动化">Hammerspoon (macOS桌面自动化)</a><ul><li><a href="https://missing-semester-cn.github.io/2020/potpourri/#%E8%B5%84%E6%BA%90">资源</a></li></ul></li><li>[开机引导以及 Live USB](<a href="https://missing-semester-cn.github.io/2020/potpourri/#%E5%BC%80%E6%9C%BA%E5%BC%95%E5%AF%BC%E4%BB%A5%E5%8F%8A">https://missing-semester-cn.github.io/2020/potpourri/#开机引导以及</a> Live USB)</li><li><a href="https://missing-semester-cn.github.io/2020/potpourri/#docker-vagrant-vms-cloud-openstack">Docker, Vagrant, VMs, Cloud, OpenStack</a></li><li><a href="https://missing-semester-cn.github.io/2020/potpourri/#%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%AE%B0%E4%BA%8B%E6%9C%AC%E7%BC%96%E7%A8%8B">交互式记事本编程</a></li><li><a href="https://missing-semester-cn.github.io/2020/potpourri/#github">GitHub</a></li></ul><h2 id="修改键位映射">修改键位映射</h2><p>作为一名程序员，键盘是你的主要输入工具。它像计算机里的其他部件一样是可配置的，而且值得你在这上面花时间。</p><p>一个很常见的配置是修改键位映射。通常这个功能由在计算机上运行的软件实现。当某一个按键被按下，软件截获键盘发出的按键事件（keypress event）并使用另外一个事件取代。比如：</p><ul><li>将 Caps Lock 映射为 Ctrl 或者 Escape：Caps Lock 使用了键盘上一个非常方便的位置而它的功能却很少被用到，所以我们（讲师）非常推荐这个修改；</li><li>将 PrtSc 映射为播放/暂停：大部分操作系统支持播放/暂停键；</li><li>交换 Ctrl 和 Meta 键（Windows 的徽标键或者 Mac 的 Command 键）。</li></ul><p>你也可以将键位映射为任意常用的指令。软件监听到特定的按键组合后会运行设定的脚本。</p><ul><li>打开一个新的终端或者浏览器窗口；</li><li>输出特定的字符串，比如：一个超长邮件地址或者 MIT ID；</li><li>使计算机或者显示器进入睡眠模式。</li></ul><p>甚至更复杂的修改也可以通过软件实现：</p><ul><li>映射按键顺序，比如：按 Shift 键五下切换大小写锁定；</li><li>区别映射单点和长按，比如：单点 Caps Lock 映射为 Escape，而长按 Caps Lock 映射为 Ctrl；</li><li>对不同的键盘或软件保存专用的映射配置。</li></ul><p>下面是一些修改键位映射的软件：</p><ul><li>macOS - <a href="https://pqrs.org/osx/karabiner/">karabiner-elements</a>, <a href="https://github.com/koekeishiya/skhd">skhd</a> 或者 <a href="https://folivora.ai/">BetterTouchTool</a></li><li>Linux - <a href="https://wiki.archlinux.org/index.php/Xmodmap">xmodmap</a> 或者 <a href="https://github.com/autokey/autokey">Autokey</a></li><li>Windows - 控制面板，<a href="https://www.autohotkey.com/">AutoHotkey</a> 或者 <a href="https://www.randyrants.com/category/sharpkeys/">SharpKeys</a></li><li>QMK - 如果你的键盘支持定制固件，<a href="https://docs.qmk.fm/">QMK</a> 可以直接在键盘的硬件上修改键位映射。保留在键盘里的映射免除了在别的机器上的重复配置。</li></ul><h2 id="守护进程">守护进程</h2><p>即便守护进程（daemon）这个词看上去有些陌生，你应该已经大约明白它的概念。大部分计算机都有一系列在后台保持运行，不需要用户手动运行或者交互的进程。这些进程就是守护进程。以守护进程运行的程序名一般以 <code>d</code> 结尾，比如 SSH 服务端 <code>sshd</code>，用来监听传入的 SSH 连接请求并对用户进行鉴权。</p><p>Linux 中的 <code>systemd</code>（the system daemon）是最常用的配置和运行守护进程的方法。运行 <code>systemctl status</code> 命令可以看到正在运行的所有守护进程。这里面有很多可能你没有见过，但是掌管了系统的核心部分的进程：管理网络、DNS解析、显示系统的图形界面等等。用户使用 <code>systemctl</code> 命令和 <code>systemd</code> 交互来<code>enable</code>（启用）、<code>disable</code>（禁用）、<code>start</code>（启动）、<code>stop</code>（停止）、<code>restart</code>（重启）、或者<code>status</code>（检查）配置好的守护进程及系统服务。</p><p><code>systemd</code> 提供了一个很方便的界面用于配置和启用新的守护进程或系统服务。下面的配置文件使用了守护进程来运行一个简单的 Python 程序。文件的内容非常直接所以我们不对它详细阐述。<code>systemd</code> 配置文件的详细指南可参见 <a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">freedesktop.org</a>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/systemd/system/myapp.service</span><br><span class="line">[Unit]</span><br><span class="line"># 配置文件描述</span><br><span class="line">Description=My Custom App</span><br><span class="line"># 在网络服务启动后启动该进程</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"># 运行该进程的用户</span><br><span class="line">User=foo</span><br><span class="line"># 运行该进程的用户组</span><br><span class="line">Group=foo</span><br><span class="line"># 运行该进程的根目录</span><br><span class="line">WorkingDirectory=/home/foo/projects/mydaemon</span><br><span class="line"># 开始该进程的命令</span><br><span class="line">ExecStart=/usr/bin/local/python3.7 app.py</span><br><span class="line"># 在出现错误时重启该进程</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"># 相当于Windows的开机启动。即使GUI没有启动，该进程也会加载并运行</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"># 如果该进程仅需要在GUI活动时运行，这里应写作：</span><br><span class="line"># WantedBy=graphical.target</span><br><span class="line"># graphical.target在multi-user.target的基础上运行和GUI相关的服务</span><br></pre></td></tr></table></figure><p>如果你只是想定期运行一些程序，可以直接使用 <a href="https://www.man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a>。它是一个系统内置的，用来执行定期任务的守护进程。</p><h2 id="FUSE">FUSE</h2><p>现在的软件系统一般由很多模块化的组件构建而成。你使用的操作系统可以通过一系列共同的方式使用不同的文件系统上的相似功能。比如当你使用 <code>touch</code> 命令创建文件的时候，<code>touch</code> 使用系统调用（system call）向内核发出请求。内核再根据文件系统，调用特有的方法来创建文件。这里的问题是，UNIX 文件系统在传统上是以内核模块的形式实现，导致只有内核可以进行文件系统相关的调用。</p><p><a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace">FUSE</a>（用户空间文件系统）允许运行在用户空间上的程序实现文件系统调用，并将这些调用与内核接口联系起来。在实践中，这意味着用户可以在文件系统调用中实现任意功能。</p><p>FUSE 可以用于实现如：一个将所有文件系统操作都使用 SSH 转发到远程主机，由远程主机处理后返回结果到本地计算机的虚拟文件系统。这个文件系统里的文件虽然存储在远程主机，对于本地计算机上的软件而言和存储在本地别无二致。<code>sshfs</code>就是一个实现了这种功能的 FUSE 文件系统。</p><p>一些有趣的 FUSE 文件系统包括：</p><ul><li><a href="https://github.com/libfuse/sshfs">sshfs</a>：使用 SSH 连接在本地打开远程主机上的文件</li><li><a href="https://rclone.org/commands/rclone_mount/">rclone</a>：将 Dropbox、Google Drive、Amazon S3、或者 Google Cloud Storage 一类的云存储服务挂载为本地文件系统</li><li><a href="https://nuetzlich.net/gocryptfs/">gocryptfs</a>：覆盖在加密文件上的文件系统。文件以加密形式保存在磁盘里，但该文件系统挂载后用户可以直接从挂载点访问文件的明文</li><li><a href="https://keybase.io/docs/kbfs">kbfs</a>：分布式端到端加密文件系统。在这个文件系统里有私密（private），共享（shared），以及公开（public）三种类型的文件夹</li><li><a href="https://borgbackup.readthedocs.io/en/stable/usage/mount.html">borgbackup</a>：方便用户浏览删除重复数据后的压缩加密备份</li></ul><h2 id="备份">备份</h2><p>任何没有备份的数据都可能在一个瞬间永远消失。复制数据很简单，但是可靠地备份数据很难。下面列举了一些关于备份的基础知识，以及一些常见做法容易掉进的陷阱。</p><p>首先，复制存储在同一个磁盘上的数据不是备份，因为这个磁盘是一个单点故障（single point of failure）。这个磁盘一旦出现问题，所有的数据都可能丢失。放在家里的外置磁盘因为火灾、抢劫等原因可能会和源数据一起丢失，所以是一个弱备份。推荐的做法是将数据备份到不同的地点存储。</p><p>同步方案也不是备份。即使方便如 Dropbox 或者 Google Drive，当数据在本地被抹除或者损坏，同步方案可能会把这些“更改”同步到云端。同理，像 RAID 这样的磁盘镜像方案也不是备份。它不能防止文件被意外删除、损坏、或者被勒索软件加密。</p><p>有效备份方案的几个核心特性是：版本控制，删除重复数据，以及安全性。对备份的数据实施版本控制保证了用户可以从任何记录过的历史版本中恢复数据。在备份中检测并删除重复数据，使其仅备份增量变化可以减少存储开销。在安全性方面，作为用户，你应该考虑别人需要有什么信息或者工具才可以访问或者完全删除你的数据及备份。最后一点，不要盲目信任备份方案。用户应该经常检查备份是否可以用来恢复数据。</p><p>备份不限制于备份在本地计算机上的文件。云端应用的重大发展使得我们很多的数据只存储在云端。当我们无法登录这些应用，在云端存储的网络邮件，社交网络上的照片，流媒体音乐播放列表，以及在线文档等等都会随之丢失。用户应该有这些数据的离线备份，而且已经有项目可以帮助下载并存储它们。</p><p>如果想要了解更多具体内容，请参考本课程2019年关于备份的<a href="https://missing-semester-cn.github.io/2019/backups">课堂笔记</a>。</p><h2 id="API（应用程序接口）">API（应用程序接口）</h2><p>关于如何使用计算机有效率地完成 <em>本地</em> 任务，我们这堂课已经介绍了很多方法。这些方法在互联网上其实也适用。大多数线上服务提供的 API（应用程序接口）让你可以通过编程方式来访问这些服务的数据。比如，美国国家气象局就提供了一个可以从 shell 中获取天气预报的 API。</p><p>这些 API 大多具有类似的格式。它们的结构化 URL 通常使用 <code>api.service.com</code> 作为根路径，用户可以访问不同的子路径来访问需要调用的操作，以及添加查询参数使 API 返回符合查询参数条件的结果。</p><p>以美国天气数据为例，为了获得某个地点的天气数据，你可以发送一个 GET 请求（比如使用 <code>curl</code>）到<a href="https://api.weather.gov/points/42.3604,-71.094"><code>https://api.weather.gov/points/42.3604,-71.094</code></a>。返回中会包括一系列用于获取特定信息（比如小时预报、气象观察站信息等）的 URL。通常这些返回都是<code>JSON</code>格式，你可以使用<a href="https://stedolan.github.io/jq/"><code>jq</code></a>等工具来选取需要的部分。</p><p>有些需要认证的 API 通常要求用户在请求中加入某种私密令牌（secret token）来完成认证。请阅读你想访问的 API 所提供的文档来确定它请求的认证方式，但是其实大多数 API 都会使用 <a href="https://www.oauth.com/">OAuth</a>。OAuth 通过向用户提供一系列仅可用于该 API 特定功能的私密令牌进行校验。因为使用了有效 OAuth 令牌的请求在 API 看来就是用户本人发出的请求，所以请一定保管好这些私密令牌。否则其他人就可以冒用你的身份进行任何你可以在这个 API 上进行的操作。</p><p><a href="https://ifttt.com/">IFTTT</a> 这个网站可以将很多 API 整合在一起，让某 API 发生的特定事件触发在其他 API 上执行的任务。IFTTT 的全称If This Then That 足以说明它的用法，比如在检测到用户的新推文后，自动发布在其他平台。但是你可以对它支持的 API 进行任意整合，所以试着来设置一下任何你需要的功能吧！</p><h2 id="常见命令行标志参数及模式">常见命令行标志参数及模式</h2><p>命令行工具的用法千差万别，阅读 <code>man</code> 页面可以帮助你理解每种工具的用法。即便如此，下面我们将介绍一下命令行工具一些常见的共同功能。</p><ul><li><p>大部分工具支持 <code>--help</code> 或者类似的标志参数（flag）来显示它们的简略用法。</p></li><li><p>会造成不可撤回操作的工具一般会提供“空运行”（dry run）标志参数，这样用户可以确认工具真实运行时会进行的操作。这些工具通常也会有“交互式”（interactive）标志参数，在执行每个不可撤回的操作前提示用户确认。</p></li><li><p><code>--version</code> 或者 <code>-V</code> 标志参数可以让工具显示它的版本信息（对于提交软件问题报告非常重要）。</p></li><li><p>基本所有的工具支持使用 <code>--verbose</code> 或者 <code>-v</code> 标志参数来输出详细的运行信息。多次使用这个标志参数，比如 <code>-vvv</code>，可以让工具输出更详细的信息（经常用于调试）。同样，很多工具支持 <code>--quiet</code> 标志参数来抑制除错误提示之外的其他输出。</p></li><li><p>大多数工具中，使用 <code>-</code> 代替输入或者输出文件名意味着工具将从标准输入（standard input）获取所需内容，或者向标准输出（standard output）输出结果。</p></li><li><p>会造成破坏性结果的工具一般默认进行非递归的操作，但是支持使用 “递归”（recursive）标志函数（通常是 <code>-r</code>）。</p></li><li><p>有的时候你可能需要向工具传入一个看上去像标志参数的普通参数，比如：</p><ul><li>使用 <code>rm</code> 删除一个叫 <code>-r</code> 的文件；</li><li>在通过一个程序运行另一个程序的时候（<code>ssh machine foo</code>），向内层的程序（<code>foo</code>）传递一个标志参数。</li></ul><p>这时候你可以使用特殊参数 <code>--</code> 让某个程序 <em>停止处理</em> <code>--</code> 后面出现的标志参数以及选项（以 <code>-</code> 开头的内容）：</p><ul><li><code>rm -- -r</code> 会让 <code>rm</code> 将 <code>-r</code> 当作文件名；</li><li><code>ssh machine --for-ssh -- foo --for-foo</code> 的 <code>--</code> 会让 <code>ssh</code> 知道 <code>--for-foo</code> 不是 <code>ssh</code> 的标志参数。</li></ul></li></ul><h2 id="窗口管理器">窗口管理器</h2><p>大部分人适应了 Windows、macOS、以及 Ubuntu 默认的“拖拽”式窗口管理器。这些窗口管理器的窗口一般就堆在屏幕上，你可以拖拽改变窗口的位置、缩放窗口、以及让窗口堆叠在一起。这种堆叠式（floating/stacking）管理器只是窗口管理器中的一种。特别在 Linux 中，有很多种其他的管理器。</p><p>平铺式（tiling）管理器就是一个常见的替代。顾名思义，平铺式管理器会把不同的窗口像贴瓷砖一样平铺在一起而不和其他窗口重叠。这和 <a href="https://github.com/tmux/tmux">tmux</a> 管理终端窗口的方式类似。平铺式管理器按照写好的布局显示打开的窗口。如果只打开一个窗口，它会填满整个屏幕。新开一个窗口的时候，原来的窗口会缩小到比如三分之二或者三分之一的大小来腾出空间。打开更多的窗口会让已有的窗口进一步调整。</p><p>就像 tmux 那样，平铺式管理器可以让你在完全不使用鼠标的情况下使用键盘切换、缩放、以及移动窗口。它们值得一试！</p><h2 id="VPN">VPN</h2><p>VPN 现在非常火，但我们不清楚这是不是因为<a href="https://gist.github.com/joepie91/5a9909939e6ce7d09e29">一些好的理由</a>。你应该了解 VPN 能提供的功能和它的限制。使用了 VPN 的你对于互联网而言，<strong>最好的情况</strong>下也就是换了一个网络供应商（ISP）。所有你发出的流量看上去来源于 VPN 供应商的网络而不是你的“真实”地址，而你实际接入的网络只能看到加密的流量。</p><p>虽然这听上去非常诱人，但是你应该知道使用 VPN 只是把原本对网络供应商的信任放在了 VPN 供应商那里——网络供应商 <em>能看到的</em>，VPN 供应商 <em>也都能看到</em>。如果相比网络供应商你更信任 VPN 供应商，那当然很好。反之，则连接VPN的价值不明确。机场的不加密公共热点确实不可以信任，但是在家庭网络环境里，这个差异就没有那么明显。</p><p>你也应该了解现在大部分包含用户敏感信息的流量已经被 HTTPS 或者 TLS 加密。这种情况下你所处的网络环境是否“安全”不太重要：供应商只能看到你和哪些服务器在交谈，却不能看到你们交谈的内容。</p><p>这一切的大前提都是“最好的情况”。曾经发生过 VPN 提供商错误使用弱加密或者直接禁用加密的先例。另外，有些恶意的或者带有投机心态的供应商会记录和你有关的所有流量，并很可能会将这些信息卖给第三方。找错一家 VPN 经常比一开始就不用 VPN 更危险。</p><p>MIT 向有访问校内资源需求的成员开放自己运营的 <a href="https://ist.mit.edu/vpn">VPN</a>。如果你也想自己配置一个 VPN，可以了解一下 <a href="https://www.wireguard.com/">WireGuard</a> 以及 <a href="https://github.com/trailofbits/algo">Algo</a>。</p><h2 id="Markdown">Markdown</h2><p>你在职业生涯中大概率会编写各种各样的文档。在很多情况下这些文档需要使用标记来增加可读性，比如：插入粗体或者斜体内容，增加页眉、超链接、以及代码片段。</p><p>在不使用 Word 或者 LaTeX 等复杂工具的情况下，你可以考虑使用 <a href="https://commonmark.org/help/">Markdown</a> 这个轻量化的标记语言（markup language）。你可能已经见过 Markdown 或者它的一个变种。很多环境都支持并使用 Markdown 的一些子功能。</p><p>Markdown 致力于将人们编写纯文本时的一些习惯标准化。比如：</p><ul><li><p>用 <code>*</code> 包围的文字表示强调（<em>斜体</em>），或者用 <code>**</code> 表示特别强调（<strong>粗体</strong>）；</p></li><li><p>以 <code>#</code> 开头的行是标题，<code>#</code> 的数量表示标题的级别，比如：<code>##二级标题</code>；</p></li><li><p>以 <code>-</code> 开头代表一个无序列表的元素。一个数字加 <code>.</code>（比如 <code>1.</code> ）代表一个有序列表元素；</p></li><li><p>反引号 ```（backtick）包围的文字会以` 代码字体显示。如果要显示一段代码，可以在每一行前加四个空格缩进，或者使用三个反引号包围整个代码片段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">就像这样</span><br></pre></td></tr></table></figure></li><li><p>如果要添加超链接，将 <em>需要显示</em> 的文字用方括号包围，并在后面紧接着用圆括号包围链接：<code>[显示文字](指向的链接)</code>。</p></li></ul><p>Markdown 不仅容易上手，而且应用非常广泛。实际上本课程的课堂笔记和其他资料都是使用 Markdown 编写的。点击<a href="https://github.com/missing-semester-cn/missing-semester-cn.github.io/blob/master/_2020/potpourri.md">这个链接</a>可以看到本页面的原始 Markdown 内容。</p><h2 id="Hammerspoon-macOS-桌面自动化">Hammerspoon (macOS 桌面自动化)</h2><p><a href="https://www.hammerspoon.org/">Hammerspoon</a> 是面向 macOS 的一个桌面自动化框架。它允许用户编写和操作系统功能挂钩的 Lua 脚本，从而与键盘、鼠标、窗口、文件系统等交互。</p><p>下面是 Hammerspoon 的一些示例应用：</p><ul><li>绑定移动窗口到的特定位置的快捷键</li><li>创建可以自动将窗口整理成特定布局的菜单栏按钮</li><li>在你到实验室以后，通过检测所连接的 WiFi 网络自动静音扬声器</li><li>在你不小心拿了朋友的充电器时弹出警告</li></ul><p>从用户的角度，Hammerspoon 可以运行任意 Lua 代码，绑定菜单栏按钮、按键、或者事件。Hammerspoon 提供了一个全面的用于和系统交互的库，因此它能没有限制地实现任何功能。你可以从头编写自己的 Hammerspoon 配置，也可以结合别人公布的配置来满足自己的需求。</p><h3 id="资源">资源</h3><ul><li><a href="https://www.hammerspoon.org/go/">Getting Started with Hammerspoon</a>：Hammerspoon 官方教程</li><li><a href="https://github.com/Hammerspoon/hammerspoon/wiki/Sample-Configurations">Sample configurations</a>：Hammerspoon 官方示例配置</li><li><a href="https://github.com/anishathalye/dotfiles-local/tree/mac/hammerspoon">Anish’s Hammerspoon config</a>：Anish 的 Hammerspoon 配置</li></ul><h2 id="开机引导以及-Live-USB">开机引导以及 Live USB</h2><p>在你的计算机启动时，<a href="https://en.wikipedia.org/wiki/BIOS">BIOS</a> 或者 <a href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a> 会在加载操作系统之前对硬件系统进行初始化，这被称为引导（booting）。你可以通过按下计算机提示的键位组合来配置引导，比如 <code>Press F9 to configure BIOS. Press F12 to enter boot menu</code>。在 BIOS 菜单中你可以对硬件相关的设置进行更改，也可以在引导菜单中选择从硬盘以外的其他设备加载操作系统——比如 Live USB。</p><p><a href="https://en.wikipedia.org/wiki/Live_USB">Live USB</a> 是包含了完整操作系统的闪存盘。Live USB 的用途非常广泛，包括：</p><ul><li>作为安装操作系统的启动盘；</li><li>在不将操作系统安装到硬盘的情况下，直接运行 Live USB 上的操作系统；</li><li>对硬盘上的相同操作系统进行修复；</li><li>恢复硬盘上的数据。</li></ul><p>Live USB 通过在闪存盘上 <em>写入</em> 操作系统的镜像制作，而写入不是单纯的往闪存盘上复制 <code>.iso</code> 文件。你可以使用 <a href="https://unetbootin.github.io/">UNetbootin</a> 、<a href="https://github.com/pbatard/rufus">Rufus</a> 等 Live USB 写入工具制作。</p><h2 id="Docker-Vagrant-VMs-Cloud-OpenStack">Docker, Vagrant, VMs, Cloud, OpenStack</h2><p><a href="https://en.wikipedia.org/wiki/Virtual_machine">虚拟机</a>（Virtual Machine）以及容器化（containerization）等工具可以帮助你模拟一个包括操作系统的完整计算机系统。虚拟机可以用于创建独立的测试或者开发环境，以及用作安全测试的沙盒。</p><p><a href="https://www.vagrantup.com/">Vagrant</a> 是一个构建和配置虚拟开发环境的工具。它支持用户在配置文件中写入比如操作系统、系统服务、需要安装的软件包等描述，然后使用 <code>vagrant up</code> 命令在各种环境（VirtualBox，KVM，Hyper-V等）中启动一个虚拟机。<a href="https://www.docker.com/">Docker</a> 是一个使用容器化概念的类似工具。</p><p>租用云端虚拟机可以享受以下资源的即时访问：</p><ul><li>便宜、常开、且有公共IP地址的虚拟机用来托管网站等服务</li><li>有大量 CPU、磁盘、内存、以及 GPU 资源的虚拟机</li><li>超出用户可以使用的物理主机数量的虚拟机<ul><li>相比物理主机的固定开支，虚拟机的开支一般按运行的时间计算。所以如果用户只需要在短时间内使用大量算力，租用1000台虚拟机运行几分钟明显更加划算。</li></ul></li></ul><p>受欢迎的 VPS 服务商有 <a href="https://aws.amazon.com/">Amazon AWS</a>，<a href="https://cloud.google.com/">Google Cloud</a>、<a href="https://azure.microsoft.com/"> Microsoft Azure</a>以及<a href="https://www.digitalocean.com/">DigitalOcean</a>。</p><p>MIT CSAIL 的成员可以使用 <a href="https://tig.csail.mit.edu/shared-computing/open-stack/">CSAIL OpenStack instance</a> 申请免费的虚拟机用于研究。</p><h2 id="交互式记事本编程">交互式记事本编程</h2><p><a href="https://en.wikipedia.org/wiki/Notebook_interface">交互式记事本</a>可以帮助开发者进行与运行结果交互等探索性的编程。现在最受欢迎的交互式记事本环境大概是 <a href="https://jupyter.org/">Jupyter</a>。它的名字来源于所支持的三种核心语言：Julia、Python、R。<a href="https://www.wolfram.com/mathematica/">Wolfram Mathematica</a> 是另外一个常用于科学计算的优秀环境。</p><h2 id="GitHub">GitHub</h2><p><a href="https://github.com/">GitHub</a> 是最受欢迎的开源软件开发平台之一。我们课程中提到的很多工具，从 <a href="https://github.com/vim/vim">vim</a> 到 <a href="https://github.com/Hammerspoon/hammerspoon">Hammerspoon</a>，都托管在 Github 上。向你每天使用的开源工具作出贡献其实很简单，下面是两种贡献者们经常使用的方法：</p><ul><li>创建一个<a href="https://help.github.com/en/github/managing-your-work-on-github/creating-an-issue">议题（issue）</a>。 议题可以用来反映软件运行的问题或者请求新的功能。创建议题并不需要创建者阅读或者编写代码，所以它是一个轻量化的贡献方式。高质量的问题报告对于开发者十分重要。在现有的议题发表评论也可以对项目的开发作出贡献。</li><li>使用<a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">拉取请求（pull request）</a>提交代码更改。由于涉及到阅读和编写代码，提交拉取请求总的来说比创建议题更加深入。拉取请求是请求别人把你自己的代码拉取（且合并）到他们的仓库里。很多开源项目仅允许认证的管理者管理项目代码，所以一般需要<a href="https://help.github.com/en/github/getting-started-with-github/fork-a-repo">复刻（fork）</a>这些项目的上游仓库（upstream repository），在你的 Github 账号下创建一个内容完全相同但是由你控制的复刻仓库。这样你就可以在这个复刻仓库自由创建新的分支并推送修复问题或者实现新功能的代码。完成修改以后再回到开源项目的 Github 页面<a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request">创建一个拉取请求</a>。</li></ul><p>提交请求后，项目管理者会和你交流拉取请求里的代码并给出反馈。如果没有问题，你的代码会和上游仓库中的代码合并。很多大的开源项目会提供贡献指南，容易上手的议题，甚至专门的指导项目来帮助参与者熟悉这些项目。</p>]]></content>
      
      
      <categories>
          
          <category> The Missing Semester </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[MIT The Missing Semester] Lec09: Security and Cryptography</title>
      <link href="/2025/03/02/MIT-The-Missing-Semester-Lec09-Security-and-Cryptography/"/>
      <url>/2025/03/02/MIT-The-Missing-Semester-Lec09-Security-and-Cryptography/</url>
      
        <content type="html"><![CDATA[<p>本 Lec 的主要内容：</p><ul><li>熵</li><li>散列函数</li><li>密钥生成函数</li><li>对称加密</li><li>非对称加密</li><li>安全与密码学的应用案例</li></ul><p>这节课将对一些基本的概念进行简单（但实用）的说明。 虽然这些说明不足以让你学会如何 <em>设计</em> 安全系统或者加密协议，但我们希望你可以对现在使用的程序和协议有一个大概了解。</p><h2 id="熵">熵</h2><p><a href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">熵</a>（Entropy）度量了<strong>不确定性</strong>并可以用来决定密码的强度。</p><p>熵的单位是 <em>比特</em>。对于一个均匀分布的随机离散变量，熵等于 <code>log_2(所有可能的个数，即n)</code>。 扔一次硬币的熵是1比特。掷一次（六面）骰子的熵大约为 2.58 比特。</p><p>一般我们认为攻击者了解密码的模型（最小长度，最大长度，可能包含的字符种类等），但是不了解某个密码是如何随机选择的—— 比如 <a href="https://en.wikipedia.org/wiki/Diceware">掷骰子</a>。</p><p>使用多少比特的熵取决于应用的<strong>威胁模型</strong>。 大约40比特的熵足以对抗在线穷举攻击（受限于网络速度和应用认证机制）。 而对于离线穷举攻击（主要受限于计算速度）, 一般需要更强的密码 (比如80比特或更多)。</p><h2 id="散列函数">散列函数</h2><h3 id="基本概念的性质">基本概念的性质</h3><p><a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">密码散列函数</a>（Cryptographic hash function）可以<strong>将任意大小的数据映射为一个固定大小的输出</strong>。除此之外，还有一些其他特性。 一个散列函数的大概规范如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hash(value: array&lt;byte&gt;) -&gt; vector&lt;byte, N&gt;  (N对于该函数固定)</span><br></pre></td></tr></table></figure><p><a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a> 是 Git 中使用的一种散列函数， 它可以将<strong>任意大小的输入映射为一个 160 比特</strong>（可被 40 位十六进制数表示）的输出。 下面我们用 <code>sha1sum</code> 命令来测试 SHA1 对几个字符串的输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">printf</span> <span class="string">&#x27;hello&#x27;</span> | <span class="built_in">sha1sum</span></span><br><span class="line">aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d</span><br><span class="line">$ <span class="built_in">printf</span> <span class="string">&#x27;hello&#x27;</span> | <span class="built_in">sha1sum</span></span><br><span class="line">aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d</span><br><span class="line">$ <span class="built_in">printf</span> <span class="string">&#x27;Hello&#x27;</span> | <span class="built_in">sha1sum</span> </span><br><span class="line">f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0</span><br></pre></td></tr></table></figure><p>抽象地讲，散列函数可以<strong>被认为</strong>是一个 <em>不可逆，且看上去随机</em>（但具确定性）的函数 （这就是<a href="https://en.wikipedia.org/wiki/Random_oracle">散列函数的理想模型</a>）。 一个散列函数拥有以下特性：</p><ul><li><strong>确定性</strong>：对于不变的输入永远有相同的输出。</li><li><strong>不可逆性</strong>：对于 <code>hash(m) = h</code>，难以通过已知的输出 <code>h</code> 来计算出原始输入 <code>m</code>。</li><li><strong>目标碰撞抵抗性/弱无碰撞</strong>：对于一个给定输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">m_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，难以找到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mn>2</mn></msub><mo mathvariant="normal">≠</mo><msub><mi>m</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">m_2 \neq m_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><msub><mi>m</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><msub><mi>m</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">hash(m_1)=hash(m_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li><li>碰撞抵抗性/强无碰撞：难以找到一组满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><msub><mi>m</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><msub><mi>m</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">hash(m_1)=hash(m_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">m_1, m_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（该性质严格强于目标碰撞抵抗性）。</li></ul><blockquote><p>注：虽然 SHA-1 还可以用于特定用途，但它已经 <strong><a href="https://shattered.io/">不再被认为</a></strong> 是一个强密码散列函数。 你可参照 <a href="https://valerieaurora.org/hash.html">密码散列函数的生命周期</a> 这个表格了解一些散列函数是何时被发现弱点及破解的。 请注意，针对应用推荐特定的散列函数超出了本课程内容的范畴。 如果选择散列函数对于你的工作非常重要，请先系统学习信息安全及密码学。</p></blockquote><h3 id="密码散列函数的应用">密码散列函数的应用</h3><ul><li><p>Git 中的<strong>内容寻址存储</strong>（Content-addressed storage）：<a href="https://en.wikipedia.org/wiki/Hash_function">散列函数</a> 是一个宽泛的概念（存在非密码学的散列函数），那么 Git 为什么要特意使用密码散列函数？</p></li><li><p>文件的<strong>信息摘要</strong>（Message digest）：像 Linux ISO 这样的软件可以从非官方的（有时不太可信的）镜像站下载，所以需要设法确认下载的软件和官方一致。 官方网站一般会在（指向镜像站的）下载链接旁边备注安装文件的哈希值。 用户从镜像站下载安装文件后可以对照公布的哈希值来确定安装文件没有被篡改。</p><blockquote><p>类似于文件签名。</p></blockquote></li><li><p><a href="https://en.wikipedia.org/wiki/Commitment_scheme">承诺机制</a>（Commitment scheme）： 假设我希望承诺一个值，但之后再透露它 —— 比如在没有一个可信的、双方可见的硬币的情况下在我的脑海中公平的 “扔一次硬币”。 我可以<strong>选择一个值 <code>r = random()</code>，并和你分享它的哈希值 <code>h = sha256(r)</code></strong>。 这时你可以开始猜硬币的正反：我们一致同意偶数 <code>r</code> 代表正面，奇数 <code>r</code> 代表反面。 你猜完了以后，我告诉你值 <code>r</code> 的内容，得出胜负。同时你可以使用 <code>sha256(r)</code> 来检查我分享的哈希值 <code>h</code> 以确认我没有作弊。</p><blockquote><p>在双方互不可信的情景下，寻求一种可信的中间商作为双方之间信任的保证者，双方都信任第三方，从而间接实现双方互相信任。</p></blockquote></li></ul><h2 id="密钥生成函数">密钥生成函数</h2><h3 id="基本概念">基本概念</h3><p><a href="https://en.wikipedia.org/wiki/Key_derivation_function">密钥生成函数</a>（Key Derivation Functions）作为密码散列函数的相关概念，被应用于包括生成固定长度，可以使用在其他密码算法中的密钥等方面。 <strong>为了对抗穷举法攻击，密钥生成函数通常较慢</strong>。</p><h3 id="应用">应用</h3><ul><li>生成可以在其他加密算法中使用的密钥，比如对称加密算法（见下）。</li><li>存储登录凭证时不可直接存储明文密码。正确的方法是针对每个用户随机生成一个 <a href="https://en.wikipedia.org/wiki/Salt_(cryptography)">盐</a> <code>salt = random()</code> 并存储，然后密钥生成函数对<strong>连接了盐的明文密码</strong>生成某个哈希值 <code>KDF(password + salt)</code>。在验证登录请求时，使用输入的密码连接存储的盐重新计算哈希值 <code>KDF(input + salt)</code>，并与存储的哈希值对比。</li></ul><h2 id="对称加密">对称加密</h2><p>说到加密，可能你会首先想到隐藏明文信息。对称加密使用以下几个方法来实现这个功能：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keygen() -&gt; key  (这是一个随机方法)（密钥生成函数）</span><br><span class="line"></span><br><span class="line">encrypt(plaintext: array&lt;byte&gt;, key) -&gt; array&lt;byte&gt;  (输出密文)</span><br><span class="line">decrypt(ciphertext: array&lt;byte&gt;, key) -&gt; array&lt;byte&gt;  (输出明文)</span><br></pre></td></tr></table></figure><p>加密方法 <code>encrypt()</code> 输出的密文 <code>ciphertext</code> 很难在不知道 <code>key</code> 的情况下得出明文 <code>plaintext</code>。</p><p>解密方法 <code>decrypt()</code> 有明显的正确性。因为功能要求给定密文及其密钥，解密方法必须输出明文：<code>decrypt(encrypt(m, k), k) = m</code>。</p><p><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> 是现在常用的一种对称加密系统。</p><h3 id="对称加密的应用">对称加密的应用</h3><p><strong>加密不信任的云服务上存储的文件</strong>。对称加密和密钥生成函数配合起来，就可以使用密码加密文件： 将密码输入密钥生成函数生成密钥 <code>key = KDF(passphrase)</code>，然后存储 <code>encrypt(file, key)</code>。</p><h2 id="非对称加密">非对称加密</h2><p>非对称加密的 <strong>“非对称”</strong> 代表在其环境中，<strong>使用两个具有不同功能的密钥</strong>： 一个是私钥(private key)，不向外公布；另一个是公钥(public key)，公布公钥不像公布对称加密的共享密钥那样可能影响加密体系的安全性。</p><p>非对称加密使用以下几个方法来实现加密 / 解密（encrypt / decrypt），以及签名 / 验证（sign / verify）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keygen() -&gt; (public key, private key)  (这是一个随机方法)</span><br><span class="line"></span><br><span class="line">encrypt(plaintext: array&lt;byte&gt;, public key) -&gt; array&lt;byte&gt;  (输出密文)</span><br><span class="line">decrypt(ciphertext: array&lt;byte&gt;, private key) -&gt; array&lt;byte&gt;  (输出明文)</span><br><span class="line"></span><br><span class="line">sign(message: array&lt;byte&gt;, private key) -&gt; array&lt;byte&gt;  (生成签名)</span><br><span class="line">verify(message: array&lt;byte&gt;, signature: array&lt;byte&gt;, public key) -&gt; bool  (验证签名是否是由和这个公钥相关的私钥生成的)</span><br></pre></td></tr></table></figure><p>非对称的加密 / 解密方法和对称的加密 / 解密方法有类似的特征。</p><p>信息在非对称加密中使用 <em>公钥</em>  加密， 且输出的密文很难在不知道 <em>私钥</em>  的情况下得出明文。解密方法 <code>decrypt()</code> 有明显的正确性。 给定密文及私钥，解密方法一定会输出明文： <code>decrypt(encrypt(m, public key), private key) = m</code>。</p><blockquote><p>对称加密和非对称加密可以类比为<strong>机械锁</strong>。 <strong>对称加密就好比一个防盗门</strong>：只要是有钥匙的人都可以开门或者锁门。 <strong>非对称加密好比一个可以拿下来的挂锁</strong>。你可以把打开状态的挂锁（公钥）给任何一个人并保留唯一的钥匙（私钥）。这样他们将给你的信息装进盒子里并用这个挂锁锁上以后，只有你可以用保留的钥匙开锁。</p></blockquote><p>签名/验证方法具有和书面签名类似的特征。</p><p>在不知道 <em>私钥</em>  的情况下，不管需要签名的信息为何，很难计算出一个可以使 <code>verify(message, signature, public key)</code> 返回为真的签名。对于使用私钥签名的信息，验证方法验证和私钥相对应的公钥时一定返回为真：  <code>verify(message, sign(message, private key), public key) = true</code>。</p><h3 id="非对称加密的应用">非对称加密的应用</h3><ul><li><a href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy">PGP电子邮件加密</a>：用户可以将所使用的公钥在线发布，比如：PGP密钥服务器或 <a href="https://keybase.io/">Keybase</a>。任何人都可以向他们发送加密的电子邮件。</li><li>聊天加密：像 <a href="https://signal.org/">Signal</a> 和 <a href="https://keybase.io/">Keybase</a> 使用非对称密钥来建立私密聊天。</li><li>软件签名：Git 支持用户对提交(commit)和标签(tag)进行GPG签名。任何人都可以使用软件开发者公布的签名公钥验证下载的已签名软件。</li></ul><h3 id="密钥分发">密钥分发</h3><p><strong>非对称加密面对的主要挑战是，如何分发公钥并对应现实世界中存在的人或组织。</strong></p><p><strong>Signal 的信任模型</strong>是，信任用户第一次使用时给出的身份（trust on first use），同时支持用户线下（out-of-band）、面对面交换公钥（Signal 里的 safety number）。</p><p>PGP使用的是 <a href="https://en.wikipedia.org/wiki/Web_of_trust">信任网络</a>。简单来说，如果我想加入一个信任网络，则必须让已经在信任网络中的成员对我进行线下验证，比如对比证件。验证无误后，<strong>信任网络的成员使用私钥对我的公钥进行签名</strong>。这样我就成为了信任网络的一部分。只要我使用签名过的公钥所对应的私钥就可以证明 “我是我”。</p><p>Keybase主要使用 <a href="https://keybase.io/blog/chat-apps-softer-than-tofu">社交网络证明 (social proof)</a>，和一些别的精巧设计。</p><p>每个信任模型有它们各自的优点：我们（讲师）更倾向于 Keybase 使用的模型。</p><h2 id="应用案例分析">应用案例分析</h2><h3 id="密码管理器">密码管理器</h3><p>每个人都应该尝试使用密码管理器，比如 <a href="https://keepassxc.org/">KeePassXC</a>、<a href="https://www.passwordstore.org/">pass</a> 和 <a href="https://1password.com/">1Password</a>。</p><p>密码管理器会帮助你对每个网站生成随机且复杂（表现为高熵）的密码，<strong>并使用你指定的主密码配合密钥生成函数来对称加密它们。</strong></p><p><strong>你只需要记住一个复杂的主密码，密码管理器就可以生成很多复杂度高且不会重复使用的密码</strong>。密码管理器通过这种方式降低密码被猜出的可能，并减少网站信息泄露后对其他网站密码的威胁。</p><h3 id="两步验证（双因子验证）">两步验证（双因子验证）</h3><p><a href="https://en.wikipedia.org/wiki/Multi-factor_authentication">两步验证</a>（2FA）要求用户同时使用密码（<strong>“你知道的信息”</strong>）和一个身份验证器（<strong>“你拥有的物品”</strong>，比如 <a href="https://www.yubico.com/">YubiKey</a>）来消除密码泄露或者<a href="https://en.wikipedia.org/wiki/Phishing">钓鱼攻击</a>的威胁。</p><h3 id="全盘加密">全盘加密</h3><p>对笔记本电脑的硬盘进行全盘加密是防止因设备丢失而信息泄露的简单且有效方法。 Linux 的 <a href="https://wiki.archlinux.org/index.php/Dm-crypt/Encrypting_a_non-root_file_system">cryptsetup + LUKS</a>， Windows的 <a href="https://fossbytes.com/enable-full-disk-encryption-windows-10/">BitLocker</a>，或者macOS的 <a href="https://support.apple.com/en-us/HT204837">FileVault</a> 都使用一个由密码保护的对称密钥来加密盘上的所有信息。</p><h3 id="聊天加密">聊天加密</h3><p><a href="https://signal.org/">Signal</a> 和 <a href="https://keybase.io/">Keybase </a>使用非对称加密对用户提供端到端（End-to-end）安全性。</p><p><strong>获取联系人的公钥非常关键</strong>。为了保证安全性，应使用线下方式验证 Signal 或者 Keybase 的用户公钥，或者信任 Keybase 用户提供的社交网络证明。</p><h3 id="SSH">SSH</h3><p>我们在<a href="https://missing-semester-cn.github.io/2020/command-line/#remote-machines">之前的一堂课</a>讨论了 SSH 和 SSH 密钥的使用。那么我们今天从密码学的角度来分析一下它们。</p><p>当你运行 <code>ssh-keygen</code> 命令，它会生成一个<strong>非对称</strong>密钥对：公钥和私钥 <code>(public_key, private_key)</code>。 生成过程中使用的随机数由系统提供的熵决定。这些熵可以来源于硬件事件（hardware events）等。 <strong>公钥最终会被分发，它可以直接明文存储。 但是为了防止泄露，私钥必须加密存储</strong>。<code>ssh-keygen</code> 命令会提示用户输入一个<strong>密码</strong>，并将它输入 <em>密钥生成函数</em>  产生一个密钥。最终，<code>ssh-keygen</code> 使用<strong>对称加密算法</strong>和<strong>这个密钥</strong>加密私钥。</p><p>在实际运用中，当服务器已知用户的公钥（存储在 <code>.ssh/authorized_keys</code> 文件中，一般在用户 HOME 目录下），尝试连接的客户端可以使用<strong>非对称签名</strong>来证明用户的身份 —— 这便是 <strong><a href="https://en.wikipedia.org/wiki/Challenge%E2%80%93response_authentication">挑战应答方式</a></strong>。</p><p>简单来说，服务器选择一个随机数字发送给客户端。客户端使用用户私钥对这个数字信息签名后返回服务器。 服务器随后使用 <code>.ssh/authorized_keys</code> 文件中存储的用户公钥来验证返回的信息是否由所对应的私钥所签名。这种验证方式可以有效<strong>证明试图登录的用户持有所需的私钥</strong>。</p><blockquote><p>密钥生成：非对称加密生成公私钥，公钥分发，私钥经过对称加密再次加密。</p><p>密钥验证：挑战应答。通过验证用户是否持有公钥对应的私钥来验证用户身份。</p></blockquote><h2 id="资源">资源</h2><ul><li><a href="https://missing-semester-cn.github.io/2019/security/">去年的讲稿</a>：更注重于计算机用户可以如何增强隐私保护和安全</li><li><a href="https://latacora.micro.blog/2018/04/03/cryptographic-right-answers.html">Cryptographic Right Answers</a>：解答了在一些应用环境下 “应该使用什么加密？” 的问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> The Missing Semester </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MIT The Missing Semester] Lec08: Meta Programming</title>
      <link href="/2025/03/02/MIT-The-Missing-Semester-Lec08-Meta-Programming/"/>
      <url>/2025/03/02/MIT-The-Missing-Semester-Lec08-Meta-Programming/</url>
      
        <content type="html"><![CDATA[<h1>Lec08：元编程</h1><p>本 Lec 的主要内容：</p><ul><li>介绍什么是构建系统</li><li>介绍依赖管理、语义版本号和锁文件</li><li>介绍持续集成系统（CI）</li><li>介绍测试</li></ul><p>我们这里说的 “元编程（metaprogramming）” 是什么意思呢？其实，对于本文要介绍的这些内容，这是我们能够想到的最能概括它们的词。因为我们今天要讲的东西，更多是关于 <em>流程</em> ，而不是写代码或更高效的工作。本节课我们会学习构建系统、代码测试以及依赖管理。在你还是学生的时候，这些东西看上去似乎对你来说没那么重要，不过当你开始实习或走进社会的时候，你将会接触到大型的代码库，本节课讲授的这些东西也会变得随处可见。必须要指出的是，“元编程” 也有<a href="https://en.wikipedia.org/wiki/Metaprogramming">用于操作程序的程序</a>” 之含义，这和我们今天讲座所介绍的概念是完全不同的。</p><h2 id="构建系统">构建系统</h2><p>如果你使用 LaTeX 来编写论文，你需要执行哪些命令才能编译出你想要的论文呢？执行基准测试、绘制图表然后将其插入论文的命令又有哪些？或者，如何编译本课程提供的代码并执行测试呢？</p><p>对于大多数系统来说，不论其是否包含代码，都会包含一个 “构建过程”。有时，你需要<strong>执行一系列操作</strong>。通常，这一过程包含了很多步骤，很多分支。执行一些命令来生成图表，然后执行另外的一些命令生成结果，然后再执行其他的命令来生成最终的论文。有很多事情需要我们完成，你并不是第一个因此感到苦恼的人，幸运的是，有很多工具可以帮助我们完成这些操作。</p><p><strong>这些工具通常被称为 “构建系统”</strong>，而且这些工具还不少。如何选择工具完全取决于你当前手头上要完成的任务以及项目的规模。从本质上讲，这些工具都是非常类似的。<strong>你需要定义 ==<em>依赖</em>、<em>目标</em> 和 <em>规则</em>==。你必须告诉构建系统你具体的构建目标，系统的任务则是找到构建这些目标所需要的依赖，并根据规则构建所需的中间产物，直到最终目标被构建出来</strong>。理想的情况下，<strong>如果目标的依赖没有发生改动，并且我们可以从之前的构建中复用这些依赖，那么与其相关的构建规则并不会被执行</strong>。</p><p><strong><code>make</code></strong> 是最常用的构建系统之一，你会发现它通常被安装到了几乎所有基于UNIX的系统中。<code>make</code> 并不完美，但是对于中小型项目来说，它已经足够好了。当你执行 <code>make</code> 时，它会去参考当前目录下名为 <strong><code>Makefile</code></strong> 的文件。所有构建目标、相关依赖和规则都需要在该文件中定义，它看上去是这样的：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">paper.pdf: paper.tex plot-data.png</span></span><br><span class="line">pdflatex paper.tex</span><br><span class="line"></span><br><span class="line"><span class="section">plot-%.png: %.dat plot.py</span></span><br><span class="line">./plot.py -i <span class="variable">$*</span>.dat -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p><strong>冒号左侧的是构建目标，冒号右侧的是构建它所需的依赖，缩进的部分是从依赖构建目标时需要用到的一段命令。<strong>在 <code>make</code> 中，第一条指令还指明了构建的目的，如果你使用不带参数的 <code>make</code>，这便是我们</strong>最终</strong>的构建结果。或者，你可以使用这样的命令来构建其他目标：<code>make plot-data.png</code>。</p><p>规则中的 <code>%</code> 是一种模式，它会匹配其左右两侧相同的字符串。例如，如果目标是 <code>plot-foo.png</code>， <code>make</code> 会去寻找 <code>foo.dat</code> 和 <code>plot.py</code> 作为依赖。现在，让我们看看如果在一个空的源码目录中执行 <code>make</code> 会发生什么？</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">make: *** No rule to make target <span class="string">&#x27;paper.tex&#x27;</span>, needed by <span class="string">&#x27;paper.pdf&#x27;</span>.  Stop.</span><br></pre></td></tr></table></figure><p><code>make</code> 会告诉我们，为了构建出<code>paper.pdf</code>，它需要 <code>paper.tex</code>，但是并没有一条规则能够告诉它如何构建该文件。让我们构建它吧！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> paper.tex</span><br><span class="line">$ make</span><br><span class="line">make: *** No rule to make target <span class="string">&#x27;plot-data.png&#x27;</span>, needed by <span class="string">&#x27;paper.pdf&#x27;</span>.  Stop.</span><br></pre></td></tr></table></figure><p>哟，有意思，我们是<strong>有</strong>构建 <code>plot-data.png</code> 的规则的，但是这是一条模式规则。因为源文件 <code>data.dat</code> 并不存在，因此 <code>make</code> 就会告诉你它不能构建 <code>plot-data.png</code>，让我们创建这些文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> paper.tex</span><br><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage&#123;graphicx&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\includegraphics[scale=0.65]&#123;plot-data.png&#125;</span><br><span class="line">\end&#123;document&#125;</span><br><span class="line">$ <span class="built_in">cat</span> plot.py</span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line">import matplotlib</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-i&#x27;</span>, <span class="built_in">type</span>=argparse.FileType(<span class="string">&#x27;r&#x27;</span>))</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-o&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">data = np.loadtxt(args.i)</span><br><span class="line">plt.plot(data[:, 0], data[:, 1])</span><br><span class="line">plt.savefig(args.o)</span><br><span class="line">$ <span class="built_in">cat</span> data.dat</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 4</span><br><span class="line">5 8</span><br></pre></td></tr></table></figure><p>当我们执行 <code>make</code> 时会发生什么？</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">./plot.py -i data.dat -o plot-data.png</span><br><span class="line">pdflatex paper.tex</span><br><span class="line">... lots of output ...</span><br></pre></td></tr></table></figure><p>看！PDF ！</p><p>如果再次执行 <code>make</code> 会怎样？</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">make: <span class="string">&#x27;paper.pdf&#x27;</span> is up to <span class="built_in">date</span>.</span><br></pre></td></tr></table></figure><p>什么事情都没做！为什么？因为它什么都不需要做。<code>make</code> 会去检查之前的构建是因其依赖改变而需要被更新。让我们试试修改 <code>paper.tex</code> 在重新执行 <code>make</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim paper.tex</span><br><span class="line">$ make</span><br><span class="line">pdflatex paper.tex</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意 <code>make</code> 并<strong>没有</strong>重新构建 <code>plot.py</code>，因为没必要：<code>plot-data.png</code> 的所有依赖都没有发生改变。</p><h2 id="依赖管理">依赖管理</h2><h3 id="依赖库">依赖库</h3><p>就你的项目来说，它的依赖可能本身也是其他的项目。你也许会依赖某些程序（例如 <code>python</code>）、系统包（例如 <code>openssl</code>）或相关编程语言的库（例如 <code>matplotlib</code>）。 现在，大多数的依赖可以通过某些<strong>软件仓库</strong>来获取，这些仓库会在一个地方托管大量的依赖，我们则可以通过一套非常简单的机制来安装依赖。</p><ul><li>例如 Ubuntu 系统下面有 Ubuntu 软件包仓库，你可以通过 <code>apt</code> 这个工具来访问，</li><li>RubyGems 则包含了 Ruby 的相关库，</li><li>PyPi 包含了 Python 库，</li><li>Arch Linux 用户贡献的库则可以在 Arch User Repository 中找到。</li></ul><h3 id="版本控制和版本号">版本控制和版本号</h3><p>由于每个仓库、每种工具的运行机制都不太一样，因此我们并不会在本节课深入讲解具体的细节。我们会介绍一些通用的术语，例如 <em>版本控制</em>。</p><p>大多数被其他项目所依赖的项目都会在每次发布新版本时创建一个<em>版本号</em>。通常看上去像 8.1.3 或 64.1.20192004。版本号一般是数字构成的，但也并不绝对。版本号有很多用途，其中最重要的作用是<strong>保证软件能够运行</strong>。</p><p>试想一下，假如我的库要发布一个新版本，在这个版本里面我<strong>重命名</strong>了某个函数。如果有人在我的库升级版本后，仍希望基于<strong>它</strong>构建新的软件，那么很可能构建会失败，因为它希望调用的函数已经不复存在了。有了版本控制就可以很好的解决这个问题，我们可以<strong>指定当前项目需要基于某个版本，甚至某个范围内的版本，或是某些项目来构建</strong>。这么做的话，即使某个被依赖的库发生了变化，依赖它的软件可以基于其之前的版本进行构建。</p><p>这样还并不理想！如果我们发布了一项和安全相关的升级，它并 <em>没有</em> 影响到任何公开接口（API），但是出于安全的考虑，依赖它的项目都应该立即升级，那应该怎么做呢？这也是版本号包含多个部分的原因。不同项目所用的版本号其具体含义并不完全相同，但是一个相对比较常用的标准是<a href="https://semver.org/">语义版本号</a>，这种版本号具有不同的语义，它的格式是这样的：主版本号.次版本号.补丁号。相关规则有：</p><ul><li>如果新的版本没有改变 API，请将补丁号递增；</li><li>如果你添加了 API 并且该改动是向后兼容的，请将次版本号递增；</li><li>如果你修改了 API 但是它并不向后兼容，请将主版本号递增。</li></ul><p>这么做有很多好处。现在如果我们的项目是基于你的项目构建的，那么只要最新版本的主版本号只要没变就是安全的，次版本号不低于之前我们使用的版本即可。</p><p>举例来说，如果我依赖的版本是 <code>1.3.7</code>，那么使用 <code>1.3.8</code>、<code>1.6.1</code>，甚至是 <code>1.3.0</code>都是可以的。如果版本号是  <code>2.2.4</code> 就不一定能用了，因为它的主版本号增加了。我们可以将 Python 的版本号作为语义版本号的一个实例。你应该知道，Python 2 和 Python 3 的代码是不兼容的，这也是 Python 的主版本号改变的原因。类似的，使用 Python 3.5 编写的代码在 3.7 上可以运行，但是在 3.4 上可能会不行。</p><h3 id="锁文件">锁文件</h3><p>使用依赖管理系统的时候，你可能会遇到<strong>锁文件（<em>lock files</em>）<strong>这一概念。锁文件列出了你</strong>当前每个依赖所对应的具体版本号</strong>。通常，你需要执行升级程序才能更新依赖的版本。这么做的原因有很多，例如避免不必要的重新编译、创建可复现的软件版本或禁止自动升级到最新版本（可能会包含 bug）。还有一种<strong>极端的依赖锁定</strong>叫做 <em><strong>vendoring</strong></em>，它会把你的<strong>依赖中的所有代码直接拷贝</strong>到你的项目中，这样你就能够完全掌控代码的任何修改，同时你也可以将自己的修改添加进去，不过这也意味着如果该依赖的维护者更新了某些代码，你也必须要自己去拉取这些更新。</p><h2 id="持续集成系统">持续集成系统</h2><p>随着你接触到的项目规模越来越大，你会发现<strong>修改代码之后</strong>还有很多额外的工作要做。你可能需要上传一份新版本的文档、上传编译后的文件到某处、发布代码到 pypi，执行测试套件等等。或许你希望每次有人提交代码到 GitHub 的时候，他们的代码风格被检查过并执行过某些基准测试？如果你有这方面的需求，那么请花些时间了解一下持续集成。</p><p><strong>持续集成，或者叫做 CI</strong> 是一种雨伞术语（umbrella term，涵盖了一组术语的术语），它指的是那些 <strong>“当你的代码变动时，自动运行的东西”</strong>，市场上有很多提供各式各样 CI 工具的公司，这些工具大部分都是免费或开源的。比较大的有 Travis CI、Azure Pipelines 和 GitHub Actions。它们的工作原理都是类似的：<strong>你需要在代码仓库中添加一个文件，描述当前仓库发生任何修改时，应该如何应对。<strong>目前为止，最常见的规则是：如果有人提交代码，执行测试套件。<strong>当这个事件被触发时，CI 提供方会启动一个（或多个）虚拟机，执行你制定的规则，并且通常会记录下相关的执行结果</strong>。你可以进行某些设置，这样当测试套件失败时你能够收到通知或者当测试全部通过时，你的仓库主页会显示一个</strong>徽标</strong>。</p><p>本课程的网站基于 GitHub Pages 构建，这就是一个很好的例子。Pages 在每次 <code>master</code> 有代码更新时，会执行 Jekyll 博客软件，然后使你的站点可以通过某个 GitHub 域名来访问。对于我们来说这些事情太琐碎了，我现在我们只需要在本地进行修改，然后使用 git 提交代码，发布到远端。CI 会自动帮我们处理后续的事情。</p><h2 id="测试">测试</h2><p>多数的大型软件都有 “测试套件”。你可能已经对测试的相关概念有所了解，但是我们觉得有些测试方法和测试术语还是应该再次提醒一下：</p><ul><li>测试套件：所有测试的统称。</li><li>单元测试：一种 “微型测试”，用于对某个封装的特性进行测试。</li><li>集成测试：一种 “宏观测试”，针对系统的某一大部分进行，测试其不同的特性或组件是否能 <em>协同</em> 工作。</li><li>回归测试：一种实现特定模式的测试，用于保证之前引起问题的 bug 不会再次出现。</li><li>模拟（Mocking）: 使用一个假的实现来替换函数、模块或类型，屏蔽那些和测试不相关的内容。例如，你可能会 “模拟网络连接” 或 “模拟硬盘”。</li></ul>]]></content>
      
      
      <categories>
          
          <category> The Missing Semester </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Build System </tag>
            
            <tag> Version </tag>
            
            <tag> Continuous Integration </tag>
            
            <tag> Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MIT The Missing Semester] Lec07: Debugging and Profiling</title>
      <link href="/2025/03/02/MIT-The-Missing-Semester-Lec07-Debugging-and-Profiling/"/>
      <url>/2025/03/02/MIT-The-Missing-Semester-Lec07-Debugging-and-Profiling/</url>
      
        <content type="html"><![CDATA[<h1>Lec07：调试及性能分析</h1><p>本 Lec 的主要内容：</p><ul><li>学习如何在命令行中调试代码<ul><li>打印调试法</li><li>日志调试法</li><li>调试器调试法<ul><li>源代码调试</li><li>二进制代码调试</li></ul></li><li>静态分析工具调试</li></ul></li><li>如何进行性能分析<ul><li>计时分析性能</li><li>CPU、内存、事件性能分析</li><li>一系列资源监控工具</li></ul></li></ul><h2 id="调试代码">调试代码</h2><h3 id="打印调试法与日志">打印调试法与日志</h3><p>“最有效的 debug 工具就是细致的分析，配合恰当位置的打印语句” — Brian Kernighan, <em>Unix 新手入门</em>。</p><p>调试代码的第一种方法往往是在你发现问题的地方添加一些打印语句，然后不断重复此过程直到你获取了足够的信息并找到问题的根本原因。</p><p>另外一个方法是使用日志，而不是临时添加打印语句。日志较普通的打印语句有如下的一些优势：</p><ul><li>你可以将<strong>日志写入文件、socket 或者甚至是发送到远端服务器</strong>而不仅仅是标准输出；</li><li>日志可以<strong>支持严重等级</strong>（例如 INFO, DEBUG, WARN, ERROR 等），这使你可以根据需要过滤日志；</li><li>对于<strong>新发现的问题</strong>，很可能你的日志中已经包含了可以帮助你定位问题的足够的信息。</li></ul><p>有很多技巧可以使日志的可读性变得更好，一个技巧是对其进行==着色==。到目前为止，你应该已经知道，以彩色文本显示终端信息时可读性更好。但是应该如何设置呢？</p><p><code>ls</code> 和 <code>grep</code> 这样的程序会使用 <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape codes</a>，它是一系列的特殊字符，可以使你的 shell 改变输出结果的颜色。例如，执行 <code>echo -e &quot;\e[38;2;255;0;0mThis is red\e[0m&quot;</code> 会打印红色的字符串：<code>This is red</code> ，只要你的终端支持<a href="https://gist.github.com/XVilka/8346728#terminals--true-color">真彩色</a>。如果你的终端不支持真彩色（例如 MacOS 的 Terminal.app），你可以使用支持更加广泛的 16 色，例如：<code>\e[31;1mThis is red\e[0m</code>。</p><p>下面这个脚本向你展示了如何在终端中打印多种颜色（只要你的终端支持真彩色）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="keyword">for</span> R <span class="keyword">in</span> $(<span class="built_in">seq</span> 0 20 255); <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> G <span class="keyword">in</span> $(<span class="built_in">seq</span> 0 20 255); <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> B <span class="keyword">in</span> $(<span class="built_in">seq</span> 0 20 255); <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">printf</span> <span class="string">&quot;\e[38;2;<span class="variable">$&#123;R&#125;</span>;<span class="variable">$&#123;G&#125;</span>;<span class="variable">$&#123;B&#125;</span>m█\e[0m&quot;</span>;</span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="第三方日志系统">第三方日志系统</h3><p>如果你正在构建大型软件系统，你很可能会使用到一些依赖，有些依赖会作为程序单独运行。如 Web 服务器、数据库或消息代理都是此类常见的第三方依赖。</p><p>和这些系统交互的时候，阅读它们的日志是非常必要的，因为仅靠客户端侧的错误信息可能并不足以定位问题。</p><p>幸运的是，大多数的程序都会将日志保存在你的系统中的某个地方。**对于 UNIX 系统来说，程序的日志通常存放在 <code>/var/log</code>。**例如， <a href="https://www.nginx.com/">NGINX</a> web 服务器就将其日志存放于<code>/var/log/nginx</code>。</p><p>目前，系统开始使用 <strong>system log</strong>，你所有的日志都会保存在这里。**大多数（但不是全部的）Linux 系统都会使用 <code>systemd</code>，**这是一个系统守护进程，它会控制你系统中的很多东西，例如哪些服务应该启动并运行。<code>systemd</code> 会将日志以某种特殊格式存放于<code>/var/log/journal</code>，你可以使用 <a href="http://man7.org/linux/man-pages/man1/journalctl.1.html"><code>journalctl</code></a> 命令显示这些消息。</p><p>类似地，在 macOS 系统中是 <code>/var/log/system.log</code>，但是有更多的工具会使用系统日志，它的内容可以使用 <a href="https://www.manpagez.com/man/1/log/"><code>log show</code></a> 显示。</p><p>对于大多数的 UNIX 系统，你也可以使用 <a href="http://man7.org/linux/man-pages/man1/dmesg.1.html"><code>dmesg</code></a> 命令来读取内核的日志。</p><p>如果你希望将日志加入到系统日志中，你可以使用 <a href="http://man7.org/linux/man-pages/man1/logger.1.html"><code>logger</code></a> 这个 shell 程序。下面这个例子显示了如何使用  <code>logger</code> 并且如何找到能够将其存入系统日志的条目。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">logger <span class="string">&quot;Hello Logs&quot;</span></span><br><span class="line"><span class="comment"># On macOS</span></span><br><span class="line"><span class="built_in">log</span> show --last 1m | grep Hello</span><br><span class="line"><span class="comment"># On Linux</span></span><br><span class="line">journalctl --since <span class="string">&quot;1m ago&quot;</span> | grep Hello</span><br></pre></td></tr></table></figure><p>不仅如此，大多数的编程语言都支持向系统日志中写日志。</p><p>正如我们在数据整理那节课上看到的那样，日志的内容可以非常的多，我们需要对其进行处理和过滤才能得到我们想要的信息。</p><p>如果你发现你需要对 <code>journalctl</code> 和 <code>log show</code> 的结果进行大量的过滤，那么此时可以考虑使用它们自带的选项对其结果先过滤一遍再输出。还有一些像 <a href="http://lnav.org/"><code>lnav</code></a> 这样的工具，它为日志文件提供了更好的展现和浏览方式。</p><h3 id="调试器">调试器</h3><p><strong>当通过打印已经不能满足你的调试需求时，你应该使用调试器。</strong></p><p>调试器是一种可以允许我们<strong>和正在执行的程序进行交互的程序</strong>，它可以做到：</p><ul><li>当到达某一行时将程序暂停；</li><li>一次一条指令地逐步执行程序；</li><li>程序崩溃后查看变量的值；</li><li>满足特定条件时暂停程序；</li><li>其他高级功能。</li></ul><p>很多编程语言都有自己的调试器。Python 的调试器是 <a href="https://docs.python.org/3/library/pdb.html"><code>pdb</code></a>.</p><p>下面对 <code>pdb</code> 支持的命令进行简单的介绍：</p><ul><li><strong>l</strong>(ist) - 显示当前行附近的 11 行或继续执行之前的显示；<ul><li><strong>ll</strong> - 显示当前所在函数的整个函数体</li></ul></li><li><strong>s</strong>(tep) - 执行当前行，并在第一个可能的地方停止（也可以理解为进入函数内部）；</li><li><strong>n</strong>(ext) - 继续执行直到当前函数的下一条语句或者 return 语句（就是执行当前语句，然后到下一条语句）；</li><li><strong>b</strong>(reak) - 设置断点（基于传入的参数）；<ul><li><strong>cl &lt;断点id&gt;</strong> - 清除断点</li><li><strong>c</strong>(ontinue) - 继续执行直到下一个端点</li></ul></li><li><strong>p</strong>(rint) - 在当前上下文对表达式求值并打印结果。还有一个命令是 <strong>pp</strong> ，它使用 <a href="https://docs.python.org/3/library/pprint.html"><code>pprint</code></a> 打印；</li><li><strong>r</strong>(eturn) - 继续执行直到当前函数返回；</li><li><strong>!</strong> - 后面接 <code>python</code> 语句，可以直接像在 <code>python</code> 命令行界面一样执行语句；</li><li><strong>q</strong>(uit) - 退出调试器。</li></ul><p>注意，因为 Python 是一种解释型语言，所以我们可以通过 <code>pdb</code> shell 执行命令。 <a href="https://pypi.org/project/ipdb/"><code>ipdb</code></a> 是一种增强型的 <code>pdb</code> ，它使用 <a href="https://ipython.org/"><code>IPython</code></a> 作为 REPL并开启了 tab 补全、语法高亮、更好的回溯和更好的内省，同时还保留了 <code>pdb</code> 模块相同的接口。</p><p>对于更底层的编程语言，你可能需要了解一下 <a href="https://www.gnu.org/software/gdb/"><code>gdb</code></a> ( 以及它的改进版 <a href="https://github.com/pwndbg/pwndbg"><code>pwndbg</code></a>) 和 <a href="https://lldb.llvm.org/"><code>lldb</code></a>。</p><p>它们都对类 C 语言的调试进行了优化，它允许你探索任意进程及其机器状态：寄存器、堆栈、程序计数器等。</p><blockquote><p>截至目前（2024.07.18），<code>gdb</code> 仅支持 x86 平台。</p></blockquote><h3 id="二进制程序调试">二进制程序调试</h3><p>即使你需要调试的程序是一个二进制的黑盒程序，仍然有一些工具可以帮助到你。当你的程序需要执行一些只有操作系统内核才能完成的操作时，它需要使用 <a href="https://en.wikipedia.org/wiki/System_call">系统调用</a>。有一些命令可以帮助你追踪你的程序执行的系统调用。在 Linux 中可以使用 <a href="http://man7.org/linux/man-pages/man1/strace.1.html"><code>strace</code></a> ，在 macOS 和 BSD 中可以使用 <a href="http://dtrace.org/blogs/about/"><code>dtrace</code></a>。<code>dtrace</code> 用起来可能有些别扭，因为它使用的是它自有的 <code>D</code> 语言，但是我们可以使用一个叫做 <a href="https://www.manpagez.com/man/1/dtruss/"><code>dtruss</code></a> 的封装使其具有和 <code>strace</code> （更多信息参考 <a href="https://8thlight.com/blog/colin-jones/2015/11/06/dtrace-even-better-than-strace-for-osx.html">这里</a>）类似的接口</p><p>下面的例子展现来如何使用 <code>strace</code> 或 <code>dtruss</code> 来显示 <code>ls</code> 执行时，对 <a href="http://man7.org/linux/man-pages/man2/stat.2.html"><code>stat</code></a> 系统调用进行追踪对结果。若需要深入了解 <code>strace</code>，<a href="https://blogs.oracle.com/linux/strace-the-sysadmins-microscope-v2">这篇文章</a> 值得一读。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># On Linux</span></span><br><span class="line"><span class="built_in">sudo</span> strace -e lstat <span class="built_in">ls</span> -l &gt; /dev/null</span><br><span class="line">4</span><br><span class="line"><span class="comment"># On macOS</span></span><br><span class="line"><span class="built_in">sudo</span> dtruss -t lstat64_extended <span class="built_in">ls</span> -l &gt; /dev/null</span><br></pre></td></tr></table></figure><h3 id="网络调试">网络调试</h3><p>有些情况下，我们需要查看网络数据包才能定位问题。像 <a href="http://man7.org/linux/man-pages/man1/tcpdump.1.html"><code>tcpdump</code></a> 和 <a href="https://www.wireshark.org/">Wireshark</a> 这样的网络数据包分析工具可以帮助你获取网络数据包的内容并基于不同的条件进行过滤。</p><p>对于 web 开发， Chrome/Firefox 的开发者工具非常方便，功能也很强大：</p><ul><li>源码 -查看任意站点的 HTML/CSS/JS 源码；</li><li>实时地修改 HTML, CSS, JS 代码 - 修改网站的内容、样式和行为用于测试（从这一点你也能看出来，网页截图是不可靠的）；</li><li>Javascript shell - 在 JS REPL中执行命令；</li><li>网络 - 分析请求的时间线；</li><li>存储 - 查看 Cookies 和本地应用存储。</li></ul><h3 id="代码静态分析工具">代码静态分析工具</h3><p>有些问题是你不需要执行代码就能发现的。例如，仔细观察一段代码，你就能发现某个循环变量覆盖了某个已经存在的变量或函数名；或是有个变量在被读取之前并没有被定义。 这种情况下 <a href="https://en.wikipedia.org/wiki/Static_program_analysis">静态分析</a> 工具就可以帮我们找到问题。<strong>静态分析会将程序的源码作为输入然后基于编码规则对其进行分析并对代码的正确性进行推理。</strong></p><p>下面这段 Python 代码中存在几个问题。 首先，我们的循环变量 <code>foo</code> 覆盖了之前定义的函数 <code>foo</code>。最后一行，我们还把 <code>bar</code> 错写成了 <code>baz</code>，因此当程序完成 <code>sleep</code> （一分钟）后，执行到这一行的时候便会崩溃。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> foo <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(foo)</span><br><span class="line">bar = <span class="number">1</span></span><br><span class="line">bar *= <span class="number">0.2</span></span><br><span class="line">time.sleep(<span class="number">60</span>)</span><br><span class="line"><span class="built_in">print</span>(baz)</span><br></pre></td></tr></table></figure><p>静态分析工具可以发现此类的问题。当我们使用 <a href="https://pypi.org/project/pyflakes"><code>pyflakes</code></a> 分析代码的时候，我们会得到与这两处 bug 相关的错误信息。<a href="http://mypy-lang.org/"><code>mypy</code></a> 则是另外一个工具，它可以对代码进行类型检查。这里，<code>mypy</code> 会警告我们 <code>bar</code> 起初是一个 <code>int</code> ，然后变成了 <code>float</code>。这些问题都可以在不运行代码的情况下被发现。</p><p>在 shell 工具那一节课的时候，我们介绍了 <a href="https://www.shellcheck.net/"><code>shellcheck</code></a>，这是一个类似的工具，但它是应用于 shell 脚本的。</p><p>大多数的编辑器和 IDE 都支持<strong>在编辑界面显示这些工具的分析结果、高亮有警告和错误的位置</strong>。 这个过程通常称为 <strong>code linting</strong> 。<em>风格检查或安全检查</em> 的结果同样也可以进行相应的显示。</p><p>在 vim 中，有 <a href="https://vimawesome.com/plugin/ale"><code>ale</code></a> 或 <a href="https://vimawesome.com/plugin/syntastic"><code>syntastic</code></a> 可以帮助你做同样的事情。 在 Python 中， <a href="https://www.pylint.org/"><code>pylint</code></a> 和 <a href="https://pypi.org/project/pep8/"><code>pep8</code></a> 是两种用于进行风格检查的工具，而 <a href="https://pypi.org/project/bandit/"><code>bandit</code></a> 工具则用于检查安全相关的问题。</p><p>对于其他语言的开发者来说，静态分析工具可以参考这个列表：<a href="https://github.com/mre/awesome-static-analysis">Awesome Static Analysis</a> （你也许会对 <em>Writing</em> 一节感兴趣）。对于 linters 则可以参考这个列表： <a href="https://github.com/caramelomartins/awesome-linters">Awesome Linters</a>。</p><p>对于风格检查和代码格式化，还有以下一些工具可以作为补充：</p><ul><li>用于 Python 的 <a href="https://github.com/psf/black"><code>black</code></a>、</li><li>用于 Go 语言的 <code>gofmt</code>、</li><li>用于 Rust 的 <code>rustfmt</code> 或是</li><li>用于 JavaScript, HTML 和 CSS 的 <a href="https://prettier.io/"><code>prettier</code></a> 。</li></ul><p>这些工具可以自动格式化你的代码，这样代码风格就可以与常见的风格保持一致。 尽管你可能并不想对代码进行风格控制，标准的代码风格有助于方便别人阅读你的代码，也可以方便你阅读它的代码。</p><h2 id="性能分析">性能分析</h2><p>即使你的代码能够像你期望的一样运行，但是如果它消耗了你全部的 CPU 和内存，那么它显然也不是个好程序。算法课上我们通常会介绍大O标记法，但却没教给我们如何找到程序中的热点（即最消耗资源的部分）。 鉴于 <a href="http://wiki.c2.com/?PrematureOptimization">过早的优化是万恶之源</a>，你需要学习性能分析和监控工具，它们会帮助你找到程序中最耗时、最耗资源的部分，这样你就可以有针对性的进行性能优化。</p><h3 id="计时">计时</h3><p>计时和调试代码类似，大多数情况下我们只需要打印两处代码之间的时间即可发现问题。下面这个例子中，我们使用了 Python 的 <a href="https://docs.python.org/3/library/time.html"><code>time</code></a>模块。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line">n = random.randint(<span class="number">1</span>, <span class="number">10</span>) * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间 </span></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一些操作</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sleeping for &#123;&#125; ms&quot;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">time.sleep(n/<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较当前时间和起始时间</span></span><br><span class="line"><span class="built_in">print</span>(time.time() - start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Sleeping for 500 ms</span></span><br><span class="line"><span class="comment"># 0.5713930130004883</span></span><br></pre></td></tr></table></figure><p>不过，执行时间（wall clock time）也可能会误导你，因为你的电脑可能也在同时运行其他进程，也可能在此期间发生了等待。 对于工具来说，需要区分真实时间、用户时间和系统时间。通常来说，用户时间+系统时间代表了你的进程所消耗的实际 CPU 时间（更详细的解释可以参照<a href="https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1">这篇文章</a>）。</p><ul><li>真实时间 - 从程序开始到结束流失掉的真实时间，包括其他进程的执行时间以及阻塞消耗的时间（例如等待  I/O 或网络）；</li><li><em>User</em> - CPU 执行用户代码所花费的时间；</li><li><em>Sys</em> - CPU 执行系统内核代码所花费的时间。</li></ul><p>例如，试着执行一个用于发起 HTTP 请求的命令并在其前面添加 <a href="http://man7.org/linux/man-pages/man1/time.1.html"><code>time</code></a> 前缀。网络不好的情况下你可能会看到下面的输出结果。请求花费了 2s 才完成，但是进程仅花费了 15ms 的 CPU 用户时间和 12ms 的 CPU 内核时间。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">time</span> curl https://missing.csail.mit.edu &amp;&gt; /dev/null</span><br><span class="line">real    0m2.561s</span><br><span class="line">user    0m0.015s</span><br><span class="line">sys     0m0.012s</span><br></pre></td></tr></table></figure><h3 id="性能分析工具">性能分析工具</h3><h4 id="CPU">CPU</h4><p>大多数情况下，当人们提及性能分析工具的时候，通常指的是 CPU 性能分析工具。</p><p><strong>CPU 性能分析工具有两种： 追踪分析器（<em>tracing</em>）及采样分析器（<em>sampling</em>）</strong>。 追踪分析器 会记录程序的每一次函数调用，而采样分析器则只会周期性的监测（通常为每毫秒）你的程序并记录程序堆栈。它们使用这些记录来生成统计信息，显示程序在哪些事情上花费了最多的时间。如果你希望了解更多相关信息，可以参考 <a href="https://jvns.ca/blog/2017/12/17/how-do-ruby---python-profilers-work-">这篇</a> 介绍性的文章。</p><p>大多数的编程语言都有一些基于命令行的分析器，我们可以使用它们来分析代码。它们通常可以集成在 IDE 中，但是本节课我们会专注于这些命令行工具本身。</p><p>在 Python 中，我们使用 <code>cProfile</code> 模块来分析每次函数调用所消耗的时间。 在下面的例子中，我们实现了一个基础的 grep 命令：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grep</span>(<span class="params">pattern, file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(file)</span><br><span class="line">        <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f.readlines()):</span><br><span class="line">            pattern = re.<span class="built_in">compile</span>(pattern)</span><br><span class="line">            <span class="keyword">match</span> = pattern.search(line)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">match</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, line), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    times = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    pattern = sys.argv[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> sys.argv[<span class="number">3</span>:]:</span><br><span class="line">            grep(pattern, file)</span><br></pre></td></tr></table></figure><p>我们可以使用下面的命令来对这段代码进行分析。通过它的输出我们可以知道，IO 消耗了大量的时间，编译正则表达式也比较耗费时间。因为正则表达式只需要编译一次，我们可以将其移动到 for 循环外面来改进性能。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python -m cProfile -s tottime grep.py 1000 <span class="string">&#x27;^(import|\s*def)[^,]*$&#x27;</span> *.py</span><br><span class="line"></span><br><span class="line">[omitted program output]</span><br><span class="line"></span><br><span class="line"> ncalls  tottime  percall  cumtime  percall filename:lineno(<span class="keyword">function</span>)</span><br><span class="line">   8000    0.266    0.000    0.292    0.000 &#123;built-in method io.open&#125;</span><br><span class="line">   8000    0.153    0.000    0.894    0.000 grep.py:5(grep)</span><br><span class="line">  17000    0.101    0.000    0.101    0.000 &#123;built-in method builtins.print&#125;</span><br><span class="line">   8000    0.100    0.000    0.129    0.000 &#123;method <span class="string">&#x27;readlines&#x27;</span> of <span class="string">&#x27;_io._IOBase&#x27;</span> objects&#125;</span><br><span class="line">  93000    0.097    0.000    0.111    0.000 re.py:286(_compile)</span><br><span class="line">  93000    0.069    0.000    0.069    0.000 &#123;method <span class="string">&#x27;search&#x27;</span> of <span class="string">&#x27;_sre.SRE_Pattern&#x27;</span> objects&#125;</span><br><span class="line">  93000    0.030    0.000    0.141    0.000 re.py:231(compile)</span><br><span class="line">  17000    0.019    0.000    0.029    0.000 codecs.py:318(decode)</span><br><span class="line">      1    0.017    0.017    0.911    0.911 grep.py:3(&lt;module&gt;)</span><br><span class="line"></span><br><span class="line">[omitted lines]</span><br></pre></td></tr></table></figure><p>关于 Python 的 <code>cProfile</code> 分析器（以及其他一些类似的分析器），<strong>需要注意的是它显示的是每次函数调用的时间</strong>。看上去可能快到反直觉，尤其是如果你在代码里面使用了第三方的函数库，因为内部函数调用也会被看作函数调用。</p><p>更加符合直觉的显示分析信息的方式是包括<strong>每行代码的执行时间</strong>，这也是 <em>行分析器</em>（line profiler） 的工作。例如，下面这段 Python 代码会向本课程的网站发起一个请求，然后解析响应返回的页面中的全部 URL：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个装饰器会告诉行分析器 </span></span><br><span class="line"><span class="comment"># 我们想要分析这个函数</span></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_urls</span>():</span><br><span class="line">    response = requests.get(<span class="string">&#x27;https://missing.csail.mit.edu&#x27;</span>)</span><br><span class="line">    s = BeautifulSoup(response.content, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    urls = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> s.find_all(<span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">        urls.append(url[<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_urls()</span><br></pre></td></tr></table></figure><p>如果我们使用 Python 的 <code>cProfile</code> 分析器，我们会得到超过 2500 行的输出结果，即使对其进行排序，我仍然搞不懂时间到底都花在哪了。如果我们使用 <a href="https://github.com/pyutils/line_profiler"><code>line_profiler</code></a>，它会基于行来显示时间：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kernprof -l -v a.py</span><br><span class="line">Wrote profile results to urls.py.lprof</span><br><span class="line">Timer unit: 1e-06 s</span><br><span class="line"></span><br><span class="line">Total <span class="keyword">time</span>: 0.636188 s</span><br><span class="line">File: a.py</span><br><span class="line">Function: get_urls at line 5</span><br><span class="line"></span><br><span class="line">Line <span class="comment">#  Hits         Time  Per Hit   % Time  Line Contents</span></span><br><span class="line">==============================================================</span><br><span class="line"> 5                                           @profile</span><br><span class="line"> 6                                           def get_urls():</span><br><span class="line"> 7         1     613909.0 613909.0     96.5      response = requests.get(<span class="string">&#x27;https://missing.csail.mit.edu&#x27;</span>)</span><br><span class="line"> 8         1      21559.0  21559.0      3.4      s = BeautifulSoup(response.content, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"> 9         1          2.0      2.0      0.0      urls = []</span><br><span class="line">10        25        685.0     27.4      0.1      <span class="keyword">for</span> url <span class="keyword">in</span> s.find_all(<span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">11        24         33.0      1.4      0.0          urls.append(url[<span class="string">&#x27;href&#x27;</span>])</span><br></pre></td></tr></table></figure><h4 id="内存">内存</h4><p>像 C 或者 C++ 这样的语言，内存泄漏会导致你的程序在使用完内存后不去释放它。为了应对内存类的 Bug，我们可以使用类似 <a href="https://valgrind.org/">Valgrind</a> 这样的工具来检查内存泄漏问题。</p><p>对于 Python 这类具有垃圾回收机制的语言，内存分析器也是很有用的，因为对于某个对象来说，只要有指针还指向它，那它就不会被回收。</p><p>下面这个例子及其输出，展示了 <a href="https://pypi.org/project/memory-profiler/">memory-profiler</a> 是如何工作的（注意装饰器和 <code>line-profiler</code> 类似）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>():</span><br><span class="line">    a = [<span class="number">1</span>] * (<span class="number">10</span> ** <span class="number">6</span>)</span><br><span class="line">    b = [<span class="number">2</span>] * (<span class="number">2</span> * <span class="number">10</span> ** <span class="number">7</span>)</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_func()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python -m memory_profiler example.py</span><br><span class="line">Line <span class="comment">#    Mem usage  Increment   Line Contents</span></span><br><span class="line">==============================================</span><br><span class="line">     3                           @profile</span><br><span class="line">     4      5.97 MB    0.00 MB   def my_func():</span><br><span class="line">     5     13.61 MB    7.64 MB       a = [1] * (10 ** 6)</span><br><span class="line">     6    166.20 MB  152.59 MB       b = [2] * (2 * 10 ** 7)</span><br><span class="line">     7     13.61 MB -152.59 MB       del b</span><br><span class="line">     8     13.61 MB    0.00 MB       <span class="built_in">return</span> a</span><br></pre></td></tr></table></figure><h4 id="事件">事件</h4><p>在我们使用<code>strace</code>调试代码的时候，你可能会希望忽略一些特殊的代码并希望在分析时将其当作黑盒处理。<a href="http://man7.org/linux/man-pages/man1/perf.1.html"><code>perf</code></a> 命令将 CPU 的区别进行了抽象，它<strong>不会报告时间和内存的消耗，而是报告与你的程序相关的系统事件</strong>。</p><p>例如，<code>perf</code> 可以报告<strong>不佳的缓存局部性（poor cache locality）、大量的页错误（page faults）或活锁（livelocks）</strong>。下面是关于常见命令的简介：</p><ul><li><code>perf list</code> - 列出可以被 pref 追踪的事件；</li><li><code>perf stat COMMAND ARG1 ARG2</code> - 收集与某个进程或指令相关的事件；</li><li><code>perf record COMMAND ARG1 ARG2</code> - 记录命令执行的采样信息并将统计数据储存在<code>perf.data</code>中；</li><li><code>perf report</code> - 格式化并打印 <code>perf.data</code> 中的数据。</li></ul><h4 id="性能分析可视化">性能分析可视化</h4><p>使用分析器来分析真实的程序时，由于软件的复杂性，其输出结果中将包含大量的信息。人类是一种视觉动物，非常不善于阅读大量的文字。因此很多工具都提供了可视化分析器输出结果的功能。</p><p>对于<strong>采样分析器</strong>来说，常见的显示 CPU 分析数据的形式是 <a href="http://www.brendangregg.com/flamegraphs.html">火焰图</a>，火焰图会<strong>在 Y 轴显示函数调用关系，并在 X 轴显示其耗时的比例</strong>。火焰图同时还是可交互的，你可以深入程序的某一具体部分，并查看其栈追踪（你可以尝试点击下面的图片）。</p><p><a href="http://www.brendangregg.com/FlameGraphs/cpu-bash-flamegraph.svg"><img src="http://www.brendangregg.com/FlameGraphs/cpu-bash-flamegraph.svg" alt="FlameGraph"></a></p><p><strong>调用图和控制流图可以显示子程序之间的关系，它将函数作为节点并把函数调用作为边</strong>。将它们和分析器的信息（例如调用次数、耗时等）放在一起使用时，调用图会变得非常有用，它可以帮助我们分析程序的流程。 在 Python 中你可以使用 <a href="http://pycallgraph.slowchop.com/en/master/"><code>pycallgraph</code></a> 来生成这些图片。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/2/2f/A_Call_Graph_generated_by_pycallgraph.png" alt="Call Graph"></p><h4 id="资源监控">资源监控</h4><p>有时候，分析程序性能的<strong>第一步是搞清楚它所消耗的资源</strong>。程序变慢通常是因为它所需要的资源不够了。例如，没有足够的内存或者网络连接变慢的时候。</p><p>有很多很多的工具可以被用来显示不同的系统资源，例如 CPU 占用、内存使用、网络、磁盘使用等。</p><ul><li><p><strong>通用监控</strong> - 最流行的工具要数 <a href="https://htop.dev/"><code>htop</code></a> 了，它是 <a href="http://man7.org/linux/man-pages/man1/top.1.html"><code>top</code></a> 的改进版。<code>htop</code> 可以显示当前运行进程的多种统计信息。<code>htop</code> 有很多选项和快捷键，常见的有：</p><ul><li><code>&lt;F6&gt;</code> 进程排序、</li><li><code>t</code> 显示树状结构和</li><li><code>h</code> 打开或折叠线程。</li></ul><p>还可以留意一下 <a href="https://nicolargo.github.io/glances/"><code>glances</code></a> ，它的实现类似但是用户界面更好。如果需要合并测量全部的进程， <a href="http://dag.wiee.rs/home-made/dstat/"><code>dstat</code></a> 也是一个非常好用的工具，它可以实时地计算不同子系统资源的度量数据，例如 I/O、网络、 CPU 利用率、上下文切换等等；</p></li><li><p><strong>I/O 操作</strong> - <a href="http://man7.org/linux/man-pages/man8/iotop.8.html"><code>iotop</code></a> 可以显示实时 I/O 占用信息而且可以非常方便地检查某个进程是否正在执行大量的磁盘读写操作；</p></li><li><p><strong>磁盘使用</strong> - <a href="http://man7.org/linux/man-pages/man1/df.1.html"><code>df</code></a> 可以显示每个分区的信息，而 <a href="http://man7.org/linux/man-pages/man1/du.1.html"><code>du</code></a> 则可以显示当前目录下每个文件的磁盘使用情况（ <strong>d</strong>isk <strong>u</strong>sage）。<code>-h</code> 选项可以使命令以对人类（<strong>h</strong>uman）更加友好的格式显示数据；<a href="https://dev.yorhel.nl/ncdu"><code>ncdu</code></a>是一个交互性更好的 <code>du</code> ，它可以让你在不同目录下导航、删除文件和文件夹；</p></li><li><p><strong>内存使用</strong> - <a href="http://man7.org/linux/man-pages/man1/free.1.html"><code>free</code></a> 可以显示系统当前空闲的内存。内存也可以使用 <code>htop</code> 这样的工具来显示；</p></li><li><p><strong>打开文件</strong> - <a href="http://man7.org/linux/man-pages/man8/lsof.8.html"><code>lsof</code></a> 可以列出被进程打开的文件信息。 当我们需要查看某个文件是被哪个进程打开的时候，这个命令非常有用；</p></li><li><p><strong>网络连接和配置</strong> - <a href="http://man7.org/linux/man-pages/man8/ss.8.html"><code>ss</code></a> 能帮助我们监控网络包的收发情况以及网络接口的显示信息。<strong><code>ss</code> 常见的一个使用场景是找到端口被进程占用的信息</strong>。<strong>如果要显示路由、网络设备和接口信息，你可以使用 <a href="http://man7.org/linux/man-pages/man8/ip.8.html"><code>ip</code></a> 命令</strong>。注意，<code>netstat</code> 和 <code>ifconfig</code> 这两个命令已经被前面那些工具所代替了。</p></li><li><p><strong>网络使用</strong> - <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a> 和 <a href="http://www.ex-parrot.com/pdw/iftop/"><code>iftop</code></a> 是非常好的用于对<strong>网络占用进行监控</strong>的交互式命令行工具。</p></li></ul><p>如果你希望测试一下这些工具，你可以使用 <a href="https://linux.die.net/man/1/stress"><code>stress</code></a> 命令来为系统人为地增加负载。</p><h4 id="基准比较测试">基准比较测试</h4><p>有时候，你只需要对黑盒程序进行基准测试，并依此对软件选择进行评估。 类似 <a href="https://github.com/sharkdp/hyperfine"><code>hyperfine</code></a> 这样的命令行可以帮你快速进行基准测试。例如，我们在 shell 工具和脚本那一节课中我们推荐使用 <code>fd</code> 来代替 <code>find</code>。我们这里可以用 <code>hyperfine</code> 来比较一下它们。</p><p>例如，下面的例子中，我们可以看到 <code>fd</code> 比 <code>find</code> 要快20倍。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hyperfine --warmup 3 <span class="string">&#x27;fd -e jpg&#x27;</span> <span class="string">&#x27;find . -iname &quot;*.jpg&quot;&#x27;</span></span><br><span class="line">Benchmark <span class="comment">#1: fd -e jpg</span></span><br><span class="line">  Time (mean ± σ):      51.4 ms ±   2.9 ms    [User: 121.0 ms, System: 160.5 ms]</span><br><span class="line">  Range (min … max):    44.2 ms …  60.1 ms    56 runs</span><br><span class="line"></span><br><span class="line">Benchmark <span class="comment">#2: find . -iname &quot;*.jpg&quot;</span></span><br><span class="line">  Time (mean ± σ):      1.126 s ±  0.101 s    [User: 141.1 ms, System: 956.1 ms]</span><br><span class="line">  Range (min … max):    0.975 s …  1.287 s    10 runs</span><br><span class="line"></span><br><span class="line">Summary</span><br><span class="line">  <span class="string">&#x27;fd -e jpg&#x27;</span> ran</span><br><span class="line">   21.89 ± 2.33 <span class="built_in">times</span> faster than <span class="string">&#x27;find . -iname &quot;*.jpg&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>和 debug 一样，浏览器也包含了很多不错的性能分析工具，可以用来分析页面加载，让我们可以搞清楚时间都消耗在什么地方（加载、渲染、脚本等等）。 更多关于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Profiling_with_the_Built-in_Profiler">Firefox</a> 和 <a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools">Chrome</a> 的信息可以点击链接查看。</p>]]></content>
      
      
      <categories>
          
          <category> The Missing Semester </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debug </tag>
            
            <tag> Profile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MIT The Missing Semester] Lec06: Git</title>
      <link href="/2025/03/02/MIT-The-Missing-Semester-Lec06-Git/"/>
      <url>/2025/03/02/MIT-The-Missing-Semester-Lec06-Git/</url>
      
        <content type="html"><![CDATA[<h1>Lec06：版本控制（Git）</h1><p>本 Lec 的主要内容：</p><ul><li>什么是版本控制系统？</li><li>Git 的数据模型是什么样的？</li><li>Git 的命令行接口有哪些？</li><li>Git 的一些高级操作</li><li>学习 Git 的一些资源推荐</li></ul><h2 id="版本控制系统（VCSs）">版本控制系统（VCSs）</h2><h3 id="什么是版本控制系统？">什么是版本控制系统？</h3><p>版本控制系统 (VCSs) 是一类用于<strong>追踪源代码（或其他文件、文件夹）改动的工具</strong>。顾名思义，这些工具可以帮助我们<strong>管理代码的修改历史</strong>；不仅如此，它还可以<strong>让协作编码变得更方便</strong>。VCS通过一系列的==快照==将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照==创建者的信息以及每个快照的相关信息==等等。</p><p>为什么说版本控制系统非常有用？即使你只是一个人进行编程工作，它也可以帮你<strong>创建项目的快照</strong>、<strong>记录每个改动的目的</strong>、<strong>基于多分支并行开发</strong>等等。和别人<strong>协作开发</strong>时，它更是一个无价之宝：你可以<strong>看到别人对代码进行的修改</strong>，同时<strong>解决由于并行开发引起的冲突</strong>。</p><p>现代的版本控制系统可以帮助你轻松地（甚至自动地）回答以下问题：</p><ul><li>当前模块是谁编写的？</li><li>这个文件的这一行是什么时候被编辑的？是谁作出的修改？修改原因是什么呢？</li><li>最近的1000个版本中，何时 / 为什么导致了单元测试失败？</li></ul><p>尽管版本控制系统有很多， 其事实上的标准则是 <strong>Git</strong> 。</p><blockquote><p>因为 Git 接口的抽象泄漏（leaky abstraction）问题，通过自顶向下的方式（从命令行接口开始）学习 Git 可能会让人感到非常困惑。很多时候你只能死记硬背一些命令行，然后像使用魔法一样使用它们，一旦出现问题，你就不知道该怎么继续往下了。</p><p>尽管 Git 的接口有些丑陋，但是它的底层设计和思想却是非常优雅的。丑陋的接口只能靠死记硬背，而优雅的底层设计则非常容易被人理解。因此，我们将通过一种自底向上的方式向你介绍 Git。我们会从数据模型开始，最后再学习它的接口。一旦你搞懂了 Git 的数据模型，再学习其接口并理解这些接口是如何操作数据模型的就非常容易了。</p></blockquote><h2 id="Git-的数据模型">Git 的数据模型</h2><p>进行版本控制的方法很多。Git 拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。</p><h3 id="快照">快照</h3><p>Git 将==顶级目录==中的文件和文件夹作为集合，并通过一系列快照来管理其历史记录。</p><p>在 Git 的术语里，**文件被称作 Blob 对象（数据对象），也就是一组数据。目录则被称之为 “树”，它将==名字与 Blob 对象或树对象进行映射==（使得==目录中可以包含其他目录==）。快照则是被追踪的==最顶层的树==。**例如，一个树看起来可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;root&gt; (tree)</span><br><span class="line">|</span><br><span class="line">+- foo (tree)</span><br><span class="line">|  |</span><br><span class="line">|  + bar.txt (blob, contents = &quot;hello world&quot;)</span><br><span class="line">|</span><br><span class="line">+- baz.txt (blob, contents = &quot;git is wonderful&quot;)</span><br></pre></td></tr></table></figure><p>这个顶层的树包含了两个元素，一个名为 “foo” 的树（它本身包含了一个 blob 对象 “bar.txt”），以及一个 blob 对象 “baz.txt”。</p><h3 id="历史记录建模：关联快照">历史记录建模：关联快照</h3><p>在 Git 中，历史记录是一个由快照组成的==有向无环图==。这代表 Git 中的每个快照都有一系列的 <strong>“父辈”</strong>，也就是其之前的一系列快照。==注意，快照具有多个 “父辈” 而非一个，因为某个快照可能由多个父辈而来==。例如，经过合并后的两条分支。</p><p>在 Git 中，这些快照被称为 “提交”（commit）。通过可视化的方式来表示这些历史提交记录时，看起来差不多是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o &lt;-- o &lt;-- o &lt;-- o</span><br><span class="line">            ^  </span><br><span class="line">             \</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></table></figure><p><strong>箭头指向了当前提交的父辈</strong>。在第三次提交之后，历史记录分岔成了两条独立的分支。这可能因为<strong>此时需要同时开发两个不同的特性，它们之间是相互独立的</strong>。开发完成后，这些分支可能会被合并，并且创建一个新的提交，这个新的提交会==同时包含==这些特性。新的提交会创建一个新的历史记录，看上去像这样（最新的合并提交用粗体标记）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o &lt;-- o &lt;-- o &lt;-- o &lt;---- o</span><br><span class="line">            ^            /</span><br><span class="line">             \          v</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></table></figure><p><strong>Git 中的提交是不可改变的</strong>。但这并不代表错误不能被修改，只不过这种 “修改” 实际上是创建了一个全新的提交记录。而引用（参见下文）则被更新为指向这些新的提交。</p><h3 id="Git-的数据模型及其伪码表示">Git 的数据模型及其伪码表示</h3><p>以下是 Git 数据模型的伪码表示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 文件就是一组数据</span><br><span class="line">type blob = array&lt;byte&gt;</span><br><span class="line"></span><br><span class="line">// 目录就是包含目录或文件的映射表</span><br><span class="line">type tree = map&lt;string, tree | blob&gt;</span><br><span class="line"></span><br><span class="line">// 每个提交都包含一个或多个父辈，元数据（描述作者，提交信息等）和顶层树（即快照）</span><br><span class="line">type commit = struct &#123;</span><br><span class="line">    parent: array&lt;commit&gt;</span><br><span class="line">    author: string</span><br><span class="line">    message: string</span><br><span class="line">    snapshot: tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种简洁的历史模型。</p><h3 id="Git-数据模型中的对象的数据寻址">Git 数据模型中的对象的数据寻址</h3><p>Git 中的对象可以是 blob、tree 或 commit：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type object = blob | tree | commit</span><br></pre></td></tr></table></figure><p>Git 在储存数据时，所有的对象都会基于它们的 <a href="https%EF%BC%9A//en.wikipedia.org/wiki/SHA-1">SHA-1 哈希</a> 进行寻址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objects = map&lt;string, object&gt;</span><br><span class="line"></span><br><span class="line">def store(object):</span><br><span class="line">    id = sha1(object)</span><br><span class="line">    objects[id] = object</span><br><span class="line"></span><br><span class="line">def load(id):</span><br><span class="line">    return objects[id]</span><br></pre></td></tr></table></figure><p>Blobs、tree 和 commit 都一样，==它们都是对象==。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是==仅仅保存了它们的哈希值作为引用==。</p><p>例如，<a href="https%EF%BC%9A//missing-semester-cn.github.io/2020/version-control/#snapshots">上面</a>例子中的树（可以通过 <code>git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d</code> 来进行可视化），看上去是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt</span><br><span class="line">040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo</span><br></pre></td></tr></table></figure><p>树本身会包含一些指向其他内容的指针，例如 <code>baz.txt</code> （blob）和 <code>foo</code> （tree）。如果我们用 <code>git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85</code>，即通过哈希值查看 baz.txt 的内容，会得到以下信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git is wonderful</span><br></pre></td></tr></table></figure><h3 id="引用">引用</h3><p>现在，所有的快照都可以通过它们的 SHA-1 哈希值来标记了。但这也太不方便了，谁也记不住一串 40 位的十六进制字符。</p><p>针对这一问题，Git 的解决方法是给这些哈希值<strong>赋予人类可读的名字，也就是引用（references）</strong>。==引用是指向提交的指针==。与对象不同的是，它是 <em>可变</em> 的（引用可以被更新，指向新的提交）。例如，<code>master</code> 引用通常会指向主分支的最新一次提交。</p><p>引用的数据模型如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 前一个string是人类可读名字，后一个string是哈希值</span><br><span class="line">references = map&lt;string, string&gt;</span><br><span class="line"></span><br><span class="line">def update_reference(name, id):</span><br><span class="line">    references[name] = id</span><br><span class="line"></span><br><span class="line">def read_reference(name):</span><br><span class="line">    return references[name]</span><br><span class="line"></span><br><span class="line">def load_reference(name_or_id):</span><br><span class="line">    if name_or_id in references:</span><br><span class="line">        return load(references[name_or_id])</span><br><span class="line">    else:</span><br><span class="line">        return load(name_or_id)</span><br><span class="line">        </span><br><span class="line">// 单个引用是从人类可读名字到哈希值的映射</span><br></pre></td></tr></table></figure><p>这样，Git 就可以使用诸如 “master” 这样人类可读的名称来表示历史记录中某个特定的提交，而不需要在使用一长串十六进制字符了。</p><p>有一个细节需要我们注意， 通常情况下，我们会想要知道 “我们当前所在位置”，并将其标记下来。这样当我们创建新的快照的时候，我们就可以知道它的相对位置（如何设置它的 “父辈” ）。<strong>在 Git 中，我们当前的位置有一个特殊的索引，它就是 “HEAD”。</strong></p><h3 id="Git-的数据仓库">Git 的数据仓库</h3><p>最后，我们可以粗略地给出 <strong>Git 仓库的定义了：<code>对象</code> 和 <code>引用</code>。</strong></p><p><strong>在硬盘上，Git 仅存储对象和引用</strong>：因为其数据模型仅包含这些东西。<strong>所有的 <code>git</code> 命令都对应着对提交树的操作，例如增加对象，增加或删除引用。</strong></p><p>当你输入某个指令时，请思考一下这条命令是如何对底层的图数据结构进行操作的。另一方面，如果你希望修改提交树，例如 “丢弃未提交的修改“ 和 ”将 ‘master’ 引用指向提交 <code>5d83f9e</code> 时“，有什么命令可以完成该操作（针对这个具体问题，你可以使用 <code>git checkout master; git reset --hard 5d83f9e</code>）</p><h3 id="Git-暂存区">Git 暂存区</h3><p>Git 中还包括一个和数据模型完全不相关的概念，但它确是创建提交的接口的一部分。</p><p>就上面介绍的快照系统来说，你也许会期望它的实现里包括一个 “创建快照” 的命令，该命令能够基于当前工作目录的当前状态创建一个全新的快照。有些版本控制系统确实是这样工作的，但 Git 不是。我们希望简洁的快照，而且每次从当前状态创建快照可能效果并不理想。例如，考虑如下场景，你开发了两个独立的特性，然后你希望创建两个独立的提交，其中第一个提交仅包含第一个特性，而第二个提交仅包含第二个特性。或者，假设你在调试代码时添加了很多打印语句，然后你仅仅希望提交和修复 bug 相关的代码而丢弃所有的打印语句。</p><p>Git 处理<strong>这些场景</strong>的方法是使用一种叫做 “暂存区（staging area）”的机制，它允许你指定下次快照中要包括那些改动。</p><h2 id="Git-的命令行接口">Git 的命令行接口</h2><p>为了避免重复信息，我们将不会详细解释以下命令行。强烈推荐阅读 <a href="https%EF%BC%9A//git-scm.com/book/zh/v2">Pro Git 中文版</a>或可以观看本讲座的视频来学习。</p><h3 id="基础">基础</h3><ul><li><p><code>git help &lt;command&gt;</code>： 获取 git 命令的帮助信息</p></li><li><p><code>git init</code>： 创建一个新的 git 仓库，其数据会存放在一个名为 <code>.git</code> 的目录下</p></li><li><p><code>git status</code>： 显示当前的仓库状态</p></li><li><p><code>git add &lt;filename&gt;</code>： 添加文件到暂存区</p></li><li><p><code>git commit</code>： 创建一个新的提交</p><ul><li>如何编写 <a href="https%EF%BC%9A//tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">良好的提交信息</a>!</li><li>为何要 <a href="https%EF%BC%9A//chris.beams.io/posts/git-commit/">编写良好的提交信息</a></li></ul></li><li><p><code>git log</code>： 显示历史日志</p></li><li><p><code>git log --all --graph --decorate</code>： 可视化历史记录（有向无环图）</p></li><li><p><code>git diff &lt;filename&gt;</code>： 显示与暂存区文件的差异</p></li><li><p><code>git diff &lt;revision&gt; &lt;filename&gt;</code>： 显示某个文件两个版本之间的差异</p></li><li><p><code>git checkout &lt;revision&gt;</code>： 更新 HEAD 和目前的分支</p></li></ul><h3 id="分支和合并">分支和合并</h3><ul><li><p><code>git branch</code>：显示分支</p></li><li><p><code>git branch &lt;name&gt;</code>：创建分支</p></li><li><p><code>git checkout -b &lt;name&gt;</code>：创建分支并切换到该分支</p><ul><li>相当于 <code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code></li></ul></li><li><p><code>git merge &lt;revision&gt;</code>：合并到当前分支</p></li><li><p><code>git mergetool</code>：使用工具来处理合并冲突</p></li><li><p><code>git rebase</code>：将一系列补丁变基（rebase）为新的基线</p></li></ul><h3 id="远端操作">远端操作</h3><ul><li><code>git remote</code>：列出远端</li><li><code>git remote add &lt;name&gt; &lt;url&gt;</code>：添加一个远端</li><li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>：将对象传送至远端并更新远端引用</li><li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>：创建本地和远端分支的关联关系</li><li><code>git fetch</code>：从远端获取对象/索引</li><li><code>git pull</code>：相当于 <code>git fetch; git merge</code></li><li><code>git clone</code>：从远端下载仓库</li></ul><h3 id="撤销">撤销</h3><ul><li><code>git commit --amend</code>：编辑提交的内容或信息</li><li><code>git reset HEAD &lt;file&gt;</code>：恢复暂存的文件</li><li><code>git checkout -- &lt;file&gt;</code>：丢弃修改</li><li><code>git restore</code>：git 2.32 版本后取代 git reset 进行许多撤销操作</li></ul><h3 id="Git-高级操作">Git 高级操作</h3><ul><li><code>git config</code>：Git 是一个 <a href="https://git-scm.com/docs/git-config">高度可定制的</a> 工具</li><li><code>git clone --depth=1</code>：浅克隆（shallow clone），不包括完整的版本历史信息，只克隆最新的快照</li><li><code>git add -p</code>：交互式暂存</li><li><code>git rebase -i</code>：交互式变基</li><li><code>git blame</code>：查看最后修改某行的人</li><li><code>git stash</code>：暂时移除工作目录下的修改内容</li><li><code>git bisect</code>：通过二分查找搜索历史记录</li><li><code>.gitignore</code>：<a href="https://git-scm.com/docs/gitignore">指定</a> Git 不要追踪的文件</li></ul><h2 id="杂项">杂项</h2><ul><li><strong>图形用户界面</strong>: Git 的 <a href="https://git-scm.com/downloads/guis">图形用户界面客户端</a> 有很多，但是我们自己并不使用这些图形用户界面的客户端，我们选择使用命令行接口</li><li><strong>Shell 集成</strong>: 将 Git 状态集成到：你的 shell 中会非常方便。(<a href="https://github.com/olivierverdier/zsh-git-prompt">zsh</a>, <a href="https://github.com/magicmonty/bash-git-prompt">bash</a>)。<a href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a> 这样的框架中一般以及集成了这一功能</li><li><strong>编辑器集成</strong>: 和上面一条类似，将 Git 集成到编辑器中好处多多。<a href="https://github.com/tpope/vim-fugitive">fugitive.vim</a> 是 Vim 中集成 GIt 的常用插件</li><li><strong>工作流</strong>: 我们已经讲解了数据模型与一些基础命令，但还没讨论到进行大型项目时的一些惯例 ( 有<a href="https://nvie.com/posts/a-successful-git-branching-model/">很多</a> <a href="https://www.endoflineblog.com/gitflow-considered-harmful">不同的</a> <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">处理方法</a>)</li><li><strong>GitHub</strong>: Git 并不等同于 GitHub。 在 GitHub 中：你需要使用一个被称作 <a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">拉取请求（pull request）</a>的方法来向其他项目贡献代码</li><li><strong>其他 Git 提供商</strong>: GitHub 并不是唯一的。还有像 <a href="https://about.gitlab.com/">GitLab</a> 和 <a href="https://bitbucket.org/">BitBucket</a> 这样的平台。</li></ul><h2 id="资源">资源</h2><ul><li><a href="https://git-scm.com/book/en/v2">Pro Git</a>，<strong>强烈推荐</strong>！学习前五章的内容可以教会：你流畅使用 Git 的绝大多数技巧，因为：你已经理解了 Git 的数据模型。后面的章节提供了很多有趣的高级主题。（<a href="https://git-scm.com/book/zh/v2">Pro Git 中文版</a>）；</li><li><a href="https://ohshitgit.com/">Oh Shit, Git!?!</a>，简短的介绍了如何从 Git 错误中恢复；</li><li><a href="https://eagain.net/articles/git-for-computer-scientists/">Git for Computer Scientists</a>，简短的介绍了 Git 的数据模型，与本文相比包含较少量的伪代码以及大量的精美图片；</li><li><a href="https://jwiegley.github.io/git-from-the-bottom-up/">Git from the Bottom Up</a> 详细的介绍了 Git 的实现细节，而不仅仅局限于数据模型。好奇的同学可以看看；</li><li><a href="https://smusamashah.github.io/blog/2017/10/14/explain-git-in-simple-words">How to explain git in simple words</a>；</li><li><a href="https://learngitbranching.js.org/">Learn Git Branching</a> 通过基于浏览器的游戏来学习 Git ；</li></ul>]]></content>
      
      
      <categories>
          
          <category> The Missing Semester </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MIT The Missing Semester] Lec05: Command Line Environment</title>
      <link href="/2025/03/02/MIT-The-Missing-Semester-Lec05-Command-Line-Environment/"/>
      <url>/2025/03/02/MIT-The-Missing-Semester-Lec05-Command-Line-Environment/</url>
      
        <content type="html"><![CDATA[<h1>Lec05：命令行环境</h1><p>本 Lec 主要学习：</p><ul><li>如何同时执行多个不同的进程并追踪它们的状态</li><li>如何停止或暂停某个进程</li><li>如何使进程在后台运行</li><li>定义别名</li><li>如何使用 SSH 操作远端机器</li></ul><h2 id="任务控制">任务控制</h2><p>某些情况下我们需要中断正在执行的任务，比如当一个命令需要执行很长时间才能完成时（假设我们在使用 <code>find</code> 搜索一个非常大的目录结构）。大多数情况下，我们可以使用 <code>Ctrl-C</code> 来停止命令的执行。但是<strong>它的工作原理是什么呢？为什么有的时候会无法结束进程？</strong></p><h3 id="结束进程">结束进程</h3><p>你的 shell 会使用 <em>UNIX 提供的信号机制</em> 执行==进程间通信==。当一个进程接收到信号时，它会</p><ol><li>停止执行、处理该信号</li><li>基于信号传递的信息来改变其执行。</li></ol><p>就这一点而言，信号是一种<em>软件中断</em>。</p><p>在上面提到的例子中，当我们输入 <code>Ctrl-C</code> 时，shell 会发送一个<code>SIGINT</code> （Signal Interrupt）信号到进程。</p><p>程序可以捕捉到这些信号，并自定义处理方式，比如下面这个 Python 程序，它捕获了信号 <code>SIGINT</code> 并忽略它，这导致你按 <code>Ctrl-C</code> 时，这个程序不会停止。为了停止这些程序，需要使用 <code>SIGINT</code> 以外的终端信号，比如 <code>SIGQUIT</code>，可以通过 <code>Ctrl-\</code> 发送该信号。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> signal, time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">signum, time</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nI got a SIGINT, but I am not stopping&quot;</span>)</span><br><span class="line"></span><br><span class="line">signal.signal(signal.SIGINT, handler)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    time.sleep(<span class="number">.1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\r&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>当向这个程序发送两次 <code>SIGINT</code>，然后再发送一次 <code>SIGQUIT</code>，以下是结果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python sigint.py</span></span><br><span class="line">24^C</span><br><span class="line">I got a SIGINT, but I am not stopping</span><br><span class="line">26^C</span><br><span class="line">I got a SIGINT, but I am not stopping</span><br><span class="line">30^\[1]    39913 quit       python sigint.pyƒ</span><br></pre></td></tr></table></figure><p>尽管 <code>SIGINT</code> 和 <code>SIGQUIT</code> 都常常用来发出和终止程序相关的请求。<code>SIGTERM</code> 则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用 <a href="https://www.man7.org/linux/man-pages/man1/kill.1.html"><code>kill</code></a> 命令, 它的语法是： <code>kill -TERM &lt;PID&gt;</code>。</p><blockquote><p><code>PID</code> 是进程号，可以通过</p><ol><li><code>ps aux | grep &lt;pattern&gt;</code> 查看符合指定模式的进程的进程号</li><li><code>pgrep &lt;pattern&gt;</code> 查看符合模式的进程的进程号，与上面类似<ul><li><code>-l</code>：显示进程 ID 和进程名称</li><li><code>-u user</code>：仅显示指定用户的进程</li><li><code>-f</code>：匹配整个命令行，而不仅仅是进程名</li><li><code>-x</code>：要求完全匹配</li><li><code>-v</code>：反转匹配</li></ul></li></ol></blockquote><h3 id="暂停和后台执行进程">暂停和后台执行进程</h3><p>信号可以让进程做其他的事情，而不仅仅是终止它们。例如，<code>SIGSTOP</code> 会让进程暂停。在终端中，键入 <code>Ctrl-Z</code> 会让 shell 发送 <code>SIGTSTP</code> 信号，<code>SIGTSTP</code>是 Terminal Stop 的缩写（即 <code>terminal</code> 版本的 SIGSTOP）。</p><blockquote><p><code>SIGSTOP</code> 和 <code>SIGTSTP</code> 的比较：</p><p><code>SIGSTOP</code>：</p><ul><li>强制暂停进程</li><li>无法被捕获、阻塞或忽略</li><li>用于系统级别的进程控制</li></ul><p><code>SIGTSTP</code>：</p><ul><li>用户请求暂停进程</li><li>可以被捕获或忽略</li><li>用于交互式终端中的进程控制</li></ul></blockquote><p>我们可以使用 <a href="https://www.man7.org/linux/man-pages/man1/fg.1p.html"><code>fg</code></a> 或 <a href="http://man7.org/linux/man-pages/man1/bg.1p.html"><code>bg</code></a> 命令恢复暂停的工作。它们分别表示<strong>在前台继续或在后台继续</strong>。</p><p><a href="http://man7.org/linux/man-pages/man1/jobs.1p.html"><code>jobs</code></a> 命令会列出==当前终端会话中尚未完成==的全部任务。你可以使用 pid 引用这些任务（也可以用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pgrep</code></a> 找出 pid）。更加符合直觉的操作是你可以使用百分号 + 任务编号（<code>jobs</code> 会打印任务编号在第一列）来选取该任务。如果要选择最近的一个任务，可以使用 <code>$!</code> 这一特殊参数。</p><p>还有一件事情需要掌握，那就是命令中的 <code>&amp;</code> 后缀可以让命令在<strong>直接在后台运行</strong>，这使得你可以直接在 shell 中继续做其他操作，<strong>不过它此时还是会使用 shell 的标准输出（即它的输出内容还是会打印到终端中），这一点有时会比较恼人（这种情况可以使用 shell 重定向处理）。</strong></p><p><strong>让已经在运行的进程转到后台运行</strong>，你可以先 <code>Ctrl-Z</code> ，然后再 <code>bg</code>。<strong>注意，后台的进程仍然是你的终端进程的子进程，一旦你关闭终端（会发送另外一个信号 <code>SIGHUP</code>），这些后台的进程也会终止</strong>。为了防止这种情况发生，你可以使用 <a href="https://www.man7.org/linux/man-pages/man1/nohup.1.html"><code>nohup</code></a> (一个用来忽略 <code>SIGHUP</code> 的封装) 来运行程序。针对已经运行的程序，可以使用<code>disown</code> 。除此之外，你可以使用<strong>终端多路复用器</strong>来实现，下一章节我们会进行详细地探讨。</p><p>下面这个简单的会话中展示了这些概念的应用：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sleep</span> 1000</span></span><br><span class="line">^Z</span><br><span class="line">[1]  + 18653 suspended  sleep 1000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">nohup</span> <span class="built_in">sleep</span> 2000 &amp;</span></span><br><span class="line">[2] 18745</span><br><span class="line">appending output to nohup.out</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[1]  + suspended  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">bg</span> %1</span></span><br><span class="line">[1]  - 18653 continued  sleep 1000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[1]  - running    sleep 1000</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -STOP %1</span></span><br><span class="line">[1]  + 18653 suspended (signal)  sleep 1000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[1]  + suspended (signal)  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -SIGHUP %1</span></span><br><span class="line">[1]  + 18653 hangup     sleep 1000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -SIGHUP %2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> %2</span></span><br><span class="line">[2]  + 18745 terminated  nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br></pre></td></tr></table></figure><p><code>SIGKILL</code> 是一个特殊的信号，它<strong>不能被进程捕获并且它会马上结束该进程</strong>。不过这样做会有一些<strong>副作用</strong>，例如留下<strong>孤儿进程</strong>。</p><p>你可以在 <a href="https://en.wikipedia.org/wiki/Signal_(IPC)">这里</a> 或输入 <a href="https://www.man7.org/linux/man-pages/man7/signal.7.html"><code>man signal</code></a> 或使用 <code>kill -l</code> 来获取更多关于信号的信息。</p><h2 id="终端多路复用">终端多路复用</h2><p>当你在使用命令行时，你通常会希望<strong>同时执行多个任务</strong>。举例来说，你可以想要<strong>同时运行你的编辑器，并在终端的另外一侧执行程序</strong>。尽管再打开一个新的终端窗口也能达到目的，使用==终端多路复用器==则是一种更好的办法。</p><p>像 <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a> 这类的终端多路复用器可以允许我们<strong>基于面板和标签</strong>分割出多个终端窗口，这样你便可以同时与<strong>多个 shell 会话</strong>进行交互。</p><p>不仅如此，终端多路复用使我们可以<strong>分离当前终端会话并在将来重新连接</strong>（在 detach 的时候不会终止 tmux 会话内的进程，并可以在将来重新连接至会话，会话的状态会被保留）。</p><p>这让你<strong>操作远端设备时</strong>的工作流大大改善，避免了 <code>nohup</code> 和其他类似技巧的使用。</p><p>现在最流行的终端多路器是 <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a>。<code>tmux</code> 是一个高度可定制的工具，你可以使用相关快捷键创建多个标签页并在它们间导航。</p><p><code>tmux</code> 中对象的继承结构如下：</p><ul><li><strong>会话</strong> - 每个会话都是一个独立的工作区，其中包含一个或多个窗口<ul><li><code>tmux</code> 开始一个新的会话</li><li><code>tmux new -s NAME</code> 开始一个新的会话并指定其名称</li><li><code>tmux ls</code> 列出当前所有会话</li><li><code>&lt;prefix&gt; d</code> 从当前会话分离</li><li><code>tmux a</code> 重新连接最后一个会话。可以通过 <code>-t NAME</code> 来指定具体的会话</li></ul></li><li><strong>窗口</strong> - 相当于编辑器或是浏览器中的 <em>标签页</em>，从视觉上将一个会话分隔为多个部分<ul><li><code>&lt;prefix&gt; c</code> 创建一个新的窗口，使用 <code>&lt;C-d&gt;</code> 关闭</li><li><code>&lt;prefix&gt; N</code> 跳转到第 N 个窗口，注意每个窗口都是有编号的</li><li><code>&lt;prefix&gt; p</code> 切换到前一个窗口</li><li><code>&lt;prefix&gt; n</code> 切换到后一个窗口</li><li><code>&lt;prefix&gt; ,</code> 重命名当前窗口</li><li><code>&lt;prefix&gt; w</code> 列出当前所有窗口</li></ul></li><li><strong>面板</strong> - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell<ul><li><code>&lt;prefix&gt; &quot;</code> 水平分割，已改为 <code>&lt;prefix&gt; -</code></li><li><code>&lt;prefix&gt; %</code> 垂直分割，已改为 <code>&lt;prefix&gt; ｜</code></li><li><code>&lt;prefix&gt; &lt;arrow-keys&gt;</code> 切换到指定方面的面板，使用方向键</li><li><code>&lt;prefix&gt; z</code> 切换当前面板的缩放</li><li><code>&lt;prefix&gt; [</code> 开始往回卷动屏幕。你可以按下空格键来开始选择，回车键复制选中的部分</li><li><code>&lt;prefix&gt; &lt;space&gt;</code> 在不同的面板排布间切换</li></ul></li></ul><blockquote><p>扩展阅读： <a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">这里</a> 是一份 <code>tmux</code> 快速入门教程， <a href="http://linuxcommand.org/lc3_adv_termmux.php">而这一篇</a> 文章则更加详细，它包含了 <code>screen</code> 命令。你也许想要掌握 <a href="https://www.man7.org/linux/man-pages/man1/screen.1.html"><code>screen</code></a> 命令，因为在大多数 UNIX 系统中都默认安装有该程序。</p></blockquote><h2 id="别名">别名</h2><p>输入一长串包含许多选项的命令会非常麻烦。因此，大多数 shell 都支持设置别名。<strong>shell 的别名相当于一个长命令的缩写，shell 会自动将其替换成原本的命令</strong>。例如，bash 中的别名语法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> alias_name=<span class="string">&quot;command_to_alias arg1 arg2&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意， <code>=</code> 两边是没有空格的，因为 <a href="https://www.man7.org/linux/man-pages/man1/alias.1p.html"><code>alias</code></a> 是一个 shell 命令，它只接受一个参数。</p></blockquote><p>别名有许多很方便的特性：</p><ul><li>常用命令的缩写</li><li>打错命令下的纠正</li><li>重新定义一些命令的默认行为</li><li>别名可以嵌套（别名内可以包含其他别名）</li><li>忽略或禁用别名</li><li>获取别名的定义（使用 <code>alias NAME</code>）</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建常用命令的缩写</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&quot;ls -lh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 能够少输入很多</span></span><br><span class="line"><span class="built_in">alias</span> gs=<span class="string">&quot;git status&quot;</span></span><br><span class="line"><span class="built_in">alias</span> gc=<span class="string">&quot;git commit&quot;</span></span><br><span class="line"><span class="built_in">alias</span> v=<span class="string">&quot;vim&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 手误打错命令也没关系</span></span><br><span class="line"><span class="built_in">alias</span> sl=<span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新定义一些命令行的默认行为</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">mv</span>=<span class="string">&quot;mv -i&quot;</span>           <span class="comment"># -i prompts before overwrite</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">mkdir</span>=<span class="string">&quot;mkdir -p&quot;</span>     <span class="comment"># -p make parent dirs as needed</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">df</span>=<span class="string">&quot;df -h&quot;</span>           <span class="comment"># -h prints human readable format</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 别名可以组合使用</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&quot;ls -A&quot;</span></span><br><span class="line"><span class="built_in">alias</span> lla=<span class="string">&quot;la -l&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在忽略某个别名</span></span><br><span class="line">\<span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 或者禁用别名</span></span><br><span class="line"><span class="built_in">unalias</span> la</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取别名的定义</span></span><br><span class="line"><span class="built_in">alias</span> ll</span><br><span class="line"><span class="comment"># 会打印 ll=&#x27;ls -lh&#x27;</span></span><br></pre></td></tr></table></figure><p>值得注意的是，在默认情况下 shell 并不会保存别名。为了让别名持续生效，你需要将配置放进 shell 的启动文件里，像是 <code>.bashrc</code> 或 <code>.zshrc</code>，下一节我们就会讲到。</p><h2 id="配置文件（Dotfiles）">配置文件（Dotfiles）</h2><p>很多<strong>程序的配置</strong>都是通过纯文本格式的被称作 <em>点文件</em> 的配置文件来完成的（之所以称为点文件，是因为它们的文件名以 <code>.</code> 开头，例如 <code>~/.vimrc</code>。也正因为此，它们<strong>默认是隐藏文件</strong>，<code>ls</code> 并不会显示它们）。</p><p>shell 的配置也是通过这类文件完成的。在启动时，你的 shell 程序会读取很多文件以加载其配置项。根据 shell 本身的不同，你从登录开始还是以交互的方式完成这一过程可能会有很大的不同。关于这一话题，<a href="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html">这里</a> 有非常好的资源。</p><p>对于 <code>bash</code> 来说，在大多数系统下，你可以通过编辑 <code>.bashrc</code> 或 <code>.bash_profile</code> 来进行配置。在文件中你可以添加<strong>需要在启动时执行的命令</strong>，例如上文我们讲到过的<strong>别名</strong>，或者是你的<strong>环境变量</strong>。</p><blockquote><p>实际上，很多程序都要求你在 shell 的配置文件中包含一行类似 <code>export PATH=&quot;$PATH:/path/to/program/bin&quot;</code> 的命令，这样才能确保这些程序能够被 shell 找到。</p></blockquote><p>以下是一些可以通过点文件配置的常用工具：</p><ul><li><code>bash</code> - <code>~/.bashrc</code> 和 <code>~/.bash_profile</code></li><li><code>git</code> - <code>~/.gitconfig</code></li><li><code>vim</code> - <code>~/.vimrc</code> 和 <code>~/.vim</code> 目录</li><li><code>ssh</code> - <code>~/.ssh/config</code></li><li><code>tmux</code> - <code>~/.tmux.conf</code></li></ul><p>我们应该如何管理这些配置文件呢？它们应该<strong>在它们的文件夹</strong>下，并使用<strong>版本控制系统</strong>进行管理，然后通过脚本将其 <strong>符号链接</strong> 到需要的地方。这么做有如下好处：</p><ul><li><strong>安装简单</strong>: 如果你登录了一台新的设备，在这台设备上应用你的配置只需要几分钟的时间</li><li><strong>可移植性</strong>: 你的工具在任何地方都以相同的配置工作</li><li><strong>同步</strong>: 在一处更新配置文件，可以同步到其他所有地方</li><li><strong>变更追踪</strong>: 你可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的</li></ul><p>配置文件中需要放些什么？你可以通过在线文档和<a href="https://en.wikipedia.org/wiki/Man_page">帮助手册</a>了解所使用工具的设置项。另一个方法是在网上搜索有关特定程序的文章，作者们在文章中会分享他们的配置。还有一种方法就是直接浏览其他人的配置文件：你可以在这里找到无数的<a href="https://github.com/search?o=desc&amp;q=dotfiles&amp;s=stars&amp;type=Repositories">dotfiles 仓库</a> —— 其中最受欢迎的那些可以在<a href="https://github.com/mathiasbynens/dotfiles">这里</a>找到（我们建议你不要直接复制别人的配置）。<a href="https://dotfiles.github.io/">这里</a> 也有一些非常有用的资源。</p><p>本课程的老师们也在 GitHub 上开源了他们的配置文件： <a href="https://github.com/anishathalye/dotfiles">Anish</a>, <a href="https://github.com/jonhoo/configs">Jon</a>, <a href="https://github.com/jjgo/dotfiles">Jose</a>.</p><h3 id="可移植性">可移植性</h3><p>配置文件的<strong>一个常见的痛点是它可能并不能在多种设备上生效</strong>。例如，如果你在不同设备上使用的操作系统或者 shell 是不同的，则配置文件是无法生效的。或者，有时你仅希望特定的配置只在某些设备上生效。</p><p>有一些技巧可以轻松达成这些目的。使用 if 语句，则你可以借助它针对不同的设备编写不同的配置。例如，你的 shell 可以这样做：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(uname)</span>&quot;</span> == <span class="string">&quot;Linux&quot;</span> ]]; <span class="keyword">then</span> &#123;do_something&#125;; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用和 shell 相关的配置时先检查当前 shell 类型</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$SHELL</span>&quot;</span> == <span class="string">&quot;zsh&quot;</span> ]]; <span class="keyword">then</span> &#123;do_something&#125;; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你也可以针对特定的设备进行配置</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(hostname)</span>&quot;</span> == <span class="string">&quot;myServer&quot;</span> ]]; <span class="keyword">then</span> &#123;do_something&#125;; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>如果配置文件支持 include 功能，你也可以多加利用。例如：<code>~/.gitconfig</code> 可以这样编写：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[include]</span><br><span class="line">    path = ~/.gitconfig_local</span><br></pre></td></tr></table></figure><p>然后我们可以<strong>在日常使用的设备上创建配置文件</strong> <code>~/.gitconfig_local</code> 来<strong>包含与该设备相关的特定配置</strong>。你甚至应该创建一个单独的代码仓库来管理这些与设备相关的配置。</p><p>如果你希望<strong>在不同的程序之间共享某些配置</strong>，该方法也适用。例如，如果你想要在 <code>bash</code> 和 <code>zsh</code> 中同时启用一些别名，你可以把它们写在 <code>.aliases</code> 里，然后在这两个 shell 里应用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Test if ~/.aliases exists and source it</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.aliases ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> ~/.aliases</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="远端设备">远端设备</h2><p>对于程序员来说，在他们的日常工作中使用远程服务器已经非常普遍了。如果你需要使用远程服务器来部署后端软件或你需要一些计算能力强大的服务器，你就会用到安全 shell（SSH）。和其他工具一样，SSH 也是可以高度定制的，也值得我们花时间学习它。</p><h3 id="连接远端设备">连接远端设备</h3><p>通过如下命令，你可以使用 <code>ssh</code> 连接到其他服务器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh foo@bar.mit.edu</span><br></pre></td></tr></table></figure><p>这里我们尝试</p><ul><li>以用户名 <code>foo</code></li><li>登录服务器 <code>bar.mit.edu</code>。服务器可以通过 URL 指定（例如<code>bar.mit.edu</code>），也可以使用 IP 指定（例如<code>foobar@192.168.1.42</code>）。</li></ul><p>后面我们会介绍如何修改 ssh 配置文件使我们可以用类似 <code>ssh bar</code> 这样的命令来登录服务器。</p><h3 id="执行命令">执行命令</h3><p><code>ssh</code> 的一个经常被忽视的特性是<strong>它可以直接远程执行命令</strong>。</p><p><code>ssh foobar@server ls</code> 可以直接以 foobar 用户的身份执行 <code>ls</code> 命令。</p><p>想要配合管道来使用也可以， <code>ssh foobar@server ls | grep PATTERN</code> 会在本地查询远端 <code>ls</code> 的输出而 <code>ls | ssh foobar@server grep PATTERN</code> 会在远端对本地 <code>ls</code> 输出的结果进行查询。</p><h3 id="SSH-密钥">SSH 密钥</h3><p>基于密钥的验证机制使用了密码学中的<strong>公钥</strong>，我们只需要<strong>向服务器证明客户端持有对应的私钥，而不需要公开其私钥</strong>。这样你就可以<strong>避免每次登录都输入密码</strong>的麻烦了。不过，私钥（通常是 <code>~/.ssh/id_rsa</code> 或者 <code>~/.ssh/id_ed25519</code>），其等效于你的密码，所以一定要好好保存它。</p><h4 id="生成密钥">生成密钥</h4><p>使用 <a href="http://man7.org/linux/man-pages/man1/ssh-keygen.1.html"><code>ssh-keygen</code></a> 命令可以生成一对密钥（公钥和私钥）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure><blockquote><p>命令解释：</p><ul><li><p><code>ssh-keygen</code>：用于生成、管理和转换认证密钥的命令行工具。</p></li><li><p><code>-o</code>：使用 OpenSSH 的新格式输出私钥文件。该格式比旧的 PEM 格式更安全，支持更强的加密。从 OpenSSH 6.5 开始默认开启。</p></li><li><p><code>-a 100</code>：指定 KDF (Key Derivation Function) 的迭代次数。KDF 将密码转换为密钥，通过增加计算复杂度来提高私钥的安全性。<code>-a 100</code> 表示使用 100 次迭代。更多的迭代次数会增加加密强度，但也会使生成密钥的过程变得更慢。</p></li><li><p><code>-t ed25519</code>：指定生成的密钥类型。ed25519 是一种用于数字签名的椭圆曲线算法，相比于 RSA，更安全且密钥长度更短。</p></li><li><p><code>-f ~/.ssh/id_ed25519</code>：指定输出文件的路径和名称。生成的私钥将保存到 <code>~/.ssh/id_ed25519</code>，对应的公钥将保存到 <code>~/.ssh/id_ed25519.pub</code>。</p></li></ul></blockquote><p>你可以为密钥设置密码，防止有人持有你的私钥并使用它访问你的服务器。你可以使用 <a href="https://www.man7.org/linux/man-pages/man1/ssh-agent.1.html"><code>ssh-agent</code></a> 或 <a href="https://linux.die.net/man/1/gpg-agent"><code>gpg-agent</code></a> ，这样就不需要每次都输入该密码了。</p><p>如果你曾经配置过使用 SSH 密钥推送到 GitHub，那么可能你已经完成了<a href="https://help.github.com/articles/connecting-to-github-with-ssh/">这里</a> 介绍的这些步骤，并且已经有了一个可用的密钥对。要检查你是否持有密码并验证它，你可以运行 <code>ssh-keygen -y -f /path/to/key</code>.</p><h4 id="基于密钥的认证机制">基于密钥的认证机制</h4><p>在服务器端，<code>ssh</code> 会查询 <code>.ssh/authorized_keys</code> 来确认哪些用户可以被允许登录。你可以通过下面的命令将一个<strong>公钥</strong>拷贝到这里：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> .ssh/id_ed25519.pub | ssh foobar@remote <span class="string">&#x27;cat &gt;&gt; ~/.ssh/authorized_keys&#x27;</span></span><br></pre></td></tr></table></figure><p>如果支持 <code>ssh-copy-id</code> 的话，可以使用下面这种更简单的解决方案：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote</span><br></pre></td></tr></table></figure><h3 id="通过-SSH-复制文件">通过 SSH 复制文件</h3><p>使用 ssh 复制文件有很多方法：</p><ul><li><code>ssh + tee</code>：最简单的方法是执行 <code>ssh</code> 命令，然后通过这样的方法利用标准输入实现： <code>cat localfile | ssh remote_server tee serverfile</code>。回忆一下，<a href="https://www.man7.org/linux/man-pages/man1/tee.1.html"><code>tee</code></a> 命令会将标准输出写入到一个文件；</li><li><a href="https://www.man7.org/linux/man-pages/man1/scp.1.html"><code>scp</code></a> ：当<strong>需要拷贝大量的文件或目录时</strong>，使用 <code>scp</code> 命令则更加方便，它可以方便地遍历相关路径。语法如下：<code>scp path/to/local_file remote_host:path/to/remote_file</code>；</li><li><a href="https://www.man7.org/linux/man-pages/man1/rsync.1.html"><code>rsync</code></a> 对 <code>scp</code> 进行了改进，它可以<strong>检测本地和远端的文件以防止重复拷贝</strong>。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于 <code>--partial</code> 标记实现<strong>断点续传</strong>。<code>rsync</code> 的语法和<code>scp</code>类似。</li></ul><h3 id="端口转发">端口转发</h3><p>很多情况下我们都会遇到软件需要监听特定设备的端口。如果是在你的本机，可以使用 <code>localhost:PORT</code> 或 <code>127.0.0.1:PORT</code>。但是如果需要监听远程服务器的端口该如何操作呢？这种情况下 <em>远端的端口并不会直接通过网络暴露给你</em>。</p><p>此时就需要进行 <em>端口转发</em>。<strong>端口转发有两种，一种是本地端口转发和远程端口转发</strong>（参见下图，该图片引用自这篇<a href="https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot">StackOverflow 文章</a>）中的图片。</p><p><strong>本地端口转发</strong><img src="https://i.stack.imgur.com/a28N8.png%C2%A0" alt="Local Port Forwarding"></p><p><strong>远程端口转发</strong><img src="https://i.stack.imgur.com/4iK3b.png%C2%A0" alt="Remote Port Forwarding"></p><p>常见的情景是使用 <em>本地端口转发</em>，即<strong>远端设备上的服务监听一个端口，而你希望在本地设备上的一个端口建立连接并转发到远程端口上</strong>。</p><p>例如，我们在远端服务器上运行 Jupyter notebook 并监听 <code>8888</code> 端口。 然后，建立从本地端口 <code>9999</code> 的转发，使用 <code>ssh -L 9999:localhost:8888 foobar@remote_server</code> 。这样只需要访问本地的 <code>localhost:9999</code> 即可。</p><blockquote><p>Tips：</p><p>在使用 ssh 命令时，<code>-N</code> 和 <code>-f</code> 是两个常用的选项，通常用于创建端口转发或隧道，而不执行远程命令。以下是对这两个选项的详细解释：</p><p><code>-N</code> 选项告诉 ssh 只进行端口转发或隧道，而不执行远程命令。这在你只需要创建一个 SSH 隧道或端口转发，而不需要在远程服务器上运行任何命令时非常有用。</p><p><code>-f</code> 选项告诉 ssh 在执行命令之前先进入后台。这在你希望 SSH 会话在后台运行时非常有用，通常与 <code>-N</code> 选项一起使用来创建后台运行的端口转发。</p><p>当这两个选项结合使用时，<strong>SSH 会在后台运行并只进行端口转发或隧道，而不执行任何命令</strong>。</p></blockquote><h3 id="SSH-配置">SSH 配置</h3><p>我们已经介绍了很多参数。为它们创建一个别名是个好想法，我们可以这样做：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> my_server=<span class="string">&quot;ssh -i ~/.id_ed25519 --port 2222 -L 9999:localhost:8888 foobar@remote_server</span></span><br></pre></td></tr></table></figure><p>不过，更好的方法是使用 <code>~/.ssh/config</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host vm</span><br><span class="line">    User foobar</span><br><span class="line">    HostName 172.16.174.141</span><br><span class="line">    Port 2222</span><br><span class="line">    IdentityFile ~/.ssh/id_ed25519</span><br><span class="line">    LocalForward 9999 localhost:8888</span><br><span class="line"></span><br><span class="line"># 在配置文件中也可以使用通配符</span><br><span class="line">Host *.mit.edu</span><br><span class="line">    User foobaz</span><br></pre></td></tr></table></figure><p>这么做的好处是，使用 <code>~/.ssh/config</code> 文件来创建别名，类似 <code>scp</code>、<code>rsync</code>和<code>mosh</code>的这些命令都可以读取这个配置并将设置转换为对应的命令行选项。</p><blockquote><p>注意，<code>~/.ssh/config</code> 文件也可以被当作配置文件，而且一般情况下也是可以被导入其他配置文件的。不过，如果你将其公开到互联网上，那么其他人都将会看到你的服务器地址、用户名、开放端口等等。这些信息可能会帮助到那些企图攻击你系统的黑客，所以请务必三思。</p></blockquote><p>服务器侧的配置通常放在 <code>/etc/ssh/sshd_config</code>。你可以在这里配置免密认证、修改 ssh 端口、开启 X11 转发等等。 你也可以为每个用户单独指定配置。</p><h3 id="杂项">杂项</h3><p>连接远程服务器的一个常见痛点是遇到由关机、休眠或网络环境变化导致的掉线。如果连接的延迟很高也很让人讨厌。<a href="https://mosh.org/">Mosh</a>（即 mobile shell ）对 ssh 进行了改进，它允许<strong>连接漫游、间歇连接及智能本地回显</strong>。</p><p>有时将一个远端文件夹挂载到本地会比较方便， <a href="https://github.com/libfuse/sshfs">sshfs</a> 可以<strong>将远端服务器上的一个文件夹挂载到本地</strong>，然后你就可以<strong>使用本地的编辑器</strong>了。</p><h2 id="Shell-框架">Shell &amp; 框架</h2><p>在 shell 工具和脚本那节课中我们已经介绍了 <code>bash</code> shell，因为它是目前<strong>最通用</strong>的 shell，大多数的系统都将其作为默认 shell。但是，它并不是唯一的选项。</p><p>例如，<code>zsh</code> shell 是 <code>bash</code> 的超集并提供了一些方便的功能：</p><ul><li>智能替换，<code>**</code></li><li>行内替换 / 通配符扩展</li><li>拼写纠错</li><li>更好的 tab 补全和选择</li><li>路径展开 （<code>cd /u/lo/b</code> 会被展开为 <code>/usr/local/bin</code>）</li></ul><p><strong>框架</strong> 也可以改进你的 shell。比较流行的通用框架包括 <a href="https://github.com/sorin-ionescu/prezto">prezto</a> 或 <a href="https://ohmyz.sh/">oh-my-zsh</a>。还有一些更精简的框架，它们往往专注于某一个特定功能，例如 <a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh 语法高亮</a> 或 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh 历史子串查询</a>。 像 <a href="https://fishshell.com/">fish</a> 这样的 shell 包含了很多用户友好的功能，其中一些特性包括：</p><ul><li>向右对齐</li><li>命令语法高亮</li><li>历史子串查询</li><li>基于手册页面的选项补全</li><li>更智能的自动补全</li><li>提示符主题</li></ul><p>需要注意的是，使用这些框架<strong>可能会降低你 shell 的性能</strong>，尤其是如果这些框架的代码没有优化或者代码过多。你随时可以测试其性能或禁用某些不常用的功能来实现速度与功能的平衡。</p><h2 id="终端模拟器">终端模拟器</h2><p>和自定义 shell 一样，花点时间选择适合你的 <strong>终端模拟器</strong> 并进行设置是很有必要的。有许多终端模拟器可供你选择（这里有一些关于它们之间<a href="https://anarc.at/blog/2018-04-12-terminal-emulators-1/">比较</a>的信息）</p><p>你会花上很多时间在使用终端上，因此研究一下终端的设置是很有必要的，你可以从下面这些方面来配置你的终端：</p><ul><li>字体选择</li><li>彩色主题</li><li>快捷键</li><li>标签页/面板支持</li><li>回退配置</li><li>性能（像 <a href="https://github.com/jwilm/alacritty">Alacritty</a> 或者 <a href="https://sw.kovidgoyal.net/kitty/">kitty</a> 这种比较新的终端，它们支持GPU加速）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> The Missing Semester </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Command Line Environment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MIT The Missing Semester] Lec04: Data Wrangling</title>
      <link href="/2025/03/02/MIT-The-Missing-Semester-Lec04-Data-Wrangling/"/>
      <url>/2025/03/02/MIT-The-Missing-Semester-Lec04-Data-Wrangling/</url>
      
        <content type="html"><![CDATA[<h1>Lec04：数据整理</h1><blockquote><p>本节的笔记记录主要以记录用于数据整理的工具为主</p></blockquote><p>本 Lec 的主要内容：</p><ul><li>一系列数据整理工具的使用：<code>grep sed sort uniq paste awk wc bc st R gnuplot xargs ffmpeg less</code></li></ul><h2 id="用-grep-来提取含有某模式的数据">用 grep 来提取含有某模式的数据</h2><ul><li><p><code>ssh myserver journalctl | grep sshd</code></p></li><li><p><code>ssh myserver 'journalctl | grep sshd | grep &quot;Disconnected from&quot;' | less</code></p><blockquote><p><code>less</code> 创建了一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。</p></blockquote></li></ul><h2 id="sed">sed</h2><p><code>sed</code> 是一个基于文本编辑器 <code>ed</code> 构建的 ”流编辑器” 。在 <code>sed</code> 中，你基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容（尽管你也可以选择这样做）。相关的命令行非常多，但是最常用的是 <code>s</code>，即 <em>替换</em> 命令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed &#x27;s/.*Disconnected from //&#x27;</span><br></pre></td></tr></table></figure><p>上面这段命令中，我们使用了一段简单的 <em>正则表达式</em>。正则表达式是一种非常强大的工具，可以让我们基于某种模式来对字符串进行匹配。<code>s</code> 命令的语法如下：<code>s/REGEX/SUBSTITUTION/</code>, 其中 <code>REGEX</code> 部分是我们需要使用的正则表达式，而 <code>SUBSTITUTION</code> 是用于替换匹配结果的文本。</p><blockquote><p>正则表达式语法：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>abc...</code></td><td>字母</td></tr><tr><td><code>123...</code></td><td>数字</td></tr><tr><td><code>\d</code></td><td>任意数字</td></tr><tr><td><code>\D</code></td><td>任意非数字</td></tr><tr><td><code>.</code></td><td>任意符号</td></tr><tr><td><code>\.</code></td><td>句号</td></tr><tr><td><code>[abc]</code></td><td>a、b 或 c</td></tr><tr><td><code>[^abc]</code></td><td>不是 a、b 和 c</td></tr><tr><td><code>[a-z]</code></td><td>a 到 z</td></tr><tr><td><code>[0-9]</code></td><td>0 到 9</td></tr><tr><td><code>\w</code></td><td>任意字母</td></tr><tr><td><code>\W</code></td><td>任意非字母</td></tr><tr><td><code>&#123;m&#125;</code></td><td>重复 m 次</td></tr><tr><td><code>&#123;m,n&#125;</code></td><td>重复 m 到 n 次</td></tr><tr><td><code>*</code></td><td>重复 0 到多次</td></tr><tr><td><code>+</code></td><td>重复 1 到多次</td></tr><tr><td><code>?</code></td><td>可能存在；加在在 <code>*</code> 或 <code>+</code> 后面使其变成非贪婪模式</td></tr><tr><td><code>\s</code></td><td>空格</td></tr><tr><td><code>\S</code></td><td>非空格</td></tr><tr><td><code>^...$</code></td><td>匹配行首和行尾</td></tr><tr><td><code>(...)</code></td><td>捕获组</td></tr><tr><td><code>(a(bc))</code></td><td>嵌套捕获组</td></tr><tr><td><code>(.*)</code></td><td>捕获所有</td></tr><tr><td>`(abc</td><td>def)`</td></tr></tbody></table><p>建议在使用 <code>sed</code> 时都是加上 <code>-E</code> 选项</p><p>注意⚠️：<code>sed</code> 默认不支持将 <code>?</code> 作为非贪婪模式标志，要启用这个用法,使用 <code>perl</code>：<code>perl -pe 's/.*?Disconnected from //'</code></p><p>tips：正则表达式在线调试工具 <a href="https://regex101.com/r/qqbZqh/2">regex debugger</a></p></blockquote><blockquote><p><code>sed</code> 的捕获组：</p><p>被圆括号内的正则表达式匹配到的文本，都会被存入一系列以编号区分的捕获组中。捕获组的内容可以在替换字符串时使用（有些正则表达式的引擎甚至支持替换表达式本身），例如 <code>\1</code>、 <code>\2</code>、<code>\3</code>等等。</p><p>捕获组序号按括号<strong>由左向右被解析的顺序</strong>来标号。</p></blockquote><h2 id="sort">sort</h2><p><code>sort</code> 用于对输入进行排序</p><p><code>sort</code> 默认会对输入流按<strong>字母序</strong>排序</p><p>加上选项 <code>-r</code> 会将排序结果<strong>颠倒</strong></p><p>加上选项 <code>-n</code> 则会按照<strong>数字顺序</strong>排序</p><p><code>sort -nk1,1</code> 会对输入流按照<strong>第一列的数字顺序</strong>排序，<code>sort -nk1,2</code> 会对输入流按照<strong>第一列和第二列的数字顺序</strong>排序，当且仅当第一列数字相同时才比较第二列数字的大小。</p><h2 id="uniq">uniq</h2><p><code>uniq</code> 用于处理有重复数据的输入</p><p><code>uniq -c</code> 会把连续出现的行折叠为一行并使用出现次数作为前缀（第一列）。</p><h2 id="paste（MacOS）">paste（MacOS）</h2><p><code>paste</code> 用于将多行内容合并为一行</p><p><code>paste -sd ',' input.txt</code>：<code>-s</code> 表示合并行，<code>-d</code> 表示选择分隔符，后面接具体的分隔符，输入可以是文件也可以是流</p><h2 id="awk-另外一种编辑器">awk - 另外一种编辑器</h2><p><code>awk</code> 其实是一种编程语言，只不过它碰巧非常善于处理文本。关于 <code>awk</code> 可以介绍的内容太多了，限于篇幅，这里我们仅介绍一些基础知识。</p><p><code>awk</code> 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。</p><p>在代码块中，<code>$0</code> 表示整行的内容，<code>$1</code> 到 <code>$n</code> 为一行中的 n 个区域，区域的分割基于 <code>awk</code> 的域分隔符（默认是空格，可以通过<code>-F</code>来修改）。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br><span class="line"> | sort | uniq -c</span><br><span class="line"> | sort -nk1,1 | tail -n10</span><br><span class="line"> | awk &#x27;&#123;print $2&#125;&#x27; | paste -sd &#x27;,&#x27;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们的代码意思是：对于每一行文本，打印其第二个部分，也就是用户名。</p><p>不过，既然 <code>awk</code> 是一种编程语言，那么则可以这样：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BEGIN &#123; rows = 0 &#125;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 == 1 &amp;&amp; <span class="variable">$2</span> ~ /^c[^ ]*e$/ &#123; rows += <span class="variable">$1</span> &#125;</span></span><br><span class="line">END &#123; print rows &#125;</span><br></pre></td></tr></table></figure><p><code>BEGIN</code> 也是一种模式，它会匹配输入的开头（ <code>END</code> 则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。事实上，我们完全可以抛弃 <code>grep</code> 和 <code>sed</code> ，因为 <code>awk</code> 就可以<a href="https://backreference.org/2010/02/10/idiomatic-awk">解决所有问题</a>。至于怎么做，就留给读者们做课后练习吧。</p><h2 id="wc">wc</h2><p><code>wc</code> 用于对输入进行数量统计</p><p><code>wc -l</code> 统计输入行数</p><h2 id="bc">bc</h2><p><code>bc</code> 主要用于对输入数据作数学运算</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">| paste -sd &#x27;+&#x27; | bc -l</span><br></pre></td></tr></table></figure><p>这段代码将每行的数字加起来</p><p>下面这种更加复杂的表达式也可以：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;2*($(data | paste -sd &#x27;+&#x27;))&quot; | bc -l</span><br></pre></td></tr></table></figure><h2 id="st">st</h2><p>你可以通过多种方式获取统计数据。如果已经安装了R语言，<a href="https://github.com/nferraz/st"><code>st</code></a> 是个不错的选择</p><h2 id="R">R</h2><p>R 也是一种编程语言，它非常适合被用来进行数据分析和<a href="https://ggplot2.tidyverse.org/">绘制图表</a>。这里我们不会讲的特别详细， 你只需要知道<code>summary</code> 可以打印某个向量的统计结果。我们将输入的一系列数据存放在一个向量后，利用 R 语言就可以得到我们想要的统计数据。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br><span class="line"> | sort | uniq -c</span><br><span class="line"> | awk &#x27;&#123;print $1&#125;&#x27; | R --slave -e &#x27;x &lt;- scan(file=&quot;stdin&quot;, quiet=TRUE); summary(x)&#x27;</span><br></pre></td></tr></table></figure><h2 id="gnuplot">gnuplot</h2><p>如果你希望绘制一些简单的图表， <code>gnuplot</code> 可以帮助到你：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br><span class="line"> | sort | uniq -c</span><br><span class="line"> | sort -nk1,1 | tail -n10</span><br><span class="line"> | gnuplot -p -e &#x27;set boxwidth 0.5; plot &quot;-&quot; using 1:xtic(2) with boxes&#x27;</span><br></pre></td></tr></table></figure><h2 id="xargs">xargs</h2><p><code>xargs</code> 用于将其<strong>输入</strong>转化为某个程序的若干个<strong>参数</strong></p><p>例子：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rustup toolchain list | grep nightly | grep -vE &quot;nightly-x86&quot; | sed &#x27;s/-x86.*//&#x27; | xargs rustup toolchain uninstall</span><br></pre></td></tr></table></figure><h2 id="不只是文本数据">不只是文本数据</h2><p>虽然到目前为止我们的讨论都是基于文本数据，但对于二进制文件其实同样有用。例如我们可以用 <code>ffmpeg</code> 从相机中捕获一张图片，将其转换成灰度图后通过 SSH 将压缩后的文件发送到远端服务器，并在那里解压、存档并显示。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 -</span><br><span class="line"> | convert - -colorspace gray -</span><br><span class="line"> | gzip</span><br><span class="line"> | ssh mymachine &#x27;gzip -d | tee copy.jpg | env DISPLAY=:0 feh -&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> The Missing Semester </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Wrangling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MIT The Missing Semester] Lec03: Vim</title>
      <link href="/2025/03/02/MIT-The-Missing-Semester-Lec03-Vim/"/>
      <url>/2025/03/02/MIT-The-Missing-Semester-Lec03-Vim/</url>
      
        <content type="html"><![CDATA[<h1>Lec03：编辑器（Vim）</h1><p>本 Lec 的主要内容：</p><ul><li>Vim 的设计哲学</li><li>Vim 接口其实是一种编程语言</li><li>Vim 中各种命令的使用</li><li>Vim 的自定义和插件扩展</li><li>一些 Vim 的进阶功能</li></ul><h2 id="如何学习使用一个编辑器">如何学习使用一个编辑器</h2><p>作为程序员，我们大部分时间都花在代码编辑上，所以花点时间掌握某个适合自己的编辑器是非常值得的。通常学习使用一个新的编辑器包含以下步骤：</p><ul><li>阅读教程（比如这节课以及我们为你提供的资源）</li><li>坚持使用它来完成你所有的编辑工作（即使一开始这会让你的工作效率降低）</li><li>随时查阅：如果某个操作看起来像是有更方便的实现方法，一般情况下真的会有</li></ul><p>如果能够遵循上述步骤，并且坚持使用新的编辑器完成所有的文本编辑任务，那么学习一个复杂的代码编辑器的过程一般是这样的：</p><ol><li>头两个小时，你会学习到编辑器的基本操作，例如打开和编辑文件、保存与退出、浏览缓冲区。</li><li>当学习时间累计达到20个小时之后，你使用新编辑器的效率应该已经和使用老编辑器一样快。</li><li>在此之后，其益处开始显现：有了足够的知识和肌肉记忆后，使用新编辑器将大大节省你的时间。而现代文本编辑器都是些复杂且强大的工具，永远有新东西可学：学的越多，效率越高。</li></ol><h2 id="该学哪个编辑器？">该学哪个编辑器？</h2><p>程序员们对自己正在使用的文本编辑器通常有着 <a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E6%88%98">非常强的执念</a>。</p><p>现在最流行的编辑器是什么？<a href="https://insights.stackoverflow.com/survey/2019/#development-environments-and-tools">Stack Overflow 的调查</a>（这个调查可能并不如我们想象的那样客观，因为 Stack Overflow 的用户并不能代表所有程序员）显示，<a href="https://code.visualstudio.com/">Visual Studio Code</a> 是目前最流行的代码编辑器。而 <a href="https://www.vim.org/">Vim</a> 则是最流行的基于命令行的编辑器。</p><h2 id="Vim">Vim</h2><p>Vim 有着悠久历史；它始于 1976 年的 Vi 编辑器，到现在还在 不断开发中。Vim 有很多聪明的设计思想，所以很多其他工具也支持 Vim 模式（比如，140 万人安装了 <a href="https://github.com/VSCodeVim/Vim">Vim emulation for VS code</a>）。即使你最后使用 其他编辑器，Vim 也值得学习。</p><p>由于不可能在 50 分钟内教授 Vim 的所有功能，我们会专注于解释 Vim 的==设计哲学==，教你基础知识， 并展示一部分高级功能，然后给你掌握这个工具所需要的资源。</p><h3 id="Vim-的哲学">Vim 的哲学</h3><p>在编程的时候，你会把大量时间花在==阅读/编辑==而不是在写代码上。所以，Vim 是一个<em>多模态</em> 编辑器：==它对于插入文字和操纵文字有不同的模式==。</p><p>Vim 是==可编程==的（可以使用 Vimscript 或者像 Python 一样的其他程序语言），==Vim 的接口本身也是一个程序语言==：键入操作（以及其助记名） 是命令，这些命令也是==可组合==的。</p><p>Vim 避免了使用鼠标，因为那样太慢了；Vim 甚至避免用 上下左右键 因为那样需要太多的手指移动。</p><p>这样的设计哲学使得 Vim 成为了一个==能跟上你思维速度的编辑器==。</p><h3 id="Vim-的五大编辑模式">Vim 的五大编辑模式</h3><p>Vim 的设计以大多数时间都花在阅读、浏览和进行少量编辑改动为基础，因此它具有多种操作模式：</p><ul><li><strong>普通模式（Normal）</strong>：在文件中四处移动光标进行修改</li><li><strong>插入模式（Insert）</strong>：插入文本</li><li><strong>替换模式（Replace）</strong>：替换文本</li><li><strong>可视化模式（Visual）</strong>（一般，行「line」，块「block」）：选中文本块</li><li><strong>命令模式（Command）</strong>：用于执行命令</li></ul><p>==在不同的操作模式下，键盘敲击的含义也不同==。比如，<code>x</code> 在插入模式会插入字母 <code>x</code>，但是在正常模式 会删除当前光标所在的字母，在可视模式下则会删除选中文块。</p><p>在默认设置下，Vim 会在==左下角显示当前的模式==。Vim 启动时的默认模式是普通模式。通常你会把<strong>大部分</strong>时间花在<em>普通模式和插入模式</em>。</p><p>切换方式：</p><ul><li>非普通模式 + <code>&lt;ESC&gt;</code> ==&gt; 普通模式</li><li>普通模式 + <code>i</code> ==&gt; 插入模式</li><li>普通模式 + <code>R</code> ==&gt; 替换模式</li><li>普通模式 + <code>v</code> ==&gt; 一般可视化模式</li><li>普通模式 + <code>V</code> ==&gt; 行可视化模式</li><li>普通模式 + <code>^v</code> ==&gt; 块可视化模式</li><li>普通模式 + <code>:</code> ==&gt; 命令模式</li></ul><h3 id="Vim-的基本操作">Vim 的基本操作</h3><h4 id="插入文本">插入文本</h4><p>在普通模式，键入 <code>i</code> 进入插入模式。现在 Vim 跟很多其他的编辑器一样，直到你键入 <code>&lt;ESC&gt;</code> 返回普通模式。你只需要掌握这一点和上面介绍的所有基础知识就可以使用 Vim 来编辑文件了 （虽然如果你一直停留在插入模式内不一定高效）。</p><h4 id="缓存，标签页，窗口">缓存，标签页，窗口</h4><ul><li><p>==Vim 会维护一系列打开的文件，称为 “缓存”==</p></li><li><p>==一个 Vim 会话包含一系列标签页，每个标签页包含 一系列窗口（分隔面板）==</p></li><li><p>==每个窗口显示一个缓存==</p></li></ul><p>跟网页浏览器等其他你熟悉的程序不一样的是， <strong>缓存和窗口不是一一对应的关系</strong>；窗口只是查看缓存的视角，这也就是说，<strong>一个缓存可以对应多个窗口，但一个窗口只能对应一个缓存</strong>。一个缓存可以在 <em>多个</em> 窗口打开，甚至在同一 个标签页内的多个窗口打开。这个功能其实很好用，比如在 <strong>查看同一个文件的不同部分的时候。</strong></p><p>Vim 默认打开一个标签页，这个标签也包含一个窗口。</p><h4 id="命令行">命令行</h4><p>在普通模式下键入 <code>:</code> 进入命令行模式。 在键入 <code>:</code> 后，你的光标会立即跳到屏幕下方的命令行。 这个模式有很多功能，包括打开，保存，关闭文件，以及 <a href="https://twitter.com/iamdevloper/status/435555976687923200">退出 Vim</a>。</p><table><thead><tr><th>指令</th><th>含义</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td><code>:q</code></td><td>退出（关闭当前窗口）</td><td style="text-align:center">-</td></tr><tr><td><code>:w</code></td><td>保存（write）</td><td style="text-align:center">-</td></tr><tr><td><code>:wq</code></td><td>保存然后退出</td><td style="text-align:center">-</td></tr><tr><td><code>:e &#123;文件名&#125;</code></td><td>打开要编辑的文件</td><td style="text-align:center">-</td></tr><tr><td><code>:ls</code></td><td>显示打开的缓存（文件）</td><td style="text-align:center">-</td></tr><tr><td><code>:help &#123;命令&#125;</code></td><td>打开帮助文档</td><td style="text-align:center"><code>:help :w</code>：打开 <code>:w</code> 命令的帮助文档<br /><code>:help w</code>：打开 <code>w</code> 移动的帮助文档</td></tr></tbody></table><h3 id="Vim-的接口其实是一种编程语言">Vim 的接口其实是一种编程语言</h3><p>Vim <strong>最重要的设计思想</strong>是 ==Vim 的界面本身是一个程序语言==。键入操作（以及他们的助记名）<strong>本身是命令</strong>，这些命令可以<strong>组合使用</strong>。这使得移动和编辑更加高效，特别是一旦形成肌肉记忆。</p><h4 id="移动">移动</h4><p>多数时候你会在正常模式下，使用移动命令在缓存中导航。==在 Vim 里面移动也被称为 “名词”， 因为它们指向文字块==。</p><p>下面是常用的移动命令</p><p><strong>基本移动</strong></p><ul><li><code>hjkl</code>（左，下，上，右）</li></ul><p><strong>词移动</strong></p><ul><li><code>w</code>：下一个词首</li><li><code>b</code>：上一个词首</li><li><code>e</code>：下一个词尾</li></ul><p><strong>行移动</strong></p><ul><li><code>0</code>：行首</li><li><code>^</code>：第一个非空格字符</li><li><code>$</code>：行尾</li></ul><p><strong>屏幕移动</strong></p><ul><li><code>H</code>：屏幕中首行</li><li><code>M</code>：屏幕居中行</li><li><code>L</code>：屏幕中尾行</li></ul><p><strong>翻页移动</strong></p><ul><li><code>^u</code>：上翻</li><li><code>^d</code>：下翻</li></ul><p><strong>文件移动</strong></p><ul><li><code>gg</code>：文件头</li><li><code>G</code>：文件尾</li></ul><p><strong>行数移动</strong></p><ul><li><code>:&#123;行数&#125;&lt;CR&gt;</code> 或者 <code>&#123;行数&#125;G</code> ({行数}为行数)</li></ul><p><strong>杂项</strong></p><ul><li><code>%</code> （找到配对，比如括号或者 /* */ 之类的注释对）</li></ul><p><strong>查找</strong></p><ul><li><code>f&#123;字符&#125;</code>、<code>t&#123;字符&#125;</code>、<code>F&#123;字符&#125;</code>、<code>T&#123;字符&#125;</code>：查找 下一个 / 上一个 / 这一行的第一个 / 这一行的最后一个字符</li><li><code>,</code> / <code>;</code> 用于导航匹配</li></ul><p><strong>搜索</strong></p><ul><li><code>/&#123;正则表达式&#125;</code>， <code>n</code> / <code>N</code> 用于导航匹配</li></ul><h4 id="选择">选择</h4><p>进入可视化模式:</p><ul><li>可视化：<code>v</code></li><li>可视化行： <code>V</code></li><li>可视化块：<code>Ctrl+v</code></li></ul><p>用移动命令来选中特定部分。</p><h4 id="编辑">编辑</h4><p>所有你需要用鼠标做的事， 你现在都可以用键盘：采用编辑命令和移动命令的组合来完成。 这就是 Vim 的界面开始看起来像一个程序语言的时候。==Vim 的编辑命令也被称为 “动词”， 因为动词可以施动于名词==。</p><ul><li><code>i</code>：进入插入模式</li><li><code>O</code> / <code>o</code>：在 上 / 下 插入空行并进入插入模式</li><li><code>d&#123;移动命令&#125;</code> ： 删除 {移动命令}<ul><li>例如，<code>dw</code> 删除词，<code>d$</code> 删除到行尾，<code>d0</code> 删除到行首</li></ul></li><li><code>c&#123;移动命令&#125;</code>：改变 {移动命令}，即先删除然后进入插入模式<ul><li>例如，<code>cw</code> 改变词</li><li>等同于 <code>d&#123;移动命令&#125;</code> + <code>i</code></li></ul></li><li><code>x</code>：删除字符（等同于 <code>dl</code>）</li><li><code>s</code>：替换字符（等同于 <code>xi</code>）</li><li>可视化模式 + 操作<ul><li>选中文字后，<code>d</code> 删除 或者 <code>c</code> 改变</li></ul></li><li><code>u</code> 撤销，<code>^r</code> 重做</li><li><code>y</code> 复制（yank），其他一些命令比如 <code>d</code> 也会复制</li><li><code>p</code> 粘贴</li><li><code>~</code> 字符大小写翻转</li></ul><blockquote><p>注意⚠️：以上所有操作都是相对于光标位置的</p></blockquote><h4 id="计数">计数</h4><p>你可以用一个数字来结合“名词”和“动词”，这会==执行指定操作若干次==。</p><p>比如：</p><ul><li><code>3w</code> 向后移动三个词</li><li><code>5j</code> 向下移动五行</li><li><code>7dw</code> 删除七个词</li></ul><h4 id="修饰语">修饰语</h4><p>你可以用修饰语改变 “名词” 的意义。修饰语有：</p><ul><li><p><code>i</code>，表示 “内部” 或者 “在内”</p></li><li><p><code>a</code>， 表示 “周围”。</p></li></ul><p>比如：</p><ul><li><code>ci(</code> 改变当前括号内的内容</li><li><code>ci[</code> 改变当前方括号内的内容</li><li><code>da'</code> 删除一个单引号字符串，包括单引号</li></ul><h3 id="自定义-Vim">自定义 Vim</h3><p>Vim 由一个位于 <code>~/.vimrc</code> 的文本配置文件（包含 Vim 脚本命令）。你可能会启用很多基本 设置。</p><p>我们提供一个文档详细的基本设置，你可以用它当作你的初始设置。我们推荐使用这个设置因为 它修复了一些 Vim 默认设置奇怪行为。 <strong>在 <a href="https://missing-semester-cn.github.io/2020/files/vimrc">这儿</a> 下载我们的设置，然后将它保存成 <code>~/.vimrc</code>.</strong></p><p>==Vim 能够被重度自定义，花时间探索自定义选项是值得的==。你可以参考其他人的在 GitHub 上共享的设置文件，比如，你的授课人的 Vim 设置 (<a href="https://github.com/anishathalye/dotfiles/blob/master/vimrc">Anish</a>, <a href="https://github.com/jonhoo/configs/blob/master/editor/.config/nvim/init.vim">Jon</a> (uses <a href="https://neovim.io/">neovim</a>), <a href="https://github.com/JJGO/dotfiles/blob/master/vim/.vimrc">Jose</a>)。 有很多好的博客文章也聊到了这个话题。==尽量不要复制粘贴别人的整个设置文件， 而是阅读和理解它，然后采用对你有用的部分==。</p><h3 id="扩展-Vim">扩展 Vim</h3><p>Vim 有很多扩展插件。跟很多互联网上已经过时的建议相反，你<em>不</em> 需要在 Vim 使用一个插件 管理器（从 Vim 8.0 开始）。你可以使用内置的插件管理系统。只需要创建一个 <code>~/.vim/pack/vendor/start/</code> 的文件夹，然后把插件放到这里（比如通过 <code>git clone</code>）。</p><p>以下是一些我们最爱的插件：</p><ul><li><a href="https://github.com/ctrlpvim/ctrlp.vim">ctrlp.vim</a>: 模糊文件查找</li><li><a href="https://github.com/mileszs/ack.vim">ack.vim</a>: 代码搜索</li><li><a href="https://github.com/scrooloose/nerdtree">nerdtree</a>: 文件浏览器</li><li><a href="https://github.com/easymotion/vim-easymotion">vim-easymotion</a>: 魔术操作</li></ul><p>我们尽量避免在这里提供一份冗长的插件列表。你可以查看讲师们的开源的配置文件 (<a href="https://github.com/anishathalye/dotfiles">Anish</a>, <a href="https://github.com/jonhoo/configs">Jon</a>, <a href="https://github.com/JJGO/dotfiles">Jose</a>) 来看看我们使用的其他插件。 浏览 <a href="https://vimawesome.com/">Vim Awesome</a> 来了解一些很棒的插件。 这个话题也有很多博客文章：搜索 “best Vim plugins”。</p><h3 id="其他程序的-Vim-模式">其他程序的 Vim 模式</h3><p>很多工具提供了 Vim 模式。这些 Vim 模式的质量参差不齐；取决于具体工具，有的提供了 很多酷炫的 Vim 功能，但是大多数对基本功能支持的很好。</p><h4 id="Shell">Shell</h4><p>如果你是一个 Bash 用户，用 <code>set -o vi</code>。如果你用 Zsh：<code>bindkey -v</code>。Fish 用 <code>fish_vi_key_bindings</code>。另外，不管利用什么 shell，你可以 <code>export EDITOR=vim</code>。 这是一个用来决定当一个程序需要启动编辑时启动哪个的环境变量。 例如，<code>git</code> 会使用这个编辑器来编辑 commit 信息。</p><h4 id="其他">其他</h4><p>甚至有 Vim 的网页浏览快捷键 <a href="http://vim.wikia.com/wiki/Vim_key_bindings_for_web_browsers">browsers</a>, 受欢迎的有 用于 Google Chrome 的 <a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?hl=en">Vimium</a> 和用于 Firefox 的 <a href="https://github.com/tridactyl/tridactyl">Tridactyl</a>。 你甚至可以在 <a href="https://github.com/lambdalisue/jupyter-vim-binding">Jupyter notebooks</a> 中用 Vim 快捷键。 <a href="https://reversed.top/2016-08-13/big-list-of-vim-like-software">这个列表</a> 中列举了支持类 vim 键位绑定的软件。</p><h2 id="Vim-进阶">Vim 进阶</h2><p>这里我们提供了一些展示这个编辑器能力的例子。我们无法把所有的这样的事情都教给你，但是你 可以在使用中学习。一个好的对策是：当你在使用你的编辑器的时候感觉 “一定有更好的方法来做这个”， 那么很可能真的有：上网搜寻一下。</p><h3 id="搜索和替换">搜索和替换</h3><p><code>:s</code> （替换）命令（<a href="http://vim.wikia.com/wiki/Search_and_replace">文档</a>）。</p><ul><li><p><code>%s/foo/bar/g</code></p><ul><li>在整个文件中将 foo 全局替换成 bar</li></ul></li><li><p><code>%s/\[.*\](\(.*\))/\1/g</code></p><ul><li>将有命名的 Markdown 链接替换成简单 URLs</li></ul></li></ul><h4 id="多窗口">多窗口</h4><ul><li>用 <code>:sp</code> / <code>:vsp</code> 来分割窗口</li><li>同一个缓存可以在多个窗口中显示。</li></ul><h4 id="宏">宏</h4><ul><li><p><code>q&#123;字符&#125;</code> 来开始在寄存器<code>&#123;字符&#125;</code>中录制宏</p></li><li><p><code>q</code> 停止录制</p></li><li><p><code>@&#123;字符&#125;</code> 重放宏</p></li><li><p>宏的执行遇错误会停止</p></li><li><p><code>&#123;计数&#125;@&#123;字符&#125;</code> 执行一个宏{计数}次</p></li><li><p>宏可以递归</p><ul><li>首先用 <code>q&#123;字符&#125;q</code> 清除宏</li><li>录制该宏，用 <code>@&#123;字符&#125;</code> 来递归调用该宏 （在录制完成之前不会有任何操作）</li></ul></li><li><p>例子：将 xml 转成 json <a href="https://missing-semester-cn.github.io/2020/files/example-data.xml">file</a></p><ul><li><p>一个有 “name” / “email” 键对象的数组</p></li><li><p>用一个 Python 程序？</p></li><li><p>用 sed / 正则表达式</p><ul><li><code>g/people/d</code></li><li><code>%s/&lt;person&gt;/&#123;/g</code></li><li><code>%s/&lt;name&gt;\(.*\)&lt;\/name&gt;/&quot;name&quot;: &quot;\1&quot;,/g</code></li><li>…</li></ul></li><li><p>Vim 命令 / 宏</p><ul><li><p><code>ggdd</code>, <code>Gdd</code> 删除第一行和最后一行</p></li><li><p>格式化最后一个元素的宏 （寄存器 <code>e</code>）</p><ul><li>跳转到有 <code>&lt;name&gt;</code> 的行</li><li><code>qe^r&quot;f&gt;s&quot;: &quot;&lt;ESC&gt;f&lt;C&quot;&lt;ESC&gt;q</code></li></ul></li><li><p>格式化一个的宏</p><ul><li>跳转到有 <code>&lt;person&gt;</code> 的行</li><li><code>qpS&#123;&lt;ESC&gt;j@eA,&lt;ESC&gt;j@ejS&#125;,&lt;ESC&gt;q</code></li></ul></li><li><p>格式化一个标签然后转到另外一个的宏</p><ul><li>跳转到有 <code>&lt;person&gt;</code> 的行</li><li><code>qq@pjq</code></li></ul></li><li><p>执行宏到文件尾</p><ul><li><code>999@q</code></li></ul></li><li><p>手动移除最后的 <code>,</code> 然后加上 <code>[</code> 和 <code>]</code> 分隔符</p></li></ul></li></ul></li></ul><h2 id="扩展资料">扩展资料</h2><ul><li><code>vimtutor</code> 是一个 Vim 安装时自带的教程</li><li><a href="https://vim-adventures.com/">Vim Adventures</a> 是一个学习使用 Vim 的游戏</li><li><a href="http://vim.wikia.com/wiki/Vim_Tips_Wiki">Vim Tips Wiki</a></li><li><a href="https://vimways.org/2019/">Vim Advent Calendar</a> 有很多 Vim 小技巧</li><li><a href="http://www.vimgolf.com/">Vim Golf</a> 是用 Vim 的用户界面作为程序语言的 <a href="https://en.wikipedia.org/wiki/Code_golf">code golf</a></li><li><a href="https://vi.stackexchange.com/">Vi/Vim Stack Exchange</a></li><li><a href="http://vimcasts.org/">Vim Screencasts</a></li><li><a href="https://pragprog.com/titles/dnvim2/">Practical Vim</a>（书籍）</li></ul>]]></content>
      
      
      <categories>
          
          <category> The Missing Semester </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MIT The Missing Semester] Lec02: Shell 工具和脚本</title>
      <link href="/2025/03/02/MIT-The-Missing-Semester-Lec02-Shell-%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC/"/>
      <url>/2025/03/02/MIT-The-Missing-Semester-Lec02-Shell-%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1>Lec02：Shell 工具和脚本</h1><p>本 Lec 的主要内容：</p><ul><li>了解如何编写 shell 脚本</li><li>shell 的变量、字符串、函数、运算符、流程控制语句、通配符</li><li>两个特性：命令替换和进程替换</li><li>如何在 shell 中调用其他语言编写的脚本</li><li>一系列常用的 shell 工具（命令）</li></ul><h2 id="Shell-脚本">Shell 脚本</h2><p>大多数 shell 都有自己的一套脚本语言，包括变量、控制流和自己的语法。</p><p>shell脚本与其他脚本语言不同之处在于，shell 脚本针对 shell 所从事的相关工作进行了优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是 shell 脚本中的原生操作，这让它比通用的脚本语言更易用。本节中，我们会专注于 bash 脚本，因为它最流行，应用更为广泛。</p><h3 id="变量赋值">变量赋值</h3><p>在bash中为变量赋值的语法是 <code>foo=bar</code>，访问变量中存储的数值，其语法为 <code>$foo</code>。</p><blockquote><p>注意⚠️：<code>foo = bar</code> （使用空格隔开）是不能正确工作的，因为解释器会调用程序<code>foo</code> 并将 <code>=</code> 和 <code>bar</code>作为参数。 总的来说，==在shell脚本中使用空格会起到分割参数的作用==，有时候可能会造成混淆，请务必多加检查。</p></blockquote><h3 id="字符串">字符串</h3><p>Bash中的字符串通过 <code>'</code> 和 <code>&quot;</code> 分隔符来定义，但是它们的含义并不相同。</p><p>以 <code>'</code> 定义的字符串为==原义字符串，其中的变量不会被转义==，而 <code>&quot;</code> 定义的字符串==会将变量值进行替换==。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">foo=bar</span><br><span class="line">echo &quot;$foo&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印 bar</span></span><br><span class="line">echo &#x27;$foo&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印 <span class="variable">$foo</span></span></span><br></pre></td></tr></table></figure><h3 id="函数">函数</h3><p>和其他大多数的编程语言一样，<code>bash</code> 也支持 <code>if</code>, <code>case</code>, <code>while</code> 和 <code>for</code> 这些控制流关键字。同样地， <code>bash</code> 也支持函数，它可以接受参数并基于参数进行操作。</p><p>下面这个函数是一个例子，它会创建一个文件夹并使用 <code>cd</code> 进入该文件夹。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mcd () &#123;</span><br><span class="line">    mkdir -p &quot;$1&quot;</span><br><span class="line">    cd &quot;$1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里 <code>$1</code> 是脚本的第一个参数。与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。</p><p>下面列举了其中一些变量，更完整的列表可以参考 <a href="https://www.tldp.org/LDP/abs/html/special-chars.html">这里</a>。</p><table><thead><tr><th>参数名</th><th>含义</th></tr></thead><tbody><tr><td><code>$0</code></td><td>脚本的名称</td></tr><tr><td><code>$1</code> ~ <code>$9</code></td><td>脚本的第 1 到第 9 个参数</td></tr><tr><td><code>$@</code></td><td>脚本的所有参数</td></tr><tr><td><code>$#</code></td><td>脚本参数的个数</td></tr><tr><td><code>$?</code></td><td>前一个命令的返回值</td></tr><tr><td><code>$$</code></td><td>当前脚本的进程识别码</td></tr><tr><td><code>!!</code></td><td>完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</td></tr><tr><td><code>$_</code></td><td>上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</td></tr></tbody></table><p>命令通常使用 <code>STDOUT</code> 来返回输出值，使用 <code>STDERR</code> 来返回错误及错误码，便于脚本以更加友好的方式报告错误。</p><p>==返回码或退出状态是脚本/命令之间交流执行状态的方式==。返回值 0 表示正常执行，其他所有非 0 的返回值都表示有错误发生。</p></blockquote><h3 id="逻辑运算符">逻辑运算符</h3><p>退出码可以搭配 <code>&amp;&amp;</code>（与操作符）和 <code>||</code>（或操作符）使用，用来进行条件判断，决定是否执行其他程序。它们都属于短路<a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">运算符</a>（short-circuiting）。同一行的多个命令可以用 <code>;</code> 分隔。程序 <code>true</code> 的返回码永远是<code>0</code>，<code>false</code> 的返回码永远是 <code>1</code>。让我们看几个例子</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">false || echo &quot;Oops, fail&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Oops, fail</span></span><br><span class="line"></span><br><span class="line">true || echo &quot;Will not be printed&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">true &amp;&amp; echo &quot;Things went well&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Things went well</span></span><br><span class="line"></span><br><span class="line">false &amp;&amp; echo &quot;Will not be printed&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">false ; echo &quot;This will always run&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This will always run</span></span><br></pre></td></tr></table></figure><blockquote><p>小技巧：<code>||</code> 运算符常用于设置第一个程序非正常执行时要执行的操作；<code>&amp;&amp;</code> 运算符常用于设置第一个程序正常执行时要执行的操作。</p></blockquote><h3 id="命令替换">命令替换</h3><p>当通过 <code>$( CMD )</code> 这样的方式来执行 <code>CMD</code> 这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行 <code>for file in $(ls)</code> ，shell 首先将调用 <code>ls</code> ，然后遍历得到的这些返回值。</p><p>这个操作常用于需要使用某个命令的输出来做一些操作的情况。</p><h3 id="进程替换">进程替换</h3><p><code>&lt;( CMD )</code> 会执行 <code>CMD</code> 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。这在我们希望输出值通过文件而不是 <code>STDIN</code> 传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别。</p><h3 id="一个综合前面知识的例子">一个综合前面知识的例子</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh <span class="comment"># 告诉shell这段代码要用系统位于/bin/sh的程序来执行</span></span></span><br><span class="line"></span><br><span class="line">echo &quot;Starting program at $(date)&quot; # 命令替换，date会被替换成日期和时间</span><br><span class="line"></span><br><span class="line">echo &quot;Running program $0 with $# arguments with pid $$&quot;</span><br><span class="line"></span><br><span class="line">for file in &quot;$@&quot;; do</span><br><span class="line">    grep foobar &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">    # 如果模式没有找到，则grep退出状态为 1</span><br><span class="line">    # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息</span><br><span class="line">    # 解释：</span><br><span class="line">    # grep foobar &quot;$file&quot;：这部分命令在变量 $file 指定的文件中搜索字符串 foobar。</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&gt; /dev/null：将标准输出（stdout）重定向到 /dev/null，即丢弃输出内容。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2&gt; /dev/null：将标准错误（stderr）重定向到 /dev/null，即丢弃错误信息。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目的：</span></span><br><span class="line">    # 这条命令的目的是执行 grep 搜索而不在终端显示任何输出或错误信息。</span><br><span class="line">    if [[ $? -ne 0 ]]; then</span><br><span class="line">        echo &quot;File $file does not have any foobar, adding one&quot;</span><br><span class="line">        echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">遍历我们提供的参数，使用grep 搜索字符串 foobar，如果没有找到，则将其作为注释追加到文件中。</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p><code>[]</code> 是 <code>test</code> 命令的简写形式，用于条件测试，是 <code>if</code> 和 <code>while</code> 语句中最常见的用法。</p></li><li><p>你可以直接使用 <code>test</code> 命令来代替 <code>[]</code>。</p></li><li><p>在 <code>Bash</code> 和 <code>Zsh</code> 中，<code>[[ ]]</code> 提供了更强大的条件测试功能，处理字符串更加安全，并且支持更多的操作符。</p></li><li><p>在脚本中，使用 <code>[]</code>、<code>test</code> 或 <code>[[ ]]</code> 取决于你的具体需求和 <code>Shell</code> 环境。对于简单的条件测试，<code>[]</code> 足够；对于更复杂的条件测试，特别是在 <code>Bash</code> 和 <code>Zsh</code> 中，建议使用 <code>[[ ]]</code>。</p></li><li><p>在 <code>Shell</code> 脚本中，使用 <code>[]</code> 时，==前后的空格是必须的==，因为它们是 <code>test</code> 命令的简写形式，参数需要用空格分隔。同样，在使用 <code>[[ ]]</code> 进行条件测试时，==空格也是必须的==。这是确保条件表达式被正确解析和执行的必要语法要求。</p></li><li><p>在条件语句中，我们比较 <code>$?</code> 是否等于0。具体的比较操作，可以查看 <code>test</code> 命令的手册。</p></li></ul></blockquote><h3 id="通配">通配</h3><p>当执行脚本时，我们经常需要提供形式类似的参数。bash 使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为 shell 的 <em>通配</em>（<em>globbing</em>）。</p><table><thead><tr><th>通配符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>?</code></td><td>匹配一个字符</td><td><code>foo?</code><br />匹配 <code>foo1</code>, <code>foox</code>, <code>foo(</code>…</td></tr><tr><td><code>*</code></td><td>匹配任意个字符</td><td><code>foo*</code><br />匹配 <code>foo123</code>, <code>foo28y</code>…</td></tr><tr><td><code>&#123;&#125;</code></td><td>生成字符串</td><td>见下面灰色字体</td></tr><tr><td><code>**</code></td><td>匹配目录和子目录中的文件</td><td><code>ls **</code><br />这将列出当前目录及其所有子目录中的所有文件</td></tr></tbody></table><blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">convert image.&#123;png,jpg&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会展开为</span></span><br><span class="line">convert image.png image.jpg</span><br><span class="line"></span><br><span class="line">cp /path/to/project/&#123;foo,bar,baz&#125;.sh /newpath</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会展开为</span></span><br><span class="line">cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以结合通配使用</span></span><br><span class="line">mv *&#123;.py,.sh&#125; folder</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会移动所有 *.py 和 *.sh 文件</span></span><br><span class="line"></span><br><span class="line">mkdir foo bar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件</span></span><br><span class="line">touch &#123;foo,bar&#125;/&#123;a..h&#125;</span><br><span class="line">touch foo/x bar/y</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比较文件夹 foo 和 bar 中包含文件的不同</span></span><br><span class="line">diff &lt;(ls foo) &lt;(ls bar)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt; x</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">---</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&gt; y</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="在-shell-中调用其他语言编写的脚本">在 shell 中调用其他语言编写的脚本</h3><p>脚本并不一定只有用 bash 写才能在终端里调用。比如说，这是一段 Python 脚本，作用是将输入的参数倒序输出：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="built_in">reversed</span>(sys.argv[<span class="number">1</span>:]):</span><br><span class="line">    <span class="built_in">print</span>(arg)</span><br></pre></td></tr></table></figure><p>内核知道去用 <code>python</code> 解释器而不是 <code>shell</code> 命令来运行这段脚本，是因为脚本的开头第一行的 <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)"><code>shebang</code></a>。</p><p>在 <code>shebang</code> 行中使用 <a href="https://man7.org/linux/man-pages/man1/env.1.html"><code>env</code></a> 命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高了你的脚本的可移植性。<code>env</code> 会利用我们第一节讲座中介绍过的 <code>PATH</code> 环境变量来进行定位。 例如，使用了 <code>env</code> 的``shebang<code> 看上去是这样的</code>#!/usr/bin/env python3`。</p><h3 id="shell-函数和-shell-脚本">shell 函数和 shell 脚本</h3><p><code>shell</code> 函数和脚本有如下一些不同点：</p><ul><li>==语言==：函数只能与 <code>shell</code> 使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li><li>==加载时刻==：函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义（<code>source 函数文件名</code>），都要重新加载一次。</li><li>==执行环境==：函数会在当前的 <code>shell</code> 环境中执行，脚本会在单独的进程中执行。因此，<strong>函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 <a href="https://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a> 将环境变量导出，并将值传递给环境变量。</strong></li><li>==两者关联==：与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。<code>shell</code> 脚本中往往也会包含它们自己的函数定义。</li></ul><h2 id="Shell-工具">Shell 工具</h2><h3 id="查看命令如何使用">查看命令如何使用</h3><p>可用工具：</p><ul><li><code>命令名 --help</code></li><li>在交互式的、基于字符处理的终端窗口中，一般也可以通过 <code>:help</code> 命令或键入 <code>?</code> 来获取帮助。</li><li><code>man 命令名</code></li><li><code>tdlr 命令名</code>（第三方，需要安装）</li></ul><h3 id="查找文件">查找文件</h3><p>可用工具：</p><ul><li><p><code>find</code>：递归地搜索符合条件的文件，如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有名称为src的文件夹</span></span><br><span class="line">find . -name src -type d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有文件夹路径中包含<span class="built_in">test</span>的python文件</span></span><br><span class="line">find . -path &#x27;*/test/*.py&#x27; -type f</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找前一天修改的所有文件</span></span><br><span class="line">find . -mtime -1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有大小在500k至10M的tar.gz文件</span></span><br><span class="line">find . -size +500k -size -10M -name &#x27;*.tar.gz&#x27;</span><br></pre></td></tr></table></figure><p>除了列出所寻找的文件之外，<code>find</code> 还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除全部扩展名为.tmp 的文件</span></span><br><span class="line">find . -name &#x27;*.tmp&#x27; -exec rm &#123;&#125; \;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找全部的 PNG 文件并将其转换为 JPG</span></span><br><span class="line">find . -name &#x27;*.png&#x27; -exec convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure><blockquote><p>解释：</p><p><code>find .</code>：从当前目录（.）开始递归搜索。</p><p><code>-name '*.tmp'</code>：查找所有扩展名为 <code>.tmp</code> 的文件。<code>*.tmp</code> 使用了通配符 <code>*</code>，匹配所有以 <code>.tmp</code> 结尾的文件名。</p><p><code>-exec rm &#123;&#125; \;</code>：</p><ul><li><p><code>-exec</code>：对于每个找到的文件执行指定的命令。</p></li><li><p><code>rm &#123;&#125;</code>：删除找到的文件。<code>&#123;&#125;</code> 是 <code>find</code> 命令的一个占位符，代表当前找到的文件。</p></li><li><p><code>\;</code>：表示 <code>-exec</code> 命令的结束。</p></li></ul><p><code>find .</code>：从当前目录（.）开始递归搜索。</p><p><code>-name '*.png'</code>：查找所有扩展名为 <code>.png</code> 的文件。<code>*.png</code> 使用了通配符 <code>*</code>，匹配所有以 <code>.png</code> 结尾的文件名。</p><p><code>-exec convert &#123;&#125; &#123;&#125;.jpg \;</code>：</p><ul><li><p><code>-exec</code>：对于每个找到的文件执行指定的命令。</p></li><li><p><code>convert &#123;&#125;</code>：使用 convert 命令（通常是 ImageMagick 软件包中的工具）进行文件格式转换。</p></li><li><p><code>&#123;&#125;.jpg</code>：将转换后的文件命名为原文件名加上 <code>.jpg</code> 扩展名。<code>&#123;&#125;</code> 是 <code>find</code> 命令的一个占位符，代表当前找到的文件。</p></li><li><p><code>\;</code>：表示 <code>-exec</code> 命令的结束。</p></li></ul></blockquote></li><li><p><code>fd</code></p><ul><li><p>尽管 <code>find</code> 用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式 <code>PATTERN</code> 的文件，你需要执行 <code>find -name '*PATTERN*'</code> (如果你希望模式匹配时是不区分大小写，可以使用 <code>-iname</code> 选项）</p><p>你当然可以使用 <code>alias</code> 设置别名来简化上述操作，但 <code>shell</code> 的哲学之一便是寻找（更好用的）替代方案。 记住，<code>shell</code> 最好的特性就是你只是在==调用程序==，因此你只要找到合适的替代程序即可（甚至自己编写）。</p></li><li><p><a href="https://github.com/sharkdp/fd"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为 <code>find</code> 的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持 unicode 并且它的语法更符合直觉。以模式<code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p></li></ul></li><li><p><code>locate</code></p><ul><li>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</li><li>这就要靠 <a href="https://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a> 了。 <code>locate</code> 使用一个由 <a href="https://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a> 负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="https://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a> 每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code> 则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">这里</a>有一个更详细的对比。</li></ul></li></ul><h3 id="查找代码">查找代码</h3><p>查找文件是很有用的技能，但是很多时候你的目标其实是查看文件的内容。一个最常见的场景是你希望查找具有某种模式的全部文件，并找它们的位置。</p><p>为了实现这一点，很多类UNIX的系统都提供了 <a href="https://man7.org/linux/man-pages/man1/grep.1.html"><code>grep</code></a> 命令，它是用于对输入文本进行匹配的通用工具。它是一个非常重要的 <code>shell</code> 工具，我们会在后续的数据清理课程中深入的探讨它。</p><p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。其中经常使用的有：</p><ul><li><p><code>-C</code> ：获取查找结果的上下文（Context）；</p></li><li><p><code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。</p><p>举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。</p></li></ul><p>但是，我们有很多办法可以对 <code>grep -R</code> 进行改进，例如使其忽略 <code>.git</code> 文件夹，使用多 CPU 等等。</p><p>因此也出现了很多它的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有使用了 requests 库的文件</span></span><br><span class="line">rg -t py &#x27;import requests&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有没有写 shebang 的文件（包含隐藏文件）</span></span><br><span class="line">rg -u --files-without-match &quot;^#!&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有的foo字符串，并打印其之后的5行</span></span><br><span class="line">rg foo -A 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印匹配的统计信息（匹配的行和文件的数量）</span></span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure><p>与 <code>find</code>/<code>fd</code> 一样，==重要的是你要知道有些问题使用合适的工具就会迎刃而解==，而具体选择哪个工具则不是那么重要。</p><h3 id="查找-shell-命令">查找 shell 命令</h3><p>目前为止，我们已经学习了如何查找文件和代码，但随着你使用shell的时间越来越久，你可能想要找到之前输入过的某条命令。首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p><p><code>history</code> 命令允许你以程序员的方式来访问 shell 中输入的历史命令。这个命令会==在标准输出中打印 shell 中的历史命令==。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 <code>grep</code> 进行模式搜索。 <code>history | grep find</code> 会打印包含 find 子串的命令。</p><p>对于大多数的shell来说，你可以使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code> 后你可以输入子串来进行匹配，查找历史命令行。</p><p>反复按下就会在所有搜索结果中循环。在 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh</a> 中，使用方向键上或下也可以完成这项工作。</p><p><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r"><code>fzf</code></a> 使用。<code>fzf</code> 是一个通用的模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p><p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。 这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell 创建的，它可以根据你最近使用过的开头相同的命令，动态地对当前的shell命令进行补全。这一功能在 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p><h3 id="文件夹导航">文件夹导航</h3><p>之前对所有操作我们都默认一个前提，即你已经位于想要执行命令的目录下，但是如何才能高效地在目录间随意切换呢？有很多简便的方法可以做到，比如设置 alias，使用 <a href="https://man7.org/linux/man-pages/man1/ln.1.html">ln -s</a> 创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p><p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用 <a href="https://github.com/clvv/fasd"><code>fasd</code></a> 和 <a href="https://github.com/wting/autojump">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p><p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm"><em>frecency</em> </a>对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em>）和时效（<em>recency</em>）进行排序。默认情况下，<code>fasd</code> 使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果你经常访问 <code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用<code>j cool</code>代替即可。</p><p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>。</p>]]></content>
      
      
      <categories>
          
          <category> The Missing Semester </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> Shell Script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MIT The Missing Semester] Lec01: The Shell</title>
      <link href="/2025/03/02/MIT-The-Missing-Semester-Lec01-The-Shell/"/>
      <url>/2025/03/02/MIT-The-Missing-Semester-Lec01-The-Shell/</url>
      
        <content type="html"><![CDATA[<h1>Lec01：The Shell</h1><p>本 Lec 主要内容：</p><ul><li>了解什么是 shell</li><li>shell 的 prompt 各部分的含义</li><li>shell 环境</li><li>在 shell 中导航</li><li>shell 的权限系统</li><li>管道符的使用</li><li>root 用户</li></ul><h2 id="为什么需要-shell">为什么需要 shell</h2><p>如今有很多交互接口可以让我们进行指令的输入，比如 GUI、语音输入甚至 AR/VR。这些交互接口可以覆盖 80% 的使用场景。但是，如果你想要完成一个操作，而这个操作恰好没有对应的按钮或语言输入，这些交互接口就捉襟见肘了。为此，使用文字接口 shell 成为了最终的选择 —— 它是全能的，任何你能在图形化接口做的事，它都能做，而且可以做的事更多。</p><h2 id="使用-shell">使用 shell</h2><h3 id="初见-shell">初见 shell</h3><p>当打开终端时，一般会看到如下内容：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">missing:~$</span><br></pre></td></tr></table></figure><p>这是 shell 最重要的文本接口。这一行内容的含义是：你的==主机名==是 <code>missing</code> 并且==当前的工作目录==（”current working directory”）或者说当前所在的位置是 <code>~</code> (表示 ==“home”==)。 <code>$</code> 符号表示现在的身份==不是 root 用户==（稍后会介绍）。</p><h3 id="在-shell-中执行命令">在 shell 中执行命令</h3><p>在 shell 中，最简单的命令是执行一个<em>程序</em>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">missing:~$ date</span><br><span class="line">Fri 10 Jan 2020 11:49:31 AM EST</span><br><span class="line">missing:~$ </span><br></pre></td></tr></table></figure><p>我们可以在执行命令的同时向程序传递<em>参数</em>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">missing:~$ echo hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>这里，我们执行了一个程序 <code>echo</code>，并传递了一个参数 <code>hello</code>。</p><blockquote><p>shell 基于空格分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），则要么用使用单引号，双引号将其包裹起来，要么使用转义符号 <code>\</code> 进行处理（<code>My\ Photos</code>）。</p></blockquote><h3 id="shell-如何知道要执行的程序在哪？">shell 如何知道要执行的程序在哪？</h3><p>其实，类似于 Python 或 Ruby，shell 是一个==编程环境==，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在 shell 中执行命令时，你实际上是在执行一段 shell 可以==解释执行==的==简短代码==。</p><p>如果你要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去咨询 <em>环境变量</em> <code>$PATH</code>，它会列出当 shell 接到某条指令时，进行程序搜索的路径：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">missing:~$ echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">missing:~$ which echo</span><br><span class="line">/bin/echo</span><br><span class="line">missing:~$ /bin/echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure><p>当我们执行 <code>echo</code> 命令时，shell 了解到需要执行 <code>echo</code> 这个程序，随后它便会在 <code>$PATH</code> 中搜索由 <code>:</code> 所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行（假定该文件是 <em>可执行程序</em>，后续课程将详细讲解）。</p><p>确定某个程序名代表的是哪个具体的程序，可以使用 <code>which</code> 程序。</p><p>我们也可以绕过 <code>$PATH</code>，通过直接指定需要执行的程序的路径来执行该程序</p><h2 id="在-shell-中导航">在 shell 中导航</h2><h3 id="路径是什么">路径是什么</h3><p>shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用 <code>/</code> 分割，而在Windows上是 <code>\</code>。路径 <code>/</code> 代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在Windows上每个盘都有一个根目录（例如： <code>C:\</code>）。</p><h3 id="相对路径和绝对路径">相对路径和绝对路径</h3><p>如果某个路径以 <code>/</code> 开头，那么它是一个 <em>绝对路径</em>，其他的都是 <em>相对路径</em> 。相对路径是指相对于当前工作目录的路径。</p><h3 id="一些导航的常用命令">一些导航的常用命令</h3><table><thead><tr><th>命令名</th><th>作用</th><th>说明</th><th>标记和选项（<code>--help</code> 省略）</th></tr></thead><tbody><tr><td><code>pwd</code></td><td>获取当前工作目录</td><td>输出到终端上</td><td>-</td></tr><tr><td><code>cd</code></td><td>切换目录</td><td><code>.</code> 表示当前目录，<code>..</code> 表示上级目录；<br />可以用绝对路径切换，也可以用相对路径切换。</td><td>-</td></tr><tr><td><code>ls</code></td><td>查看指定目录下包含哪些文件</td><td>不带参数，则查看当前目录下包含哪些文件<br />带参数，则查看参数所在路径下包含哪些文件<br /></td><td><code>-l</code>：更加详细地列出目录下文件或文件夹信息。</td></tr><tr><td><code>mv</code></td><td>重命名或移动文件</td><td>后跟两个参数，第一个原文件路径，后一个目的文件路径</td><td>-</td></tr><tr><td><code>cp</code></td><td>拷贝文件</td><td>后跟两个参数，第一个原文件路径，后一个拷贝目的文件路径</td><td></td></tr><tr><td><code>mkdir</code></td><td>新建文件夹</td><td>后跟多个参数，表示创建多个文件夹</td><td>-</td></tr><tr><td><code>rm</code></td><td>删除文件</td><td>后跟多个参数，为待删除文件路径</td><td>-</td></tr><tr><td><code>rmdir</code></td><td>删除文件夹</td><td>后跟多个参数，为待删除文件夹<br />只能删除空文件夹</td><td>-</td></tr><tr><td><code>cat</code></td><td>获取一个文件中的所有内容</td><td>后跟一个参数，为文件路径；默认将内容输出到终端</td><td></td></tr><tr><td><code>tail</code></td><td>获取输入流内容末尾 <code>n</code> 行的内容</td><td>后跟一个可选参数，表示文件路径；如果输入流中已经有内容，可以不指定；默认输出到终端</td><td><code>-n?</code>：<code>-n</code> 为选项，<code>?</code> 为任意一个数字，合在一起指定获取末尾内容的行数。</td></tr><tr><td><code>grep</code></td><td>在输入流内容中查找指定内容</td><td>默认输出到终端</td><td></td></tr><tr><td><code>man</code></td><td>获取某个程序的文档（用户手册）</td><td>后跟一个参数：程序名</td><td>-</td></tr></tbody></table><h3 id="文件和文件夹权限">文件和文件夹权限</h3><p>当使用 <code>ls -l</code> 时，可以看到如下的结果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">missing:~$ ls -l /home</span><br><span class="line">drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing</span><br></pre></td></tr></table></figure><p>接下来依次解释这一行输出各部分的含义：</p><table><thead><tr><th><code>drwxr-xr-x</code>：文件类型和权限</th><th><code>1</code>：链接数</th><th><code>missing</code>：所有者</th><th><code>users</code>：所有组</th><th><code>4096</code>：文件大小</th><th><code>Jun 15 2019</code>：最后修改时间</th><th><code>missing</code>：文件名</th></tr></thead><tbody><tr><td>第一个字符表示这是一个目录<br />接下来九个字符分成三组，每组三个字符，分别表示不同用户的访问权限：<br />- 第一组表示所有者的权限<br />- 第二组表示所有组的权限<br />- 第三组表示其他用户的权限<br /><code>rwx</code> 三个字母分别代表 ==读、写、执行== 权限</td><td>这是目录的硬链接数，对于目录来说，这是其子目录（包括 <code>.</code> 和 <code>..</code>）的数量。这里显示 1，表示该目录下没有子目录（只有 <code>.</code> 和 <code>..</code>）。</td><td>这是该目录的所有者，即用户 <code>missing</code>。</td><td>这是该目录所属的组，即组 <code>users</code>。</td><td>这是该目录的大小，单位是==字节==。对于目录来说，大小一般是包含目录项所需的字节数。</td><td>这是该目录最后一次修改的时间。格式为 月 日 年，表示该目录在 2019 年 6 月 15 日进行了最后一次修改。</td><td>这是目录的名称，即 <code>missing</code>。</td></tr></tbody></table><blockquote><p>对于文件来说：<code>rwx</code> 对应的就是文件的 ==读、写、执行==；但是对于文件夹来说：<code>rwx</code> 对应的是该文件夹 ==是否能列出其包含的内容、是否能添加、删除、重命名其包含的内容、是否能进入该目录==。</p><p>**注意⚠️：**如果没有对一个文件夹的执行权限，相当于这个文件夹里的所有文件我都无能为力。</p><p>**因为：**不管是ls命令还是写文件还是读文件内容，都需要给出文件的路径，而如果对文件所处文件夹的没有执行权限，在路径解析到文件夹的时候就拒绝访问了，所以不能执行任何操作。</p></blockquote><h2 id="在程序间创建连接">在程序间创建连接</h2><p>在 shell 中，程序有两个主要的 ==“流”== ：它们的==输入流==和==输出流==。 当程序尝试==读取信息==时，它们会从==输入流中进行读取==，当程序==打印信息==时，它们会将==信息输出到输出流==中。 通常，一个程序的输入输出流都是终端。也就是，用户键盘作为输入，显示器作为输出。 但是，我们也可以重定向这些流！</p><p>最简单的重定向是 <code>&lt; file</code> 和 <code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">missing:~$ echo hello &gt; hello.txt</span><br><span class="line">missing:~$ cat hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ cat &lt; hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ cat &lt; hello.txt &gt; hello2.txt</span><br><span class="line">missing:~$ cat hello2.txt</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>&gt;</code> 是覆盖内容，使用 <code>&gt;&gt;</code> 是追加内容。</p></blockquote><p>使用管道（ <em>pipes</em> ），我们能够更好的利用文件重定向。 <code>|</code> 操作符允许我们==将一个程序的输出和另外一个程序的输入连接起来==：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">missing:~$ ls -l / | tail -n1</span><br><span class="line">drwxr-xr-x 1 root  root  4096 Jun 20  2019 var</span><br><span class="line">missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=&#x27; &#x27; -f2</span><br><span class="line">219</span><br></pre></td></tr></table></figure><blockquote><p>我们会在数据清理一章中更加详细的探讨如何更好的利用管道。</p></blockquote><h2 id="root-用户">root 用户</h2><p>对于大多数的类 Unix 系统，有一类用户是非常特殊的，那就是：==根用户（root user）==。 你应该已经注意到了，在上面的输出结果中，根用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件。</p><p>通常我们并不会以根用户的身份直接登录系统，因为这样可能会因为某些错误的操作而破坏系统。 取而代之的是我们会在需要的时候使用 <code>sudo</code> 命令。顾名思义，它的作用是让你可以==以 su（super user 或 root 的简写）的身份执行一些操作==。 当你遇到拒绝访问（permission denied）的错误时，通常是因为此时你必须是根用户才能操作。然而，请再次确认你是真的要执行此操作。</p><blockquote><p><strong>使用 <code>sudo</code> 的注意事项⚠️：在 shell 中，<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。 <code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写。如果要向一个只有 root 用户才有权限访问的文件中写入内容，需要用 <code>sudo</code> 修饰可以往文件中写入内容的某程序，才能顺利写入。总的要点来说：要访问权限受限的文件时，需要用 <code>sudo</code> 修饰访问该文件的程序。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> The Missing Semester </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic Web Development -- Java Web</title>
      <link href="/2025/03/02/Basic-Web-Development/"/>
      <url>/2025/03/02/Basic-Web-Development/</url>
      
        <content type="html"><![CDATA[<h1>Java Web</h1><h2 id="Web-网站的开发模式">Web 网站的开发模式</h2><p>Web 网站的工作流程</p><img src="/2025/03/02/Basic-Web-Development/Web%E7%BD%91%E7%AB%99%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class=""><p>Web 开发课程安排</p><p>包括：</p><ol><li><p>前端 Web 开发</p><ul><li>HTML、CSS、JavaScript</li><li>Vue、ElementUI、Nginx</li><li>Ajax、Axios</li></ul></li><li><p>后端 Web 开发</p><ul><li><p>Maven</p></li><li><p>SpringBoot Web 基础篇</p></li><li><p>MySQL</p></li><li><p>SpringBoot Mybatis</p></li><li><p>SpringBoot Web 开发篇</p></li><li><p>SpringBoot Web 进阶篇</p></li></ul></li></ol><hr><h2 id="Web-前端开发">Web 前端开发</h2><h3 id="Web-标准">Web 标准</h3><p>Web 标准也称为网页标准，由一系列的标准组成，大部分由 W3C 负责指定。</p><p>三个组成部分：</p><ol><li>HTML：负责<strong>网页的结构</strong>（页面元素和内容）</li><li>CSS：负责<strong>网页的表现</strong>（页面元素的外观、位置等页面样式，如颜色、大小等）</li><li>JavaScript：负责<strong>网页的行为</strong>（交互效果）</li></ol><h3 id="HTML-CSS">HTML &amp; CSS</h3><h3 id="JavaScript-Vue">JavaScript &amp; Vue</h3><h4 id="什么是-JavaScript">什么是 JavaScript</h4><ul><li><p>JavaScript 是一门<strong>跨平台</strong>、<strong>面向对象</strong>的<strong>脚本</strong>（不需要编译）语言。是用来控制网页行为的，它能使网页可交互。</p></li><li><p>JavaScript 和 Java 是完全不同的语言，不论是概念还是设计。但是基础语法类似。</p></li><li><p>JavaScript 在 1995 年有 Brendan Eich 发明，并于 1997 年成为 <strong>ECMA 标准</strong>。</p><blockquote><p>ECMA 国际（前身为欧洲计算机制造商协会），制定了标准化的脚本程序设计语言 ECMAScript，这种语言得到广泛应用。而 JavaScript 是遵守 ECMAScript标准的。</p></blockquote></li><li><p>ECMAScript 6 是最新的 JavaScript 版本 （发布于 2015 年）。</p></li></ul><h4 id="JavaScript-引入方式">JavaScript 引入方式</h4><ul><li><strong>内部脚本</strong>：将 JavaScript 代码定义在 HTML页面中<ul><li>JavaScript 代码必须位于 <code>&lt;script&gt;&lt;/script&gt;</code> 标签之间</li><li>在 HTML 文档中，可以在<strong>任意地方</strong>，放置<strong>任意数量</strong>的 <code>&lt;script&gt;</code></li><li>一般会把脚本置于 <code>&lt;body&gt;</code> 元素的<strong>底部</strong>，可以改善页面显示速度</li></ul></li><li><strong>外部脚本</strong>：将 JavaScript 代码定义在外部 js 文件中，然后引入到 HTML 页面中<ul><li>外部 js 文件中，只包含 js 代码，不包含 <code>&lt;script&gt;</code>标签</li><li><code>&lt;script&gt;</code> 标签不能自闭合</li></ul></li></ul><h4 id="JavaScript-基础语法">JavaScript 基础语法</h4><h5 id="书写语法">书写语法</h5><ul><li><strong>区分大小写</strong></li><li>每行结尾的<strong>分号可有可无</strong></li><li>注释：<ul><li>单行注释： //</li><li>多行注释：/*    */</li></ul></li><li><strong>大括号</strong>表示代码块</li><li>输出语句：<ul><li>window.alert()： 浏览器弹出警告框</li><li>document.write()：输出到 HTML 文档，在浏览器页面中展示</li><li>console.log()：输出到浏览器控制台</li></ul></li></ul><h5 id="变量">变量</h5><ul><li><p>JavaScript 中用 <code>var</code> 关键字来声明变量。</p></li><li><p>JavaScript 是一门<strong>弱类型语言</strong>，变量<strong>可以存放不同类型的值</strong>。</p></li><li><p>变量名需要遵循如下规则：</p><ul><li>变量名可以是任何<strong>字母、数字、下划线或美元符号</strong></li><li><strong>数字不能开头</strong></li><li>建议使用<strong>驼峰命名法</strong></li></ul></li><li><p><code>var</code> 关键字定义的变量的特点：</p><ol><li>定义出来的变量属于<strong>全局变量</strong></li><li>相同变量可以<strong>重复定义</strong></li></ol><blockquote><ul><li>ECMAScript 6 新增了 <code>let</code> 关键字来定义变量。它的用法类似于 <code>var</code>，但是所声明的变量，只在 <code>let</code> 关键字所在的<strong>代码块内有效</strong>（局部变量），且<strong>不允许重复声明</strong>。</li><li>ECMAScript 6 新增了 <code>const</code> 关键字，用来声明一个<strong>只读</strong>的常量。一旦声明，常量的值就不能改变。</li></ul></blockquote></li></ul><h5 id="数据类型、运算符、流程控制语句">数据类型、运算符、流程控制语句</h5><p><strong>数据类型</strong>：JavaScript 中分为：<strong>原始类型</strong> 和 <strong>引用类型</strong></p><ul><li><p>原始类型有：</p><ul><li>number：数字（整数、小鼠、NaN）</li><li>string：字符串，单双引号皆可</li><li>boolean：布尔类型，取值为 <code>ture</code> 和 <code>false</code></li><li>null：对象为空</li><li>undefined：当声明的变量未初始化时，该变量的默认类型                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       是 <code>undefined</code></li></ul><blockquote><p>使用 <code>typeof</code> 运算符可以获取数据类型</p></blockquote></li><li><p>运算符：</p><ul><li>算数运算符：+、-、*、/、%、++、–</li><li>赋值运算符：=、+=、-=、*=、/=、%=</li><li>比较运算符：&gt;、&lt;、&gt;=、&lt;=、!=、==、<code>===</code></li><li>逻辑运算符：&amp;&amp;、||、!</li><li>三元运算符：条件表达式 ? true_value : false_value</li></ul><blockquote><p>== 与 ===：</p><ul><li>== 在比较时会先进行类型转换，再判断是否相等</li><li>=== 在比较时不会进行类型转换，如果类型不同直接返回 false</li></ul></blockquote><blockquote><p>类型转换：</p><ul><li>字符串类型转为数字类型：<ul><li>将字符串字面值转为数字。如果字面值不是数字，则转为 NaN</li><li>使用 parseInt() 函数转换，该函数从字符串头开始匹配数字，直到遇到非数字为止</li><li>举例：parseInt(12) -&gt; 12, parseInt(12A45) -&gt; 12, parseInt(A45) -&gt; NaN</li></ul></li><li>其他类型转为布尔类型：<ul><li>Number：<strong>0 和 NaN</strong> 为 false，其他均为 true</li><li>String：<strong>空字符串</strong>为 false，其他均为 true</li><li><strong>Null 和 undefined</strong>：均为 false</li></ul></li></ul></blockquote></li><li><p>流程控制语句：</p><ul><li>if…else if…else</li><li>switch</li><li>for</li><li>while</li><li>do … while</li><li>语法与 Java 一致</li></ul></li></ul><h4 id="JavaScript-函数">JavaScript 函数</h4><ul><li><p>介绍：函数（方法）是被设计为执行特定任务的代码块</p></li><li><p>定义：JavaScript 函数通过 <code>function</code> 关键字进行定义，语法为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">funcName</span>(<span class="params">arg1, arg2, ...</span>) &#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcName = <span class="keyword">function</span>(<span class="params">arg1, arg2, ...</span>) &#123;</span><br><span class="line">    <span class="comment">// funciton body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意：</p><ul><li><strong>形式参数不需要类型</strong>。因为 JavaScript 是弱类型语言</li><li><strong>返回值也不需要定义类型</strong>，在函数内部直接使用 <code>return</code> 返回即可</li></ul></li><li><p>调用：函数名称(实参列表)</p></li><li><p>注意事项：JavaScript 中，函数调用可以传<strong>递任意个数</strong>的参数（但函数使用哪些参数会按照<strong>顺序</strong>来决定）</p></li></ul><h4 id="JavaScript-对象">JavaScript 对象</h4><h5 id="基础对象">基础对象</h5><h6 id="Array">Array</h6><ul><li><p>JavaScript中 Array 对象用于定义数组。</p></li><li><p>定义：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="keyword">new</span> <span class="title class_">Array</span>(element list);</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = [element list];</span><br></pre></td></tr></table></figure></li><li><p>访问：<code>name[index];</code></p></li><li><p>特点：</p><ol><li><p>长度可变：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr[<span class="number">10</span>] = <span class="number">50</span>; <span class="comment">// 允许的操作</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">10</span>]); <span class="comment">// 50</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">9</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">8</span>]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p>类型可变（任意）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">5</span>] = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 允许的操作</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">5</span>]); <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>属性：</p><ul><li>length：设置或返回数组中元素的数量</li></ul></li><li><p>方法：</p><ul><li><p>forEach()：遍历数组中的每个<strong>有值</strong>的元素，并调用一次传入的函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e); <span class="comment">// 遍历数组每个有值的元素，并对其执行一次函数的操作            </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或用箭头函数简化函数定义：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>push()：将新元素添加到数组的末尾，并<strong>返回新的长度</strong></p></li><li><p>splice()：从数组中删除元素</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 从arr的索引为2的位置开始删2个元素</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h6 id="String">String</h6><ul><li>创建方式：<ul><li>方式1：<code>var name = new String(&quot;...&quot;);</code></li><li>方式2：<code>var name = &quot;...&quot;;</code></li></ul></li><li>属性：length：获取字符串的长度</li><li>方法：<ul><li>charAt()：返回在指定位置的字符</li><li>indexOf()：检索某个子字符串第一次出现的位置</li><li>trim()：去除字符串两边的空格，返回新字符串</li><li>substring()：提取字符串中两个指定索引之间（含头不含尾）的字符子串</li></ul></li></ul><h6 id="JSON">JSON</h6><ul><li><p>JavaScript 自定义对象</p><ul><li><p>定义格式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = &#123;</span><br><span class="line">    <span class="attr">attr1</span>: value1,</span><br><span class="line">    <span class="attr">attr2</span>: value2,</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">attrn</span>: valuen,</span><br><span class="line">    <span class="attr">funcName</span>: <span class="keyword">function</span>(<span class="params">arg list</span>)&#123;&#125;,</span><br><span class="line">    <span class="title function_">funcName</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 定义函数的另一种语法 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>调用格式：</p><ul><li>name.attr;</li><li>name.funcName(arg list);</li></ul></li></ul></li><li><p>JSON 介绍</p><ul><li><p>概念：JSON 全称为 <strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation，JavaScript对象标记法</p></li><li><p>JSON 是通过 JavaScript 对象标记法书写的<strong>文本</strong></p></li><li><p>JSON 格式的数据：</p><img src="/2025/03/02/Basic-Web-Development/JSON%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE.png" class=""></li><li><p>key 都要用<strong>双引号</strong>引起来，其他的与 JavaScript对象的格式相同</p></li><li><p>由于 JSON语法简单，层次结构鲜明，现在多用于<strong>数据载体</strong>，在网络中进行数据传输</p></li></ul></li><li><p>JSON 基础语法</p><ul><li><p>定义：<code>var name = '&#123;&quot;key1&quot;: value1, &quot;key2&quot;: value2&#125;';</code></p><ul><li><p>示例：<code>var userStr = '&#123;&quot;name&quot;: &quot;Jerry&quot;, &quot;age&quot;: 18, &quot;addr&quot;: [&quot;北京&quot;, &quot;上海&quot;, &quot;西安&quot;]&#125;';</code></p></li><li><p>value 的数据类型可以为：</p><ul><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>数组（在方括号中）</li><li>对象（在花括号中）</li><li>null</li></ul></li><li><p>JSON 字符串转为 JS 对象</p><p><code>var jsObject = JSON.parse(userStr);</code></p></li><li><p>JS 对象转为 JSON 字符串</p><p><code>var jsonStr = JSON.stringify(jsObject);</code></p></li></ul></li></ul></li></ul><h5 id="浏览器对象模型-BOM">浏览器对象模型 - BOM</h5><ul><li>概念：<strong>B</strong>rowser <strong>O</strong>bject <strong>M</strong>odel 浏览器对象模型，允许 JavaScript 与浏览器对话，JavaScript 将浏览器的各个组成部分封装为对象。</li><li>组成：<ul><li>Window：浏览器窗口对象</li><li>Navigator：浏览器对象</li><li>Screen：屏幕对象</li><li>History：历史记录对象</li><li>Location：地址栏对象</li></ul></li><li>Window<ul><li>介绍：浏览器窗口对象</li><li>获取：直接使用 window，其中 <code>window.</code> 可省略</li><li>属性<ul><li>history：对 History 对象的只读引用。</li><li>location：对于窗口或框架的 Location 对象</li><li>navigator：对 Navigator 对象的只读引用</li></ul></li><li>方法<ul><li>alert()：显示带有一段消息和一个确认按钮的警告框</li><li>confirm()：显示带有一段消息以及确认按钮和取消按钮的对话框，有返回值，点击确定返回 true，点击取消返回 false</li><li>setInterval()：按照指定的周期（毫秒为单位）来调用函数或计算表达式</li><li>setTimeout()：在指定的毫秒数后调用函数或计算表达式</li></ul></li><li>Location<ul><li>介绍：地址栏对象</li><li>获取：使用 <code>window.location</code> 获取，其中 <code>window.</code> 可以省略</li><li>属性：<ul><li>href：设置或返回完整的 URL</li></ul></li></ul></li></ul></li></ul><h5 id="文档对象模型-DOM">文档对象模型 - DOM</h5><ul><li><p>概念：<strong>D</strong>ocument <strong>O</strong>bject <strong>M</strong>odel，文档对象模型</p></li><li><p>将标记语言的各个组成部分封装为对应的对象：</p><ul><li>Document：整个文档对象</li><li>Element：元素对象</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li></ul></li><li><p>JavaScipt 通过 DOM，能够对HTML进行操作：</p><ul><li>改变 HTML 元素的内容</li><li>改变 HTML 元素的样式</li><li>对 HTML DOM 事件作出反应</li><li>添加和删除 HTML 元素</li></ul></li><li><p>DOM 是 W3C 的标准，定义了访问 HTML 和 XML 文档的标准，分为三个不同部分：</p><ol><li>Core DOM - 所有文档类型的标准模型‘<ul><li>Document：整个文档对象</li><li>Element：元素对象</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li></ul></li><li>XML DOM- XML 文档的标准模型</li><li>HTML DOM - HTML 文档的标准模型<ul><li>Image：<code>&lt;img&gt;</code></li><li>Button：<code>&lt;input type='button'&gt;</code></li></ul></li></ol></li><li><p>获取指定 HTML 元素的对象</p><ul><li><p>HTML 中的 Element 对象可以通过 Document 对象获取，而 Document 对象是通过 window 对象获取的</p></li><li><p>Document 对象中提供了以下获取 Element 元素对象的函数：</p><ol><li><p>根据 <code>id</code> 属性值获取，返回单个 Element 对象</p><p><code>var h1 = document.getElementById('h1');</code></p></li><li><p>根据标签名称获取，返回 Element 对象<strong>数组</strong></p><p><code>var divs = document.getElementsByTagName('div');</code></p></li><li><p>根据 <code>name</code> 属性值获取，返回 Element 对象<strong>数组</strong></p><p><code>var hobbies = document.getElementsByName('hobby');</code></p></li><li><p>根据 <code>class</code> 属性值获取，返回 Element 对象<strong>数组</strong></p><p><code>var clss = document.getElementsByClassName('cls');</code></p></li></ol></li></ul></li><li><p>改变 Element 元素</p><ul><li>查阅文档，根据 Element 元素所拥有的属性和方法来改变 Element 元素</li></ul></li></ul><h4 id="JavaScript-事件监听">JavaScript 事件监听</h4><ul><li>事件： HTML 事件是发生在 HTML 元素上的 “事情”。比如：<ul><li>按钮被点击</li><li>鼠标移动到元素上</li><li>按下键盘按键</li></ul></li><li>事件监听：JavaScript 可以在事件被侦测到时 <strong>执行代码</strong></li></ul><h5 id="事件绑定">事件绑定</h5><ul><li><p>方式一：通过 HTML 标签中的事件属性进行绑定</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;on()&quot;</span> value=<span class="string">&quot;button1&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(<span class="string">&quot;I&#x27;m clicked!&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>方式二：通过 DOM 元素属性绑定</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;btn&quot;</span> value=<span class="string">&quot;button2&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(<span class="string">&quot;I&#x27;m clicked!&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h5 id="常见事件">常见事件</h5><table><thead><tr><th style="text-align:center">事件名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">onclick</td><td style="text-align:center">鼠标单击事件</td></tr><tr><td style="text-align:center">onblur</td><td style="text-align:center">元素失去焦点</td></tr><tr><td style="text-align:center">onfocus</td><td style="text-align:center">元素获得焦点</td></tr><tr><td style="text-align:center">onload</td><td style="text-align:center">某个页面或图像被完成加载</td></tr><tr><td style="text-align:center">onsubmit</td><td style="text-align:center">当表单提交时触发该事件</td></tr><tr><td style="text-align:center">onkeydown</td><td style="text-align:center">某个键盘的键被按下</td></tr><tr><td style="text-align:center">onmouseover</td><td style="text-align:center">鼠标被移到某元素之上</td></tr><tr><td style="text-align:center">onmouseout</td><td style="text-align:center">鼠标从某元素上移开</td></tr></tbody></table><h4 id="Vue">Vue</h4><h5 id="什么是Vue？">什么是Vue？</h5><ul><li><p>Vue 是一套<strong>前端框架</strong>，免除原生 JavaScript 中的 DOM 操作，简化书写</p></li><li><p>基于 <strong>MVVM</strong> (Model-View-ViewModel) 思想，实现数据的<strong>双向绑定</strong>，将编程的关注点放在数据上</p></li><li><p>官网：<a href="Vue%E5%AE%98%E7%BD%91">https://v2.cn.vuejs.org/</a></p><blockquote><p>框架：是一个半成品软件，是一套可重用的、通用的软件基础代码模型。基于框架进行开发，更加快捷、更加高效。</p></blockquote></li><li><p>MVVM模型</p><img src="/2025/03/02/Basic-Web-Development/MVVM%E6%A8%A1%E5%9E%8B.png" class=""></li></ul><h5 id="Vue快速入门">Vue快速入门</h5><ul><li><p>新建 HTML 页面，引入 Vue.js 文件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"><span class="tag">&lt;/<span class="name">scripts</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure></li><li><p>在 JS 代码区域，创建 Vue 核心对象，定义数据模型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&quot;Hello Vue!&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写视图</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>插值表达式：</p><ul><li>形式： </li><li>内容可以是：<ul><li>变量</li><li>三元运算符</li><li>函数调用</li><li>算术运算</li></ul></li></ul></blockquote></li></ul><h5 id="Vue-常见指令">Vue 常见指令</h5><ul><li><p>指令：指 HTML 标签上带有 <code>v-</code> 前缀的特殊属性，不同指令具有不同含义。</p></li><li><p>常用指令：</p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">v-bind</td><td style="text-align:center">为 HTML 标签绑定属性值，如设置 href，css 样式等</td></tr><tr><td style="text-align:center">v-model</td><td style="text-align:center">在表单元素上创建双向数据绑定</td></tr><tr><td style="text-align:center">v-on</td><td style="text-align:center">为 HTML 标签绑定事件</td></tr><tr><td style="text-align:center">v-if</td><td style="text-align:center">条件性地渲染某元素，判定为 true 是渲染，否则不渲染</td></tr><tr><td style="text-align:center">v-else-if</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">v-else</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">v-show</td><td style="text-align:center">根据条件展示某元素，区别在于切换的是 display 属性的值</td></tr><tr><td style="text-align:center">v-for</td><td style="text-align:center">列表渲染，遍历容器的元素或者对象的属性</td></tr></tbody></table><ul><li><p>v-bind：</p><p>常规用法：<code>&lt;a v-bind:href=&quot;url&quot;&gt;xxx&lt;/a&gt;</code></p><p>简化用法：<code>&lt;a :href=&quot;url&quot;&gt;xxx&lt;/a&gt;</code></p></li><li><p>v-model：</p><p><code>&lt;input type=&quot;text&quot; v-model=&quot;url&quot;&gt;</code></p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">     <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">     <span class="attr">data</span>: &#123;</span><br><span class="line">         <span class="attr">url</span>:<span class="string">&quot;https://www.google.com&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>注意事项：通过 v-bind 或者 v-model 绑定的变量，必须在数据模型中声明。</p></blockquote><ul><li><p>v-on：</p><p>常规用法：<code>&lt;input type=&quot;text&quot; value=&quot;button&quot; v-on:click=&quot;handle()&quot;&gt;</code></p><p>简化写法：<code>&lt;input type=&quot;text&quot; value=&quot;button&quot; @click=&quot;handle()&quot;&gt;</code></p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">     <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">     <span class="attr">data</span>: &#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">methods</span>: &#123;</span><br><span class="line">         <span class="attr">handle</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">             <span class="title function_">alert</span>(<span class="string">&quot;I&#x27;m clicked!&quot;</span>)；</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>v-if、v-else-if、v-else：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">年龄&#123;&#123;age&#125;&#125;，经判定为：</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;age &lt;= 35&quot;</span>&gt;</span>年轻人<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else-if</span>=<span class="string">&quot;age &gt; 35 &amp;&amp; age &lt; 60&quot;</span>&gt;</span>中年人<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>老年人<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>v-show：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">年龄&#123;&#123;age&#125;&#125;，经判定为：</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show:</span>&quot;<span class="attr">age</span> &lt;= <span class="string">35</span>&quot;&gt;</span>年轻人<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>v-for：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;addr in addrs&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;addr&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(addr, index) in addrs&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;index + 1&#125;&#125; : &#123;&#123;addr&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">...</span><br><span class="line"><span class="attr">addrs</span>: [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;广州&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>, <span class="string">&#x27;成都&#x27;</span>, <span class="string">&#x27;杭州&#x27;</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></blockquote></li></ul></li></ul><h5 id="Vue-生命周期">Vue 生命周期</h5><ul><li><p>生命周期：指一个对象从创建到销毁的整个过程。</p></li><li><p>Vue 生命周期的八个阶段：<strong>每触发一个生命周期事件，会自动执行一个生命周期方法</strong>（钩子）</p><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:center">阶段周期</th></tr></thead><tbody><tr><td style="text-align:center">beforeCreate</td><td style="text-align:center">创建前</td></tr><tr><td style="text-align:center">created</td><td style="text-align:center">创建后</td></tr><tr><td style="text-align:center">beforeMount</td><td style="text-align:center">挂载前</td></tr><tr><td style="text-align:center"><strong>mounted</strong></td><td style="text-align:center"><strong>挂载完成</strong></td></tr><tr><td style="text-align:center">beforeUpdated</td><td style="text-align:center">更新前</td></tr><tr><td style="text-align:center">updated</td><td style="text-align:center">更新后</td></tr><tr><td style="text-align:center">beforeDestory</td><td style="text-align:center">销毁前</td></tr><tr><td style="text-align:center">destoryed</td><td style="text-align:center">销毁后</td></tr></tbody></table><img src="/2025/03/02/Basic-Web-Development/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA.png" class=""></li></ul><h3 id="Ajax-Axios-Element">Ajax &amp; Axios &amp; Element</h3><h4 id="Ajax">Ajax</h4><ul><li><p>概念：<strong>A</strong>synchronous <strong>J</strong>avaScript <strong>A</strong>nd <strong>X</strong>ML，<strong>异步</strong>的 JavaScript 和 XML</p></li><li><p>作用：</p><ul><li><p>数据交换：通过 Ajax 可以给服务器发送请求，并获取服务器相应的数据</p></li><li><p>异步交互：可以在<strong>不重新加载整个页面</strong>的情况下，与服务器交换数据并<strong>更新部分网页</strong>的技术，如：搜索联想、用户名是否可用的校验等等。</p><img src="/2025/03/02/Basic-Web-Development/AJAX%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B%E5%9B%BE%E7%A4%BA.png" class=""></li></ul></li><li><p>同步与异步</p><ul><li>同步：服务器处理请求时客户端需要等待，直到服务器返回数据后才能进行后面操作。</li><li>异步：服务器处理请求时客户端可以进行其他操作，不需要等待服务器端。</li></ul></li><li><p>原生 Ajax（繁琐，已弃用）</p><ol><li><p>准备数据地址：<a href="%E6%95%B0%E6%8D%AE%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%B7%B2%E5%BC%83%E7%94%A8">http://yapi.smart-xwork.cn/mock/169327./emp/list</a></p></li><li><p>创建 <code>XMLHttpRequest</code> 对象：用于和服务器交换数据</p></li><li><p>向服务器发送请求</p></li><li><p>获取服务器响应数据</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;获取数据&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;getData()&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>= <span class="string">&quot;div1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 1.创建XMLHttpRequest</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> xmlHttpRequest = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 2.发送异步请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        xmlHttpRequest.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="attr">http</span>:<span class="comment">//yapi.smart-xwork.cn/mock/169327./emp/list);</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        xmlHttpRequest.<span class="title function_">send</span>(); <span class="comment">// 发送请求                    </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 3.获取服务器响应数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        xmlHttpRequest.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">if</span> (xmlHttpRequest.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xmlHttpRequest.<span class="property">status</span> == <span class="number">200</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>).<span class="property">innerHTML</span> = xmlHttpRequest.<span class="property">responseText</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>Axios（基于原生 Ajax 封装，简化书写，快速开发）</p><ul><li><p>官网：<a href="Axios%E5%AE%98%E7%BD%91">https://www.axios-http.cn/</a></p></li><li><p>Axios 使用步骤：</p><ol><li><p>引入 Axios 的 js 文件：</p><p><code>&lt;script src=&quot;js/axios-0.18.0.js&quot;&gt;&lt;/script&gt;</code></p></li><li><p>使用 Axios 发送请求，并获取响应结果</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://...&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://...&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:<span class="string">&quot;id=1&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>then 方法中需要传入一个函数参数，称为成功回调函数，在成功获得服务器数据时调用，数据被封装为一个对象赋值给 result（回调函数参数）。</p></blockquote></li></ol><ul><li><p>请求方式简化（推荐）：</p><ul><li><p>axios.get(url [, config])</p></li><li><p>axios.delete(url [, config])</p></li><li><p>axios.post(url [, data [, config]])</p></li><li><p>axios.put(url [,data [,config]])</p></li><li><p>使用方式示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;http://...&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&quot;http://...&quot;</span>, <span class="string">&quot;id=1&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><h4 id="前后端分离开发">前后端分离开发</h4><h5 id="介绍">介绍</h5><h6 id="早期开发模式：前后端混合开发">早期开发模式：前后端混合开发</h6><ul><li>前端人员开发好一个静态的 HTML 页面，剩下的 CSS JS AXIOS JAVA 数据库等都交给主力开发人员来开发，<strong>前端代码和后端代码都放在一个工程文件</strong>中。</li><li>问题：<ol><li>沟通成本高</li><li>分工不明确</li><li>项目不便于管理</li><li>项目不便于维护扩展</li></ol></li></ul><h6 id="当前主流开发模式：前后端分离开发">当前主流开发模式：前后端分离开发</h6><img src="/2025/03/02/Basic-Web-Development/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91%E5%9B%BE%E7%A4%BA.png" class=""><blockquote><p>前端团队负责前端工程，后端团队负责后端工程，前端与后端<strong>交互依靠异步请求</strong>，保证两者能够顺利交互的开发规范定义在<strong>接口文档</strong>中。</p></blockquote><blockquote><p>接口文档由产品经理通过<strong>分析页面原型和需求</strong>来定义和书写。</p></blockquote><p>开发流程：</p><p>需求分析 -》 接口定义 -》 前后端并行开发 -》 测试 -》 前后端联调测试</p><h5 id="YApi">YApi</h5><ul><li>介绍：YApi 是高效、易用、功能强大的 api 管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务</li><li>官网：[<a href="http://yapi.smart-xwork.cn/">http://yapi.smart-xwork.cn/</a>](YApi 官网)</li><li>功能：<ol><li>API 接口管理</li><li>Mock 服务：模拟真实接口，生成接口的模拟测试数据，用于前端工程测试</li></ol></li><li>使用步骤：<ol><li>添加项目</li><li>添加分类</li><li>添加接口</li><li>完善接口信息</li><li>（可选）添加 mock 期望</li></ol></li></ul><h4 id="前端工程化">前端工程化</h4><p>前端工程化开发：在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化，标准化（借助 Vue 提供的脚手架工具）。</p><ul><li>模块化：将 JS 和 CSS 制作成一个个可以复用的模块</li><li>组件化：将 UI 结构、CSS 样式以及 JS 的行为封装成一个个的组件</li><li>规范化：提供一套标准的规范的<strong>目录结构、编码规范和接口规范</strong>，所有开发人员都遵循这一套统一的规范进行开发</li><li>自动化：项目的构建、部署和测试自动化进行</li></ul><h5 id="环境准备">环境准备</h5><h6 id="vue-cli">vue-cli</h6><ul><li>介绍：vue-cli 是 Vue 官方提供的一个脚手架，用于快速生成一个 Vue 的项目模板</li><li>vue-cli 提供了如下功能：<ul><li>统一的目录结构</li><li>本地调试</li><li>热部署</li><li>单元测试</li><li>集成打包上线</li></ul></li><li>依赖环境：NodeJS</li></ul><h5 id="Vue-项目简介">Vue 项目简介</h5><ul><li><p>目录结构：</p><p>基于 Vue 脚手架创建出来的工程，有标准的目录结构，如下：</p><img src="/2025/03/02/Basic-Web-Development/Vue%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" class=""><ul><li>node_modules：存放整个项目的依赖包</li><li>public：存放项目的静态文件</li><li><strong>src：存放项目的源代码</strong></li><li>package.json：存放模块基本信息，项目开发所需要模块，版本信息</li><li>vue.config.js：保存 vue 配置的文件，如：代理、端口的配置等</li></ul><p><code>src</code> 目录下的结构如下：</p><img src="/2025/03/02/Basic-Web-Development/src%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" class=""><ul><li>assets：静态资源</li><li>components：可重用的组件</li><li>router：路由配置</li><li>views：视图组件（页面）</li><li>App.vue：入口页面（根组件）</li><li>main.js：入口 js 文件</li></ul></li></ul><h5 id="Vue-项目开发流程">Vue 项目开发流程</h5><h4 id="Vue-组件库-Element">Vue 组件库 Element</h4><h5 id="什么是-Element">什么是 Element</h5><ul><li>Element：是饿了么团队研发的，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端<strong>组件</strong>库</li><li>组件：组成网页的部件，例如 超链接、按钮、图片、表格、表单、分页条等等</li><li>官网：<a href="Element%E5%AE%98%E7%BD%91">https://element.eleme.cn/#/zh-CN</a></li></ul><h5 id="快速入门">快速入门</h5><ul><li><p>安装 ElementUI 组件库（在当前工程的目录下），在命令行执行指令：</p><p><code>npm install element-ui@2.15.3</code></p></li><li><p>引入 ElementUI 组件库</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 main.js 文件中引入</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementUI</span> <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">ElementUI</span>);</span><br></pre></td></tr></table></figure></li><li><p>访问官网，复制组件代码，调整</p></li></ul><h5 id="常见组件">常见组件</h5><h6 id="表格">表格</h6><ul><li>Table 表格：用于展示多条结构类似的数据，可对数据进行排序、筛选、对比或其他自定义操作。</li></ul><h6 id="分页">分页</h6><ul><li>Pagination 分页：当数据量过多时，使用分页分解数据。</li></ul><h6 id="对话框">对话框</h6><ul><li>Dialog 对话框：在保留当前页面状态的情况下，告知用户并承载相关操作。</li></ul><h6 id="表单">表单</h6><ul><li>Form 表单：由输入框、选择器、单选框、多选框等控件组成，用以收集、校验、提交数据。</li></ul><h5 id="案例">案例</h5><p>完成如下页面：</p><img src="/2025/03/02/Basic-Web-Development/%E6%A1%88%E4%BE%8B.png" class=""><p>要求：根据页面原型完成员工管理页面开发，并通过 Axios 完成数据异步加载。</p><p>步骤：</p><ol><li>创建页面，完成页面的整体布局规划</li><li>布局中各个部分的组件实现</li><li>列表数据的异步加载，并渲染展示</li></ol><h4 id="Vue-路由">Vue 路由</h4><ul><li>前端路由：URL 中 #号 与 组件 之间的对应关系</li></ul><img src="/2025/03/02/Basic-Web-Development/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1.png" class=""><h5 id="Vue-Router">Vue Router</h5><ul><li><p>介绍：Vue Router 是 Vue 的官方路由</p></li><li><p>组成：</p><ul><li><code>VueRouter</code>：路由器类，根据路由请求在路由视图中动态渲染选中的组件。其中维护了一份路由表，记录了路由路径和组件的对应关系。</li><li><code>&lt;router-link&gt;</code>：请求链接组件，浏览器会解析成 <code>&lt;a&gt;</code></li><li><code>&lt;router-view&gt;</code>：动态视图组件，用来渲染展示与路由路径对应的组件</li></ul><img src="/2025/03/02/Basic-Web-Development/VueRouter.png" class=""></li></ul><h4 id="打包部署">打包部署</h4><h5 id="打包">打包</h5><p>方式：在项目目录下执行指令：<code>npm run build</code>，之后会在项目目录下生成一个 <code>dist</code> 文件夹，为打包好的文件。</p><h5 id="部署">部署</h5><h6 id="Nginx">Nginx</h6><ul><li><p>介绍：Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件 （IMAP/PO3）代理服务器。其特点是占用内存少，并发能力强，在各大型互联网公司都有非常广泛的使用</p></li><li><p>官网：<a href="Nginx%E5%AE%98%E7%BD%91">https://nginx.org/</a></p></li><li><p>Nginx 目录结构如下：</p><img src="/2025/03/02/Basic-Web-Development/Nginx%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84png" class=""><p>其中：</p><ul><li>conf：配置文件目录</li><li>html：静态资源文件目录</li><li>logs：日志文件目录</li><li>temp：临时文件目录</li></ul></li><li><p>步骤：将打包好的 <code>dist</code> 目录下的文件，复制到 nginx 安装目录的 html 目录下即可</p><blockquote><p>注意事项：Nginx 默认占用 80 端口号，如果 80 端口号被占用，可以在 <code>/conf/nginx.conf</code> 中修改端口号</p></blockquote><blockquote><p>附在 Windows 控制台查看占用端口程序的代码：<code>netstat -ano | findStr port_no</code></p></blockquote></li></ul><hr><h2 id="Web-后端开发">Web 后端开发</h2><h3 id="Maven">Maven</h3><h4 id="什么是-Maven？">什么是 Maven？</h4><ul><li><p>Maven 是 Apache 旗下的一个开源项目，是一款用于管理和构建 Java 项目的工具</p><blockquote><p>Apache 软件基金会，成立于 1999年 7 月，是目前世界上最大的最受欢迎的开源软件基金会，也是一个专门为支持开源项目而生的非盈利组织</p><p>开源项目一览：[<a href="https://www.apache.org/index.html#project-list">https://www.apache.org/index.html#project-list</a>](Apache 开源项目一览)</p></blockquote></li></ul><h4 id="Maven-的作用">Maven 的作用</h4><ol><li><p><strong>依赖管理</strong>：方便快捷地管理项目依赖的资源包（jar包），避免版本冲突问题</p></li><li><p><strong>统一项目结构</strong>：提供标准、统一的项目结构</p><ul><li>main：实际项目资源<ul><li>java：java 源代码目录</li><li>resources：配置文件目录</li></ul></li><li>test：测试项目资源</li><li>pom.xml：项目配置文件</li></ul></li><li><p><strong>项目构建</strong>：标准跨平台（Linux、Window、MacOS）的自动化项目构建方式</p></li></ol><h4 id="Maven-概述">Maven 概述</h4><h5 id="介绍-2">介绍</h5><ul><li><p>Apache Maven 是一个项目管理和构建工具，它基于项目对象模型（POM）的概念，通过一小段描述信息来管理项目的构建</p></li><li><p>作用：</p><ul><li>方便的依赖管理</li><li>统一的目录结构</li><li>标准的项目构建流程</li></ul></li><li><p>官网：[<a href="http://maven.apache.org/">http://maven.apache.org/</a>](Maven 官网)</p></li><li><p>Maven 基本模型如下：<img src="/2025/03/02/Basic-Web-Development/Maven%E6%A8%A1%E5%9E%8B.png" class=""></p><ul><li>仓库：用于存储资源，管理各种 jar 包<ul><li>本地仓库：自己计算机上的一个目录</li><li>中央仓库：由 Maven 团队维护的全球唯一的仓库。仓库地址：[<a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a>](Maven 中央仓库)</li><li>远程仓库（私服）：一般为公司团队搭建的私有仓库。</li><li>查找顺序：先查找本地仓库，如果没有，再从远程仓库（如果有）下载，还未找到再从中央仓库下载至本地仓库。</li></ul></li></ul></li></ul><h5 id="安装">安装</h5><p>安装步骤：</p><ol><li><p>解压下载好的 zip 包</p><p>目录结构如下：</p><ul><li>bin：存放的是可执行文件，负责执行一些项目周期相关的指令（如 <code>mvn</code>）</li><li>config：存放 Maven 的配置文件</li><li>lib：存放 Maven 本身所依赖的 jar 包资源（因为 Maven 基于 Java 开发）</li></ul></li><li><p>配置本地仓库：修改 <code>conf/settings.xml</code> 中的 <code>&lt;localRepository&gt;</code> 为一个指定目录，如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>E:\develop\apache-maven-3.6.1\mvn_repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置阿里云私服：修改 <code>conf/settings.xml</code> 中的 <code>&lt;mirrors&gt;</code> 标签，为其添加如下子标签：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置环境变量：<code>MAVEN_HOME</code> 配置为 Maven 的解压目录，并将其 <code>bin</code> 目录加入 <code>PATH</code> 环境变量</p></li></ol><h4 id="IDEA-集成-Maven">IDEA 集成 Maven</h4><ul><li><p>配置 Maven 环境</p><p>配置当前工程：</p><ul><li>IDEA 中选择 File --&gt; Settings --&gt; Build, Execution, Deployment --&gt; Build Tools --&gt; Maven</li><li>设置 IDEA 使用本地安装的 Maven，并修改配置文件及本地仓库路径</li></ul><p>配置 Maven 环境（全局）：在创建项目页 Customize 栏中的 All Settings 处配置，步骤同上</p></li><li><p>创建 Maven 项目</p><ol><li><p>创建模块，Build system选择 Maven</p></li><li><p>Advanced Settings 里填写模块名称，坐标信息，点击 Create，创建完成</p><blockquote><p>Maven 坐标：</p><ul><li>什么是坐标？<ul><li>Maven 中的坐标是资源的唯一标识，通过该坐标可以唯一定位资源位置</li><li>使用坐标来<strong>定义项目</strong>或引入项目中需要的<strong>依赖</strong></li></ul></li><li>坐标的主要组成<ul><li>groupId：定义当前 Maven 项目隶属组织名称（通常是域名反写，例如：com.yl）</li><li>artifactId：定义当前 Maven 项目名称（通常是模块名称，例如 order-service、goods-service）</li><li>version：定义当前项目版本号</li></ul></li></ul></blockquote></li><li><p>编写 HelloWorld，并运行</p></li></ol></li><li><p>导入 Maven 项目</p><ul><li>方式一：先将待导入项目文件夹复制一份在当前工程目录下，然后选择 IDEA 右侧 Maven 面板，点击 + 号，选中该项目的 pom.xml 文件，双击即可</li><li>方式二：可以在当前工程的 Project Structure 页面 Module 栏中中点击 + 号，选择 Import Module，选择导入项目的 pom.xml 文件即可</li></ul></li></ul><h4 id="依赖管理">依赖管理</h4><h5 id="依赖配置">依赖配置</h5><ul><li><p>依赖：值当前项目运行所需要的 jar 包，一个项目中可以引入多个依赖</p></li><li><p>配置：</p><ol><li>在 pom.xml 文件中编写 <code>&lt;dependencies&gt;</code> 标签</li><li>在 <code>&lt;dependencies&gt;</code> 标签中，使用 <code>&lt;dependency&gt;</code> 引入坐标</li><li>定义坐标的 groupId, artifaceId, version</li><li>点击刷新按钮，引入最新加入的坐标</li></ol><blockquote><p>注意事项：</p><ul><li>如果引入的依赖，在本地仓库不存在，将会连接远程仓库/中央仓库，然后下载依赖</li><li>如果不知道依赖的坐标信息，可以到 [<a href="https://mvnrepository.com/">https://mvnrepository.com/</a> ](Maven 坐标搜索)中搜索</li></ul></blockquote></li></ul><h5 id="依赖传递">依赖传递</h5><ul><li><p>依赖具有传递性</p><ul><li>直接依赖：在当前项目中通过依赖配置建立的依赖关系</li><li>间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源</li></ul><img src="/2025/03/02/Basic-Web-Development/%E4%BE%9D%E8%B5%96%E4%BC%A0%E9%80%92%E5%9B%BE%E7%A4%BA.png" class=""><ul><li>可以在项目的 pom.xml 文件中右键选择 Diagrams，选择 Show  Diagram 就可以看到项目的依赖情况</li></ul></li><li><p>排除依赖：指主动断开依赖的资源，被排除的资源无需指定版本</p><ul><li>图示：<img src="/2025/03/02/Basic-Web-Development/%E6%8E%92%E9%99%A4%E4%BE%9D%E8%B5%96%E5%9B%BE%E7%A4%BA.png" class=""></li></ul></li></ul><h5 id="依赖范围">依赖范围</h5><p>依赖的 jar 包，默认情况下，可以在任何地方使用。可以通过 <code>&lt;scope&gt;...&lt;/scope&gt;</code> 设置其作用范围</p><p>作用范围：</p><ul><li><p>主程序范围有效（main 文件夹范围内）</p></li><li><p>测试程序范围有效（test 文件夹范围内）</p></li><li><p>是否参与打包运行（package 指令范围内）</p><table><thead><tr><th style="text-align:center">scope 值</th><th style="text-align:center">主程序</th><th style="text-align:center">测试程序</th><th style="text-align:center">打包（运行）</th><th style="text-align:center">范例</th></tr></thead><tbody><tr><td style="text-align:center">complie（默认）</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">log4j</td></tr><tr><td style="text-align:center">test</td><td style="text-align:center">-</td><td style="text-align:center">Y</td><td style="text-align:center">-</td><td style="text-align:center">junit</td></tr><tr><td style="text-align:center">provided</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">-</td><td style="text-align:center">servlet-api</td></tr><tr><td style="text-align:center">runtime</td><td style="text-align:center">-</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">jdbc 驱动</td></tr></tbody></table></li></ul><h5 id="生命周期">生命周期</h5><p>Maven 的生命周期就是为了对所有的 Maven 项目<strong>构建过程进行抽象和统一</strong></p><p>Maven 中有 3 套相互独立的生命周期：</p><ul><li>clean：清理工作</li><li>default：核心工作，如：编译、测试、打包、安装、部署等</li><li>site：生成报告、发布站点等</li></ul><p>每套生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段</p><img src="/2025/03/02/Basic-Web-Development/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%98%B6%E6%AE%B5.png" class=""><p>五个重点关注阶段：</p><ul><li><p>clean：一处上一次构建生成的文件</p></li><li><p>compile：编译项目源代码</p></li><li><p>test：使用合适的单元测试框架运行测试（junit）</p></li><li><p>package：将编译后的文件打包，如：jar、war等</p></li><li><p>install：安装项目到本地仓库</p><blockquote><p>注意事项：在<strong>同一套生命周期</strong>中，当运行后面的阶段时，前面的阶段都会运行。</p></blockquote></li></ul><p>如何执行生命周期：</p><ol><li>在 IDEA 中，右侧的 maven 工具栏，选中对应的生命周期，双击执行</li><li>在命令行中，通过命令执行：<code>mvn phase_name</code></li></ol><h3 id="SpringBoot-基础篇">SpringBoot 基础篇</h3><h4 id="Spring">Spring</h4><ul><li>官网：[<a href="http://spring.io">spring.io</a>](Spring 官网)</li><li>Spring 发展到今天已经形成了一种开发生态圈，Spring 提供了若干个子项目，每个项目用于完成特定的功能</li></ul><h4 id="SpringBoot">SpringBoot</h4><p><strong>SpringBoot 可以帮助我们非常快速地构建应用程序、简化开发、提高效率，是为了解决使用底层 Spring 框架构建项目太复杂繁琐而生。</strong></p><h4 id="SpringBoot-Web-入门">SpringBoot Web 入门</h4><p>需求：使用 SpringBoot 开发一个 Web 应用，浏览器发起请求 /hello 后，给浏览器返回字符串 “Hello World~”</p><p>步骤：</p><ol><li>创建 SpringBoot 工程，并勾选 Web 开发相关依赖</li><li>定义 HelloController 类，添加方法 hello，并添加注解</li><li>运行测试</li></ol><h4 id="HTTP-协议">HTTP 协议</h4><h5 id="概述">概述</h5><ul><li>概念：<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，超文本传输协议，规定了浏览器与服务器之间数据传输的规则</li><li>特点：<ol><li>基于 TCP 协议：面向连接，安全</li><li>基于请求 - 响应模型：一次请求对应一次响应</li><li>HTTP 协议是无状态的协议：对于事务处理没有记忆能力。每次请求 - 响应都是独立的<ul><li>缺点：多次请求间不能共享数据</li><li>优点：速度快</li></ul></li></ol></li></ul><h5 id="请求协议">请求协议</h5><p>请求数据格式分为三个部分：</p><ul><li><p>请求行：请求数据的第一行，包括请求方式，资源路径和协议</p></li><li><p>请求头：第二行开始，格式为 <code>key: value</code></p><p>常见的请求头及其含义：</p><table><thead><tr><th style="text-align:center">请求头</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">Host</td><td style="text-align:left">请求的主机名</td></tr><tr><td style="text-align:center">User-agent</td><td style="text-align:left">浏览器版本</td></tr><tr><td style="text-align:center">Accept</td><td style="text-align:left">表示浏览器能接收的资源类型，如 text/*，image/* 或者 */* 表示所有</td></tr><tr><td style="text-align:center">Accept-Language</td><td style="text-align:left">表示浏览器偏好的语言，服务器可以据此返回不同语言的网页</td></tr><tr><td style="text-align:center">Accept-Encoding</td><td style="text-align:left">表示浏览器可以支持的压缩类型，例如 gzip、deflate等</td></tr><tr><td style="text-align:center">Content-Type</td><td style="text-align:left">请求主体的数据类型</td></tr><tr><td style="text-align:center">Content-Length</td><td style="text-align:left">请求主体的大小（单位：字节）</td></tr></tbody></table></li><li><p>请求体：POST 请求特有，与请求行和请求头间隔一个空行，存放请求参数</p></li></ul><blockquote><p>GET：请求参数在请求行中，没有请求体。GET 请求大小有限制</p><p>POST：请求参数在请求体中，POST请求大小没有限制</p></blockquote><h5 id="响应协议">响应协议</h5><p>响应数据格式也分为三个部分：</p><ul><li><p>响应行：响应数据的第一行，包括协议、状态码和描述</p><p>状态码分类：</p><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中：临时状态码</strong>，表示请求已经接收，告诉客户端应该继续请求或者如果它已经完成则忽略它</td></tr><tr><td>2xx</td><td>**成功：**表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td>**重定向：**重定向到其他地方；让客户端再发起一次请求以完成整个处理</td></tr><tr><td>4xx</td><td>**客户端错误：**处理发生错误，责任在客户端。如：请求了不存在的资源、客户端未被授权、禁止访问等</td></tr><tr><td>5xx</td><td>**服务器错误：**处理发生错误，责任在服务端。如：程序抛出异常等</td></tr></tbody></table></li><li><p>响应头：第二行开始，格式key: value</p><p>常见的响应头及其含义：</p><table><thead><tr><th>响应头</th><th>含义</th></tr></thead><tbody><tr><td>Content-Type</td><td>表示该响应内容的类型，例如 text/html, application/json</td></tr><tr><td>Content-Length</td><td>表示该响应内容的长度（字节数）</td></tr><tr><td>Content-Encoding</td><td>表示该响应压缩算法，例如 gzip</td></tr><tr><td>Cache-Control</td><td>指示客户端应如何缓存，例如 max-age=300 表示可以最多缓存 300 秒</td></tr><tr><td>Set-Cookie</td><td>告诉浏览器为当前页面所在的域设置 cookie</td></tr></tbody></table></li><li><p>响应体：最后一部分，与响应行和响应头间隔一个空行，存放响应数据</p></li></ul><h5 id="协议解析">协议解析</h5><p>浏览器内置了解析 http 协议格式数据的程序，以下主要研究服务端如何解析 请求协议和返回 响应协议</p><ul><li>最原始的方法是在 Java 代码中用 socket 拿到网络的输入输出流，通过输入流按照数据格式一行一行读取请求行，请求头和请求体，通过逻辑判断来决定响应数据，最后通过输出流将 响应数据 输出回请求方（按照数据格式）</li><li>由于原始的方法太过繁琐，代码量过大，又因为 http 协议是统一固定的标准，所以有很多已被其他组织写好的软件程序对 http 协议进行了<strong>封装</strong>，使得程序员不必直接对 http 协议进行操作，这些软件程序称为 <strong>Web 服务器</strong>，以下将会介绍最为流行的 Web 服务器 —— Tomcat</li></ul><h4 id="Web-服务器-Tomcat">Web 服务器 - Tomcat</h4><h5 id="Web-服务器">Web 服务器</h5><p>Web 服务器是一个<strong>软件程序</strong>，对 http 协议的操作进行了封装，<strong>简化了 Web 程序开发</strong>，使得程序员不必直接对协议进行操作，让 Web 开发更加便捷。主要功能是 <strong>”提供网上信息浏览服务“</strong></p><h5 id="简介">简介</h5><ul><li>概念：Tomcat 是 Apache 软件基金会的一个核心项目，是一个开源免费的<strong>轻量级</strong> Web 服务器，<strong>支持 Servlet/JSP等少量 JavaEE 规范</strong></li><li>JavaEE：Java Enterprise Edition，Java 企业版。指 Java 企业级开发的技术规范总和。包含 13 项技术规范：JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAF</li><li>Tomcat 也被称为 <strong>Web 容器、Servlet 容器</strong>。Servlet 程序需要依赖于 Tomcat 才能运行</li><li>官网：[<a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a>](Tomcat 官网)</li></ul><h5 id="基本使用">基本使用</h5><ul><li><p>下载：官网下载</p></li><li><p>安装：将压缩包解压到相应目录即为安装完成</p><ul><li><p>解压后目录如下：</p><p>其中：</p><ul><li>bin：存放可执行文件</li><li>conf：存放配置文件<ul><li>其中的 server.xml 文件中可以修改 Tomcat 占用的端口号</li></ul></li><li>lib：存放 Tomcat 依赖的 jar 包</li><li>logs：存放日志文件</li><li>temp：存放临时文件</li><li>webapps：应用发布目录</li><li>work：工作目录</li></ul></li></ul></li><li><p>卸载：直接删除目录即可</p></li><li><p>启动：双击：``bin\startup.bat`</p></li><li><p>关闭：</p><ul><li>直接关掉运行窗口：强制关闭</li><li>双击 <code>bin\shutdown.bat</code>：正常关闭</li><li>Ctrl + C：正常关闭</li></ul></li></ul><blockquote><p>注意事项：HTTP 协议默认端口号为 80，如果将 Tomcat 端口号改为 80，则将来访问 Tomcat 时，不需要输入端口号，直接输入 <code>localhost</code> 或 IP</p></blockquote><ul><li>部署应用：将打包好的 web 应用目录放在 <code>webapps</code> 目录下即可</li></ul><h5 id="入门程序解析">入门程序解析</h5><ul><li>起步依赖：<ul><li>spring-boot-starter-web：包含了 web 应用开发所需要的常见依赖</li><li>spring-boot-starter-test：包含了单元测试所需要的常见依赖</li><li>官方提供的 starter：[<a href="https://docs.spring.io/spring-boot/docs/2.7.4/reference/htmlsingle/#using.build-system.starters">https://docs.spring.io/spring-boot/docs/2.7.4/reference/htmlsingle/#using.build-system.starters</a>](Spring 官方提供的起步依赖一览)</li></ul></li><li>内嵌 Tomcat 服务器<ul><li>基于 SpringBoot 开发的 Web 应用程序，内置了 Tomcat 服务器，当启动类运行时，回自动启动内嵌的 Tomcat 服务器。</li></ul></li></ul><h4 id="请求响应">请求响应</h4><p>SpringBoot 中的请求响应结构图示：</p><img src="/2025/03/02/Basic-Web-Development/%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94.png" class=""><ul><li><p>请求对象（HttpServletRequest）：获取请求数据</p></li><li><p>响应对象（HttpServletResponse）：设置响应数据</p></li><li><p>BS 架构：Browser/Server，浏览器/服务器架构模式。客户端只需要浏览器，应用程序的逻辑和数据都存储在服务端</p></li><li><p>CS 架构：Client/Server，客户端/服务器架构模式</p></li></ul><h5 id="请求">请求</h5><p>主要讲述各类请求参数的结构和封装</p><h6 id="Postman">Postman</h6><ul><li><p>Postman 是一款功能强大的网页调试与发送网页 HTTP 请求的应用</p></li><li><p>作用：常用于进行接口测试</p></li></ul><h6 id="简单参数">简单参数</h6><ul><li><p>原始方式：在原始的 Web 程序中，获取请求参数，需要通过 HttpServletRequest 对象手动获取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">ageStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(ageStr);</span><br><span class="line">    System.out.println(name + <span class="string">&quot;: &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SpringBoot 方式</p><ul><li><p>简单参数：<strong>参数名与形参变量名相同</strong>，<strong>定义形参即可接收参数</strong>（GET 和 POST请求均可用，只要参数名与形参变量名相同即可），会自动进行类型转换，于是上述代码精简为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">    System.out.println(name + <span class="string">&quot;: &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果方法的形参名称与请求参数名称不匹配，可以使用 <code>@RequestParam</code> 完成映射</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(<span class="meta">@RequestParam(name = &quot;name&quot;)</span> String username, Integer age)</span> &#123;</span><br><span class="line">    System.out.println(username + <span class="string">&quot;: &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p><code>@RequestParam</code> 中的 <code>required</code> 属性<strong>默认为</strong> <code>true</code>，代表该请求参数<strong>必须传递</strong>，如果不传递将<strong>报错</strong>。如果该参数是<strong>可选的</strong>，可以将 <code>required</code> 属性设置为 <code>false</code></p></blockquote></li></ul></li></ul><h6 id="实体参数">实体参数</h6><ul><li><p>简单实体对象：<strong>请求参数名与形参对象属性名相同</strong>，定义 POJO 接收即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/simplePojo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simplePojo</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>要确保实体类有合适的<strong>getter和setter方法</strong>。Spring 使用这些方法来绑定请求参数到对象属性上。</p></blockquote></li><li><p>复杂实体对象：<strong>请求参数名与形参对象属性名相同</strong>，按照对象层次结构关系即可接收嵌套 POJO 属性参数，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/complexPojo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">complexPojo</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则对应的请求参数顺序为：<code>name</code>, <code>age</code>, <code>address.province</code>, <code>address.city</code>.</p></li></ul><h6 id="数组集合参数">数组集合参数</h6><ul><li><p>应用场景：用于处理前端复选框组件传递的参数（一般为数组或集合）</p></li><li><p>数组参数：<strong>请求参数名与形参数组名称相同</strong>且请求参数为多个，定义数组类型形参即可接收参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/arrayParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">arrayParam</span><span class="params">(String[] hobby)</span> &#123;</span><br><span class="line">    System.out.println(Arrays.toString(hobby));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>集合参数：<strong>请求参数名与形参集合名称相同</strong>且请求参数为多个，<code>@RequestParam</code> 绑定参数关系（因为默认多个值是封装到数组里的）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestParam(&quot;/listParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">listParam</span><span class="params">(<span class="meta">@ReqeustParam</span> List&lt;String&gt; hobby)</span> &#123;</span><br><span class="line">    System.out.println(hobby);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="日期参数">日期参数</h6><ul><li><p>日期参数：使用 <code>@DateTimeFormat</code> 注解完成日期参数格式转换，<strong>请求参数名与形参名称相同</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/dateParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dateParam</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span> LocalDateTime updateTime)</span> &#123;</span><br><span class="line">    System.out.println(updateTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul><h6 id="Json-参数">Json 参数</h6><ul><li><p>JSON参数：JSON 参数<strong>键名与形参对象属性名相同</strong>，定义 <strong>POJO</strong> 类型形参即可接收参数，需要使用 <code>@RequestBody</code> 标识</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;jsonParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">jsonParam</span><span class="params">(<span class="meta">@RequestBody</span> Client client)</span> &#123;</span><br><span class="line">    System.out.println(client);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Tom&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;province&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shanghai&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="路径参数">路径参数</h6><ul><li><p>路径参数：通过请求 URL 直接传递参数，使用 {…} 来表示该路径参数，需要使用 <code>@PathVariable</code> 获取路径参数，<strong>路径参数名需要与方法形参名相同</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/pathParam/&#123;num&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">pathParam</span><span class="params">(<span class="meta">@PathVariable</span> Integer num)</span> &#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="响应">响应</h5><h6 id="ResponseBody">@ResponseBody</h6><ul><li>类型：方法注解、类注解</li><li>位置：Controller 方法上/类上</li><li>作用：将方法返回值直接响应，如果返回值类型是 <strong>实体对象/集合，将会转换为 JSON 格式响应</strong></li><li>说明：@RestController = @Controller + @ResponseBody</li></ul><h6 id="统一响应结果">统一响应结果</h6><p>图示：</p><img src="/2025/03/02/Basic-Web-Development/%E7%BB%9F%E4%B8%80%E5%93%8D%E5%BA%94%E5%9B%BE%E7%A4%BA.png" class=""><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="comment">// 状态码</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">// 提示信息</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">// 数据</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>温馨提示：SpringBoot 项目的静态资源（html、css、js等前端资源）默认存放目录为：classpath:/static、classpath:/public、classpath:/resources</p></blockquote><h5 id="分层解耦">分层解耦</h5><h6 id="三层架构（基于单一职责原则）">三层架构（基于单一职责原则）</h6><ul><li><p>Controller：控制层。接收前端发送的请求，对请求进行处理，并响应数据。</p></li><li><p>Service：业务逻辑层。处理具体的业务逻辑</p></li><li><p>Dao：数据访问层（Data Access Object）（持久层）。负责数据访问操作，包括数据的增删改查。</p><img src="/2025/03/02/Basic-Web-Development/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.png" class=""></li></ul><h6 id="分层解耦-2">分层解耦</h6><ul><li>内聚：软件中各个功能模块内部的功能联系</li><li>耦合：衡量软件中各个层/模块之间的依赖、关联的程度</li><li>软件设计原则：高内聚低耦合</li><li>控制反转：<strong>I</strong>nversion <strong>O</strong>f <strong>C</strong>ontrol，简称 <strong>IOC</strong>。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转</li><li>依赖注入：<strong>D</strong>ependency <strong>I</strong>njection，简称 <strong>DI</strong>。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入</li><li>Bean 对象：IOC 容器中创建、管理的对象，称之为 <strong>Bean</strong></li><li>分层解耦就是基于 IOC 和 DI 来实现的</li></ul><h6 id="IOC-DI-入门">IOC &amp; DI 入门</h6><p>步骤：</p><ol><li><p>将需要解耦的实现类，交给 IOC 容器来管理</p><p>在类上加入注解：<code>@Component</code></p></li><li><p>在耦合的代码部分，进行依赖注入</p><p>在代码部分上方，加上注解 <code>@Autowired</code></p></li><li><p>运行测试</p></li></ol><h6 id="IOC详解">IOC详解</h6><ul><li><p>Bean 的声明</p><p>要把某个对象交给 IOC 容器管理，需要在对应的类上加上如下注解之一：</p><table><thead><tr><th>注解</th><th>说明</th><th>位置</th></tr></thead><tbody><tr><td>@Component</td><td>声明 bean 的基础注解</td><td>不属于以下三类时，用此注解，例如：工具类</td></tr><tr><td>@Controller</td><td>@Component 的衍生注解</td><td>标注在控制器类上</td></tr><tr><td>@Service</td><td>@Component 的衍生注解</td><td>标注在业务类上</td></tr><tr><td>@Repository</td><td>@Component 的衍生注解</td><td>标注在数据访问类上（由于与mabatis整合，用的少）</td></tr></tbody></table><blockquote><p>注意事项：</p><ul><li>声明 bean 的时候，可以给每个 bean 取名字，具体做法是在以上四个注解后加上 <code>(value = &quot;beanName&quot;)</code></li><li>使用以上四个注解都可以声明 bean，但是在 SpringBoot 集成 Web 开发中，声明控制器 bean 只能用 @Controller</li></ul></blockquote></li><li><p>Bean 组件扫描</p><ul><li>前面声明 bean  的四大注解要想生效，还需要被组件扫描注解 <code>@ComponentScan</code> 扫描</li><li><code>@ComponentScan</code> 注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解 <code>@SpringBootApplication</code> 中，默认扫描范围是启动类所在包及其子包</li></ul></li></ul><h6 id="DI详解">DI详解</h6><ul><li>@Autowired 注解，默认是按照<strong>类型</strong>进行，如果存在多个相同类型的 bean，则会报错，程序无法启动，可通过以下几种方案来解决：<ul><li>@Primary：在想要生效的 bean 上加上该注解即可</li><li>@Qualifier：在 <code>@Autowired</code> 下加上该注解并在该注解后加上 <code>(&quot;beanName&quot;)</code> 即可选择你想要生效的 bean</li><li>@Resource：不用 <code>@Autowired</code> 而改用 <code>@Resource(name = &quot;beanName&quot;)</code> 来指定你想要生效的 bean</li></ul></li></ul><h3 id="MySQL">MySQL</h3><h4 id="数据库设计">数据库设计</h4><h5 id="MySQL概述">MySQL概述</h5><p>登录语法：</p><p><code>mysql -uusername -ppassword [-hip] [-pport]</code></p><h5 id="DDL">DDL</h5><p>基于页面原型和需求文档来设计表结构</p><img src="/2025/03/02/Basic-Web-Development/%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" class=""><h4 id="数据库操作">数据库操作</h4><h5 id="DML">DML</h5><h5 id="DQL">DQL</h5><h5 id="多表设计">多表设计</h5><ul><li>一对多</li><li>多对多</li><li>一对一</li><li>根据页面原型和需求文档分析多张表之间的关系，以及每张表中有哪些字段。</li></ul><h4 id="数据库优化">数据库优化</h4><h5 id="索引">索引</h5><h6 id="介绍-3">介绍</h6><ul><li>索引（index）是帮助数据库<strong>高效获取数据</strong>的<strong>数据结构</strong></li><li>优缺点：<ul><li>优点：<ul><li>提高数据查询效率，降低数据库 IO 成本</li><li>通过索引列对数据进行排序，降低数据排序成本，降低 CPU 消耗</li></ul></li><li>缺点：<ul><li>索引会占用存储空间</li><li>索引大大提高了查询效率，同时却降低了插入、更新和删除的效率</li></ul></li></ul></li></ul><h6 id="结构">结构</h6><p>MySQL 数据库支持的索引结构有很多，如：</p><ul><li>Hash 索引</li><li>B+Tree 索引</li><li>Full-Text 索引</li></ul><p>我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。</p><ul><li><p>B+Tree（多路平衡搜索树）</p><img src="/2025/03/02/Basic-Web-Development/B+Tree.png" class=""><ul><li>每一个节点，可以存储多个 key（有 n 个 key，就有 n 个指针）</li><li>所有的数据都存储在叶子节点，非叶子节点仅用于索引数据</li><li>叶子节点形成了一条双向链表，便于数据的排序及区间范围查询</li></ul></li></ul><h6 id="语法">语法</h6><ul><li><p>创建索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] INDEX 索引名 <span class="keyword">ON</span> 表名(字段名, ...);</span><br></pre></td></tr></table></figure></li><li><p>查看索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></li><li><p>删除索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX 索引名 <span class="keyword">ON</span> 表名;</span><br></pre></td></tr></table></figure></li></ul><blockquote><ul><li><p>主键字段，在建表时，会自动创建主键索引</p></li><li><p>添加唯一约束时，数据库实际上会添加唯一索引</p></li></ul></blockquote><h3 id="SpringBoot-Mybatis">SpringBoot Mybatis</h3><h4 id="什么是-MyBatis？">什么是 MyBatis？</h4><ul><li>MyBatis 是一款优秀的<strong>持久层</strong>框架，用于简化 JDBC 的开发</li><li>MyBatis 本是 Apache 的一个开源项目 iBatis，2010 年这个项目由 Apache 迁移到了 google code，并且改名为 MyBatis。2013 年 11 月 迁移到 Github</li><li>官网：[<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a>](MyBatis 官网)</li></ul><h4 id="MyBatis-入门">MyBatis 入门</h4><h5 id="快速入门-2">快速入门</h5><p>步骤：</p><ol><li>准备工作（创建 SpringBoot 工程、数据库表 user、实体类 User）</li><li>引入 MyBatis 的相关依赖，配置 MyBatis（数据库连接信息）</li><li>编写 SQL 语句（注解/XML）</li></ol><p>配置 SQL 提示</p><ul><li>产生原因：IDEA 和数据库没有建立连接，不识别表信息</li><li>解决方式：在 IDEA 中配置 MySQL 连接</li></ul><h5 id="JDBC-介绍">JDBC 介绍</h5><ul><li><p>JDBC：<strong>J</strong>ava <strong>D</strong>ata<strong>B</strong>ase <strong>C</strong>onnectivity，就是使用 JAVA 语言操作关系型数据库的一套 API（规范，只有接口，无实现类）</p><img src="/2025/03/02/Basic-Web-Development/JDBC.png" class=""><blockquote><p>JAVA 程序操作数据库流程图示</p></blockquote></li><li><p>本质：</p><ul><li>sun 公司官方定义的一套操作所有关系型数据库的规范，即接口</li><li>各个数据库厂商去实现这套接口，提供数据库驱动jar包</li><li>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类</li></ul></li><li><p>原始 JDBC 操作数据库程序</p><img src="/2025/03/02/Basic-Web-Development/%E5%8E%9F%E5%A7%8BJDBC%E7%A8%8B%E5%BA%8F.png" class=""><p>问题：</p><ul><li>注册驱动的驱动包名和获取连接的 url、用户名和密码变动频繁，原始程序是硬编码的方式，在更改后需要重新编译打包部署，维护成本高</li><li>解析封装返回数据的代码量大，操作繁琐</li><li>频繁地进行数据库资源的连接和释放，造成资源浪费和性能降低</li></ul></li><li><p>MyBatis 实现的优点</p><ul><li>驱动报名和获取连接的信息写在 application.properties 文件中，不在 JAVA 程序中，变更无需重新编译程序</li><li>解析封装返回数据由框架代为执行，不需要手动编写代码</li><li>数据库连接对象都放在数据库连接池之中，使用时取出，用完后退还，不会频繁地获取和释放连接对象，避免了资源的浪费</li></ul></li></ul><h5 id="数据库连接池">数据库连接池</h5><p>介绍：</p><ul><li><strong>数据库连接池</strong>是一个<strong>容器</strong>，负责<strong>分配、管理</strong>数据库连接对象（Connection）</li><li>它允许应用程序<strong>重复使用</strong>一个现有的数据库连接对象，而不是再重新建立一个</li><li><strong>释放空闲时间超过最大空闲时间的连接</strong>，来避免因为没有释放连接而引起的客户端连接遗漏（有客户端获取不到连接）</li></ul><p>标准接口：DataSource</p><ul><li><p>官方（sun）提供的数据库连接池接口，由第三方组织实现此接口</p></li><li><p>功能：获取连接</p></li><li><p>核心方法：<code>Connection getConnection() throws SQLException;</code></p></li><li><p>常见产品：</p><ul><li><p>C3P0</p></li><li><p>DBCP</p></li><li><p>Druid（阿里巴巴开源的数据库连接池项目，是 JAVA 语言最好的数据库连接池之一）</p><ul><li><p>依赖配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>application.properties 内容照旧</p></li><li><p>官方文档：[<a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a>](Druid 官方文档)</p></li></ul></li><li><p>Hikari（SpringBoot 默认）</p></li></ul></li></ul><h5 id="lombok">lombok</h5><ul><li><p>lombok 是一个使用的 JAVA 类库，能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString 等方法，并可以自动化生成日志变量，简化 JAVA 开发，提高效率</p></li><li><p>lombok 常用注解：</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>@Getter/@Setter</td><td>为所有的属性提供 getter/setter 方法</td></tr><tr><td>@ToString</td><td>会给类自动生成易于阅读的 toString 方法</td></tr><tr><td>@EqualsAndHashCode</td><td>根据类所拥有的非静态字段自动重写 equals 方法和 hashCode 方法</td></tr><tr><td><strong>@Data</strong></td><td>提供了综合的生成代码功能（@Getter + @Setter + @ToString + @EqualsAndHashCode）</td></tr><tr><td><strong>@NoArgsConstructor</strong></td><td>为实体类生成无参的构造器方法</td></tr><tr><td><strong>@AllArgsConstructor</strong></td><td>为实体类生成除了 static 修饰的字段之外带有各参数的构造器方法</td></tr></tbody></table></li><li><p>依赖引入：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="MyBatis-基础增删改查">MyBatis 基础增删改查</h4><h5 id="准备">准备</h5><ul><li>准备数据库表 emp</li><li>创建一个 SpringBoot 工程，选择引入对应的起步依赖（lombok, mybatis, mysql driver）</li><li>application.properties 中引入数据库连接信息</li><li>准备对应的实体类 Emp（实体类属性采用驼峰命名）</li><li>准备 Mapper 接口 EmpMapper</li></ul><h5 id="删除">删除</h5><ul><li><p>根据主键删除</p></li><li><p>SQL 语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">17</span>;</span><br></pre></td></tr></table></figure></li><li><p>接口方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Delete(&quot;DELETE FROM emp WHERE id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li><code>#&#123;&#125;</code> 为 MyBatis 的变量占位符，可以拿到方法接收的参数</li><li><code>@Delete</code> 注解拥有返回值：该 SQL 操作影响的行的数量，要拿到该返回值，只需将方法声明为 int 返回类型即可，方法执行后会返回该值。</li></ol></li></ul><blockquote><p>注意事项：如果 mapper 接口方法形参只有一个普通类型的参数，#{…} 里面的属性名可以随便写，如 #{id}、#{value}，但建议保持一致</p></blockquote><blockquote><p>日志输出：可以在 application.properties 中，打开 mybatis 的日志，并指定输出到控制台</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>预编译 SQL：</p><img src="/2025/03/02/Basic-Web-Development/%E9%A2%84%E7%BC%96%E8%AF%91SQL.png" class=""><p>优势:</p><ul><li><p>性能更高</p><img src="/2025/03/02/Basic-Web-Development/%E9%A2%84%E7%BC%96%E8%AF%91SQL%E6%80%A7%E8%83%BD%E6%9B%B4%E9%AB%98.png" class=""></li><li><p>更安全（防止SQL注入）</p><ul><li>SQL 注入是通过操作输入的数据来修改事先定义好的 SQL 语句，以达到执行代码对服务器进行攻击的方法。</li></ul></li></ul></blockquote><blockquote><p>参数占位符</p><ul><li>#{…}<ul><li>执行 SQL 时，会将 #{…} 替换为 ?，生成预编译 SQL，会自动设置参数值</li><li>使用时机：<strong>参数传递</strong>，都是用 #{…}</li></ul></li><li>${…}<ul><li>拼接 SQL。直接将参数拼接在 SQL 语句中，存在 SQL 注入问题</li><li>使用时机：如果对表名、列表进行动态设置时使用</li></ul></li></ul></blockquote><h5 id="插入">插入</h5><h6 id="接口方法：">接口方法：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot;INSERT INTO emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time)&quot; +</span></span><br><span class="line"><span class="meta">            &quot;values(#&#123;username&#125; , #&#123;name&#125;, #&#123;gender&#125;, #&#123;image&#125;, #&#123;job&#125;, #&#123;entryDate&#125;, #&#123;deptId&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125; )&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Emp emp)</span>;</span><br></pre></td></tr></table></figure><p>使用实体类将传递参数封装起来，并在 #{}内写这个实体类的属性</p><h6 id="主键返回">主键返回</h6><ul><li><p>描述：在数据添加成功后，需要获取插入数据库数据的主键。如添加套餐数据时，还需要维护套餐菜品关系表数据</p></li><li><p>实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Options(keyProperty = &quot;id&quot;, useGeneratedKeys = true)</span> <span class="comment">// 会自动将生成的主键值，赋值给emp对象的id属性</span></span><br><span class="line"><span class="meta">@Insert(&quot;INSERT INTO emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time)&quot; +</span></span><br><span class="line"><span class="meta">            &quot;values(#&#123;username&#125; , #&#123;name&#125;, #&#123;gender&#125;, #&#123;image&#125;, #&#123;job&#125;, #&#123;entryDate&#125;, #&#123;deptId&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125; )&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Emp emp)</span>;</span><br></pre></td></tr></table></figure></li></ul><h5 id="更新">更新</h5><h6 id="接口方法：-2">接口方法：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Update(&quot;UPDATE emp SET username = #&#123;username&#125;, name = #&#123;name&#125;, gender = #&#123;gender&#125;, image = #&#123;image&#125;, job = #&#123;job&#125;, entrydate = #&#123;entryDate&#125;, dept_id = #&#123;deptId&#125;, update_time = #&#123;updateTime&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Emp emp)</span>;</span><br></pre></td></tr></table></figure><h5 id="查询">查询</h5><h6 id="根据-ID-查询">根据 ID 查询</h6><p>接口方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM emp WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>数据封装</p><ul><li><p>实体类属性名 和 数据库表查询返回的字段名一致，MyBatis 会自动封装</p></li><li><p>如果字段名不一致，则不能自动封装</p></li><li><p>解决方案：</p><ol><li><p>给字段起别名，让别名与实体类属性名一致</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT id, username, password, name, gander, image, job, entrydate entryDate, dept_id deptId, create_time createTime, update_time updateTime FROM emp WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure></li><li><p>通过 @Results, @Result 注解手动映射封装</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;entrydate&quot;, property = &quot;entryDate&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;dept_id&quot;, property = &quot;deptId&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;update_time&quot;, property = &quot;updateTime&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM emp WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>开启 MyBatis 的驼峰命名自动映射开关，可以实现 a_column --------&gt; aColumn。在 application.properties 中 输入</strong></p><p><code>mybatis.configuration.map-underscore-to-camel-case=true</code></p></li></ol></li></ul></blockquote><h6 id="条件查询">条件查询</h6><p>接口方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM emp WHERE name LIKE concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;) AND gender = #&#123;gender&#125; AND entrydate BETWEEN #&#123;begin&#125; AND #&#123;end&#125; ORDER BY update_time DESC&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">list</span><span class="params">(String name, Short gender, LocalDate begin, LocalDate end)</span>;</span><br></pre></td></tr></table></figure><h4 id="XML-映射文件">XML 映射文件</h4><h5 id="规范">规范</h5><ul><li><p>XML 映射文件的名称与 Mapper 接口名称一致，并且将 XML 映射文件和 Mapper 接口放置在相同包下（同包同名）</p></li><li><p>XML 映射文件的 namespace 属性与 Mapper 接口全限定名一致</p></li><li><p>XML 映射文件中 SQL 语句的 id 与 Mapper 接口中的方法名一致，并保持返回类型一致</p></li><li><p>文件结构：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.yl.mapper.EmpMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    resultType 指单条记录所封装的类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.yl.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">        // SQL 语句</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>原则：使用 MyBatis 的注解，主要是来完成一些简单的增删改查功能。如果需要实现复杂的 SQL 功能，建议使用 XML 来配置映射语句</p></blockquote><h4 id="MyBatis-动态-SQL">MyBatis 动态 SQL</h4><p><strong>动态 SQL：随着用户的输入或外部条件的变化而变化的 SQL 语句，我们称为动态 SQL</strong></p><h5 id="if"><code>&lt;if&gt;</code></h5><ul><li><p>用户判断条件是否成立。使用 test 属性进行条件判断，如果条件为 true，则拼接 SQL；否则不。</p></li><li><p><strong>test 属性中的 and、or必须小写！！！</strong></p></li><li><p>示例1：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.yl.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">        SELECT *</span><br><span class="line">        FROM emp</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">                name LIKE concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">                AND gender = #&#123;gender&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null and end != null&quot;</span>&gt;</span></span><br><span class="line">                AND entrydate BETWEEN #&#123;begin&#125; AND #&#123;end&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        ORDER BY update_time DESC</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>&lt;where&gt;</code> 标签可以</p><ol><li>动态生成 WHERE 子句（有条件成立则生成，否则不生产）</li><li>自动去除掉条件前面多余的 and 和 or</li></ol></blockquote></li><li><p>示例2：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span> = <span class="string">&quot;update2&quot;</span>&gt;</span></span><br><span class="line">UPDATE emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span> = <span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">            username = #&#123;username&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span> = <span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">            name = #&#123;name&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span> = <span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">            gender = #&#123;gender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>&lt;set&gt;</code> 标签可以</p><ol><li>动态地在行首插入 SET 关键字，机制同 <code>&lt;where&gt;</code></li><li>自动去除掉额外的逗号</li></ol></blockquote></li></ul><p><code>&lt;foreach&gt;</code></p><p>要完成这个 SQL 语句的实现：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> id <span class="keyword">in</span>(<span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>实现如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span> = <span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">DELETE FROM emp WHERE id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span> = <span class="string">&quot;ids&quot;</span> <span class="attr">item</span> = <span class="string">&quot;id&quot;</span> <span class="attr">separator</span> = <span class="string">&quot;,&quot;</span> <span class="attr">open</span> = <span class="string">&quot;(&quot;</span> <span class="attr">close</span> = <span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">    #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>属性解释：</p><ul><li>collection：要遍历的集合</li><li>item：遍历出的元素的名字（自定）</li><li>separator：分隔符</li><li>open：遍历开始前拼接的 SQL 片段</li><li>close：遍历结束后拼接的 SQL 片段</li></ul></blockquote><h5 id="sql-include"><code>&lt;sql&gt;&lt;include&gt;</code></h5><ul><li><p><code>&lt;sql&gt;</code>：用来定义可重用的 SQL 片段</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;yourName&quot;</span>&gt;</span></span><br><span class="line">    // sql</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;include&gt;</code>：通过属性 refid，指定引用的 sql 片段</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> place <span class="keyword">to</span> reuse the <span class="keyword">sql</span></span><br><span class="line"><span class="operator">&lt;</span>include refid<span class="operator">=</span>&quot;yourName&quot; <span class="operator">/</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="SpringBoot-Web-开发篇">SpringBoot Web 开发篇</h3><h4 id="文件上传">文件上传</h4><h5 id="简介-2">简介</h5><ul><li>文件上传，是指将本地图片、视频、音频等文件上传到服务器，供其他用户浏览或下载的过程</li><li>文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能</li><li>前端页面文件上传三要素：<ul><li>form 表单元素中：<code>method=&quot;post&quot;</code>, <code>enctype=&quot;multipart/form-data&quot;</code></li><li>input 元素中：<code>type=&quot;file&quot;</code></li><li>图示：<img src="/2025/03/02/Basic-Web-Development/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%B8%89%E8%A6%81%E7%B4%A0.png" class=""></li><li>使用 Spring 框架提供的类 <code>MultipartFile</code> 来接收上传的文件</li></ul></li></ul><h5 id="本地存储">本地存储</h5><p>在服务端，接收到上传上来的文件之后，将文件存储在本地服务器磁盘中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">upload</span><span class="params">(String username, Integer age, MultipartFile image)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;文件上传：&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, username, age, image);</span><br><span class="line">    <span class="comment">// 获取原始文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">    <span class="comment">// 构造唯一文件名——加入 uuid（通用唯一识别码）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> originalFilename.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">extname</span> <span class="operator">=</span> originalFilename.substring(index);</span><br><span class="line">    <span class="type">String</span> <span class="variable">newFileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + extname;</span><br><span class="line">    log.info(<span class="string">&quot;新的文件名：&#123;&#125;&quot;</span>, newFileName);</span><br><span class="line">    <span class="comment">// 将文件保存到本地</span></span><br><span class="line">    image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\code\\Java Web\\tlias\\image\\&quot;</span> + newFileName));</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 SpringBoot 中，文件上传，默认单个文件允许最大大小为 1MB。如果需要上传大文件，可以进行如下配置</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置单个文件最大上传大小</span></span><br><span class="line"><span class="attr">spring.servlet.multipart.max-file-size</span>=<span class="string">10MB</span></span><br><span class="line"><span class="comment"># 配置单个请求最大上传大小（一次请求可以上传多个文件）</span></span><br><span class="line"><span class="attr">spring.servlet.multipart.max-request-size</span>=<span class="string">100MB</span></span><br></pre></td></tr></table></figure><p>本地存储的问题：</p><ol><li>前端无法访问服务端保存的文件</li><li>服务器磁盘容量有限，扩容困难</li><li>服务器磁盘损坏后，造成的损失大</li></ol><blockquote><p><code>MultipartFile</code> 类的常用方法：</p><ul><li>String getOriginalFilename(); // 获取原始文件名</li><li>void transferTo(File dest); // 将接收的文件转存到磁盘中</li><li>long getSize(); // 获取文件的大小，单位：字节</li><li>byte[] getBytes(); // 获取文件内容的字节数组</li><li>InputStream getInputStream(); // 获取接收到的文件内容的输入流</li></ul></blockquote><h5 id="阿里云-OSS">阿里云 OSS</h5><h6 id="介绍-4">介绍</h6><p><strong>阿里云</strong>：阿里云是阿里巴巴集团旗下全球领先的云计算公司，也是国内最大的<strong>云服务提供商</strong></p><p><strong>云服务</strong>：通过互联网向外界提供的各种服务</p><p><strong>阿里云对象存储OSS（Object Storage Service）</strong>：是一款海量、安全、低成本、高可靠的云存储服务。使用 OSS，可以<strong>通过网络</strong>随时<strong>存储和调用</strong>包括文本、图片、音频和视频等在内的<strong>各种文件</strong>。</p><h6 id="使用第三方服务的通用思路">使用第三方服务的通用思路</h6><ol><li><p>准备工作：账号注册、实名认证、后台基本配置等</p></li><li><p>参照官方 SDK 编写入门程序</p><blockquote><p>SDK：<strong>S</strong>oftware <strong>D</strong>evelopment <strong>K</strong>it 的缩写，<strong>软件开发工具包</strong>，包括辅助软件开发的依赖（jar包）、代码示例等，都可以叫做 SDK</p></blockquote></li><li><p>项目中集成该服务并使用</p></li></ol><h6 id="阿里云-OSS-使用步骤">阿里云 OSS 使用步骤</h6><ol><li><p>注册阿里云（实名认证）</p></li><li><p>充值</p></li><li><p>开通对象存储服务（OSS）</p></li><li><p>创建 bucket</p><blockquote><p>bucket 是阿里云 OSS 中的存储空间，是用户用于存储对象（Object，就是文件）的容器，所有的对象都必须隶属于某个存储空间</p></blockquote></li><li><p>获取 AccessKey（密钥）</p></li><li><p>参照官方 SDK 编写入门程序</p></li><li><p>项目集成 OSS</p></li></ol><h6 id="集成">集成</h6><p>步骤：</p><ol><li><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.15.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引入阿里云 OSS 上传文件工具类（由官方的示例代码改造而来）</p></li><li><p>上传图片接口开发</p></li></ol><h4 id="配置文件">配置文件</h4><h5 id="参数配置化">参数配置化</h5><p>问题：如果在一些类中定义所需要的参数（如OSS的密钥和bucket），会导致不变维护和管理</p><p>问题解决：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># OSS 参数配置</span></span><br><span class="line"><span class="attr">aliyun.oss.endpoint</span>=<span class="string">https://oss-cn-hangzhou.aliyuncs.com</span></span><br><span class="line"><span class="attr">aliyun.oss.accessKeyId</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">aliyun.oss.accessKeySecret</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">aliyun.oss.bucketName</span>=<span class="string">java-web-learn3</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;aliyun.oss.endpoint&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String endpoint;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;aliyun.oss.accessKeyId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String accessKeyId;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;aliyun.oss.accessKeySecret&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String accessKeySecret;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;aliyun.oss.bucketName&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String bucketName;</span><br></pre></td></tr></table></figure><blockquote><p>@Value(Spring提供) 注解通常用于外部配置的属性注入，具体用法为：@Value(“${配置文件中的key}”)</p></blockquote><h5 id="yml-配置文件">yml 配置文件</h5><h6 id="常见配置文件格式对比">常见配置文件格式对比</h6><ul><li>XML：臃肿</li><li>properties：层级结构不清晰</li><li>yml/yaml：简洁、数据为中心（推荐）</li></ul><h6 id="yml-基本语法">yml 基本语法</h6><ul><li>大小写敏感</li><li><strong>数值前边必须有空格</strong>作为分隔符</li><li>使用缩进表示层级关系，<strong>缩进时，不允许使用 Tab 键</strong>，只能用空格（idea 会自动将 Tab 转换为空格）</li><li><strong>缩进的空格数目不重要</strong>，只要相同层级的元素左侧<strong>对齐</strong>即可</li><li># 表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul><h6 id="yml-数据格式">yml 数据格式</h6><ul><li><p>对象/Map集合</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">user:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure></li><li><p>数组/List/Set集合：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hobby:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">java</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">game</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sport</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="ConfigurationProperties">@ConfigurationProperties</h5><p><strong>想法</strong>：想要配置文件中的配置参数自动注入到相应对象的属性，而不需要每个属性都加上 @Value 注解</p><p><strong>实现</strong>：</p><ul><li><p>Spring 提供了方法以实现以上操作，步骤：</p><ol><li><p>配置文件的 key 名称与实体类的属性名一致，并且提供对应的 getter/setter 方法</p></li><li><p>将该实体类交给 IOC 容器管理</p></li><li><p>配置文件的 key 名称前面的部分用 @ConfigurationProperties 注解来指定。如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span></span><br></pre></td></tr></table></figure></li></ol><p>配置好的实体类示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>配置文件提示：</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>@ConfigurationProperties 与 @Value</strong></p><ul><li>相同点：都是用来注入外部配置的属性的</li><li>不同点：<ul><li>@Value 注解只能一个一个地进行外部属性的注入</li><li>@ConfigurationProperties 注解可以批量地将外部属性注入到 bean 对象的属性中</li></ul></li></ul><h4 id="登录认证">登录认证</h4><h5 id="登录功能">登录功能</h5><p>查询数据库中对应用户名和密码的用户，返回 Emp 对象，如果不为空，则登录成功；为空，则登录失败</p><h5 id="登录校验">登录校验</h5><p>**问题：**在未登录的情况下，直接输入 url 就可以不登陆而访问部门管理、员工管理等功能</p><p><strong>实现蓝图：</strong></p><img src="/2025/03/02/Basic-Web-Development/%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C.png" class=""><h6 id="会话技术">会话技术</h6><ul><li><p><strong>会话</strong>：用户打开浏览器，访问 web 服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含<strong>多次</strong>请求和响应。</p></li><li><p><strong>会话跟踪：<strong>一种维护浏览器</strong>状态</strong>的方法，服务器需要<strong>识别</strong>多次请求是否来自于<strong>同一浏览器</strong>，以便在同一次会话的多次请求间<strong>共享数据</strong></p></li><li><p>会话跟踪方案：</p><ul><li><p>客户端会话跟踪技术：Cookie</p><ul><li>图示：</li></ul><img src="/2025/03/02/Basic-Web-Development/cookie%E4%BC%A0%E9%80%92%E6%B5%81%E7%A8%8B.png" class=""><ul><li><p>优点：HTTP 协议中支持的技术</p></li><li><p>缺点：</p><ul><li><p>移动端 APP 无法使用 Cookie</p></li><li><p>不安全，并且用户可以自己禁用 Cookie</p></li><li><p>Cookie 不能跨域</p></li></ul><blockquote><img src="/2025/03/02/Basic-Web-Development/Cookie%E4%B8%8D%E8%83%BD%E8%B7%A8%E5%9F%9F.png" class=""><ul><li><p>跨域区分三个维度：协议、IP/域名、端口，任何一个不同将导致跨域</p></li><li><p>Cookie 不能跨域，简单来说，就是浏览器目前访问的 ip + 端口的 Cookie 不能被其他 ip + 端口设置</p></li></ul></blockquote></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置Cookie</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/c1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">cookie1</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置 Cookie（响应Cookie），cookie名为login_username，值为yl</span></span><br><span class="line">    response.addCookie(<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;login_username&quot;</span>, <span class="string">&quot;yl&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Cookie</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;c2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">cookie2</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取所有的Cookie</span></span><br><span class="line">    Cookie[] cookies = request.getCookies();</span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie: cookies) &#123;</span><br><span class="line">    <span class="comment">// 输出name为login_username的cookie</span></span><br><span class="line">        <span class="keyword">if</span> (cookie.getName().equals(<span class="string">&quot;login_username&quot;</span>)) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;login_username&quot;</span> + cookie.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>服务端会话跟踪技术：Session</p><ul><li><p>与 Cookie 方案类似，Session 是基于 Cookie 实现的，区别在于存储方在服务端，而不是客户端浏览器</p></li><li><p>优点：</p><ul><li>存储在服务端，安全</li></ul></li><li><p>缺点：</p><ul><li>服务器集群环境下无法直接使用 Session</li><li>Cookie 的缺点</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 往 HttpSession 中存储数据</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/s1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">session1</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 往 Session 中存储数据</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;loginUser&quot;</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 HttpSession 中获取数据</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/s2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">session2</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">    <span class="comment">// 从 Session 中获取数据</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">loginUser</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;loginUser&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.success(loginUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>令牌技术（主流方案）</p><ul><li><p>优点：支持 PC 端、移动端</p><ul><li>解决了集群环境下的认证问题</li><li>减轻了服务器端存储压力（不需要存 Session）</li></ul></li><li><p>缺点：</p><ul><li>需要自己实现</li></ul></li></ul></li></ul></li></ul><h6 id="JWT-令牌">JWT 令牌</h6><p><strong>简介</strong></p><ul><li><p>全称：<strong>J</strong>SON <strong>W</strong>eb <strong>T</strong>oken（<a href="https://jwt.io/%EF%BC%89">https://jwt.io/）</a></p></li><li><p>定义了一种<strong>简洁的</strong>、<strong>自包含的</strong>格式，用于在通信双方以 json 数据格式安全地传输信息。由于数字签名的存在，这些信息是可靠的。</p></li><li><p>组成：</p><ul><li><p>第一部分：Header（头），记录令牌类型、签名算法等。例如 <code>&#123;&quot;alg&quot;: &quot;Hs256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125;</code></p></li><li><p>第二部分：Payload（有效载荷），携带一些自定义信息、默认信息等。例如 <code>&#123;&quot;id&quot;: &quot;1&quot;, &quot;username&quot;: &quot;Tom&quot;&#125;</code></p></li><li><p>第三部分：Signature（签名），防止 Token 被篡改、确保安全性。将 Header、Payload 部分内容融入，并加入指定密钥，通过指定签名算法计算而来。</p></li><li><p>图示：</p><img src="/2025/03/02/Basic-Web-Development/jwt%E4%BB%A4%E7%89%8C%E5%9B%BE%E7%A4%BA.png" class=""><blockquote><p>Base64：是一种基于 64 个可打印字符（A-Z a-z 0-9 + /）来表示二进制数据的编码方式</p></blockquote></li></ul></li></ul><p><strong>场景</strong>：登录认证</p><ol><li>登录成功后，<strong>生成令牌</strong></li><li>将令牌发放给前端和浏览器，浏览器在后续发送请求时都会携带 JWT 令牌到服务端以校验身份</li><li>服务端会在每次请求前先<strong>校验令牌</strong>，通过后，再处理请求</li></ol><p><strong>令牌生成和校验</strong></p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>生成 JWT 令牌</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getJwt</span><span class="params">()</span> &#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    claims.put(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    claims.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">secretString</span> <span class="operator">=</span> <span class="string">&quot;yl&quot;</span>; <span class="comment">// 原始签名密钥</span></span><br><span class="line">    <span class="type">byte</span>[] secretBytes = Base64.getEncoder().encode(secretString.getBytes()); <span class="comment">// 将原始签名密钥编码为 Base64编码以满足生成需要</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">        .signWith(SignatureAlgorithm.HS256, secretBytes) <span class="comment">// 设置签名算法和签名密钥</span></span><br><span class="line">        .setClaims(claims) <span class="comment">// 自定义内容</span></span><br><span class="line">        .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">3600</span> * <span class="number">1000</span>)) <span class="comment">// 设置 JWT 令牌有限期为一小时</span></span><br><span class="line">        .compact();</span><br><span class="line">    System.out.println(jwt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>校验并解析 JWT 令牌</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseJwt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()          </span><br><span class="line">        .setSigningKey(Base64.getEncoder().encode(<span class="string">&quot;yl&quot;</span>.getBytes())) <span class="comment">// 设置签名密钥，需与生成时一致</span></span><br><span class="line">        .parseClaimsJws(<span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoiVG9tIiwiaWQiOjEsImV4cCI6MTcwODkzNzU0Mn0.-_402mawcQ0HxFvxPMm8DfJC_XcK8btNmLwJYvwAn3w&quot;</span>) <span class="comment">// 传递 JWT 令牌，校验</span></span><br><span class="line">        .getBody(); <span class="comment">// 获取令牌自定义内容</span></span><br><span class="line">    System.out.println(claims);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意事项</p><ul><li>JWT 校验时所使用的签名密钥，必须和生成 JWT 令牌时使用的密钥是配套的</li><li>如果 JWT 令牌解析校验时报错，则说明 JWT 令牌被篡改 或 失效了，令牌非法</li></ul></blockquote><p><strong>登录-生成令牌</strong></p><ul><li>引入 JWT 令牌操作工具类</li><li>登录完成后，调用工具类生成 JWT 令牌，并返回</li></ul><h6 id="过滤器-Filter">过滤器 Filter</h6><p><strong>概述</strong></p><ul><li>概念：Filter 过滤器，是 JavaWeb 三大组件之一（Servlet、Filter、Listener）之一</li><li>过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能</li><li>过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理、敏感字符处理等</li></ul><p><strong>快速入门</strong></p><p>步骤：</p><ol><li>定义 Filter：定义一个类，<strong>实现 Filter 接口</strong>，<strong>并重写其所有方法</strong>（可以只重写 doFilter 方法）</li><li>配置 Filter：<strong>Filter 类加上</strong> <strong>@WebFilte</strong>r 注解，配置拦截资源的<strong>路径</strong>。<strong>引导类加上 @ServletComponentScan</strong> 开启 Servlet 组件支持</li></ol><p><strong>详解</strong></p><ul><li><p>执行流程</p><ul><li><strong>拦截到请求之后</strong>，会自动<strong>调用 doFilter 方法</strong>，在放行前，会<strong>执行放行代码之前的逻辑</strong>，放行时<strong>执行对应的访问操作</strong>，对应操作执行完毕后，还会返回来<strong>执行放行代码之后的逻辑</strong>。此为整个执行流程</li></ul></li><li><p>拦截路径</p><ul><li><p>Filter 可以根据需求，配置不同的拦截资源路径：</p><table><thead><tr><th>拦截路径</th><th>urlPatterns值</th><th>含义</th></tr></thead><tbody><tr><td>拦截具体路径</td><td>/login</td><td>只有访问 /login 路径时，才会被拦截</td></tr><tr><td>目录拦截</td><td>/emps/*</td><td>访问 /emps 下的所有资源，都会被拦截</td></tr><tr><td>拦截所有</td><td>/*</td><td>访问所有资源，都会被拦截</td></tr></tbody></table></li></ul></li><li><p>过滤器链</p><ul><li>介绍：一个 Web 应用中，可以配置多个过滤器，这多个过滤器就形成了一个过滤器链（类似栈）</li><li>图示：<img src="/2025/03/02/Basic-Web-Development/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE.png" class=""></li><li>顺序：注解配置的 Filter，顺序是按照过滤器类名（字符串）的自然排序</li></ul></li></ul><p><strong>登录校验-Filter</strong></p><p>流程：<img src="/2025/03/02/Basic-Web-Development/Filter%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.png" class=""></p><h6 id="拦截器-Interceptor">拦截器 Interceptor</h6><p><strong>简介&amp;快速入门</strong></p><ul><li><p>概述</p><ul><li>概念：Interceptor 是一种动态<strong>拦截方法调用</strong>的机制，类似于过滤器。Spring 框架中提供的，用来<strong>动态拦截控制器</strong>方法的执行。</li><li>作用：拦截请求，在指定的方法调用后，根据业务需要执行<strong>预先设定</strong>的代码</li></ul></li><li><p>步骤</p><ol><li><p>定义拦截器，<strong>实现 HandlerInterceptor 接口</strong>，并<strong>重写其所有方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">// 目标资源方法执行前执行，放行则返回 true，不放行则返回 false</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目标资源方法执行后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 视图渲染完毕后执行，最后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>注册拦截器</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginInterceptor loginInterceptor;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(loginInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><p><strong>详解</strong></p><ul><li><p>拦截路径</p><ul><li><p>拦截器可以根据需求，配置不同的拦截路径：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    registry.addInterceptor(loginInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>).excludePathPatterns(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addPathPatterns</code> 可以配置需要拦截哪些资源</p><p><code>excludePathPatterns</code> 可以配置不需要拦截哪些资源</p><table><thead><tr><th>拦截路径</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>/*</td><td>一级路径</td><td>只能匹配类别 /login，<strong>不能匹配 /depts/1</strong></td></tr><tr><td>/**</td><td>任意级路径</td><td>任意匹配</td></tr><tr><td>/depts/*</td><td>/depts 下的一级路径</td><td>可匹配 /depts/1，<strong>不能匹配 /depts/1/2 和 /depts</strong></td></tr><tr><td>/depts/**</td><td>/depts 下的任意级路径</td><td>能匹配 /depts 和其下任何路径，<strong>不能匹配 /emps 和其下任何路径</strong></td></tr></tbody></table></li></ul></li><li><p>执行流程</p><ul><li>图示：<img src="/2025/03/02/Basic-Web-Development/%E6%8B%A6%E6%88%AA%E5%99%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" class=""></li><li>浏览器请求会<strong>先被 Tomcat 服务器中的过滤器拦截</strong>，过滤器放行的请求会转交给 <strong>Spring 中的 DispatcherServlet</strong>，然后<strong>被拦截器拦截</strong>，<strong>拦截器放行的请求才到达 controller 执行操作</strong>，然后再<strong>依次返回</strong>。</li></ul></li></ul><blockquote><p>Filter 与 Interceptor 比较</p><ul><li>接口规范不同：过滤器需要实现 Filter 接口，而拦截器需要实现 HandlerInterceptor 接口</li><li>拦截范围不同：过滤器 Filter 会拦截所有的资源，而 Interceptor 只会拦截 Spring 环境中的资源</li></ul></blockquote><p><strong>登录校验-Interceptor</strong></p><p>只需要将 Filter 中的代码照搬即可</p><h5 id="异常处理">异常处理</h5><p>出现异常（如添加数据时数据库数据重复，添加失败），如何处理？</p><ul><li>**方案一：**在 Controller 的方法中进行 try…catch 处理（代码臃肿，不推荐）</li><li>**方案二：**全局异常处理器（简单、优雅、推荐）</li></ul><p>全局异常处理器图示：</p><img src="/2025/03/02/Basic-Web-Development/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8.png" class=""><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">ex</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;对不起，操作失败，请联系管理员&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@RestControllerAdvice = @ControllerAdvice + @ResponseBody</p></blockquote><h4 id="事务管理">事务管理</h4><h5 id="事务回顾">事务回顾</h5><ul><li>概念：<strong>事务</strong> 是一组操作的集合，它是一个不可分割的<strong>工作单位</strong>，这些操作 <strong>要么同时成功，要么同时失效</strong></li><li>操作：<ul><li>开启事务：<code>start transaction / begin;</code></li><li>提交事务：<code>commit;</code></li><li>回滚事务：<code>rollback;</code></li></ul></li></ul><h5 id="Spring-事务管理">Spring 事务管理</h5><p>案例：解散部门：删除部门，同时删除该部门下的员工</p><h6 id="注解-Transactional">注解 @Transactional</h6><ul><li><p>位置：业务（service）层的方法上（当前方法交给 Spring 事务管理）、类上（当前类所有方法交给 Spring 事务管理）、接口上（当前接口下的所有实现类的所有方法交给 Spring 事务管理）</p></li><li><p>作用：将当前方法交给 Spring 进行事务管理，方法执行前，开启事务；成功执行完毕，提交事务；出现异常，回滚事务</p></li><li><p>开启 Spring 事务管理日志</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org.springframework.jdbc.support.JdbcTransactionManager:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="事务进阶">事务进阶</h5><p>@Transactional 注解有两个属性：</p><ul><li><p>rollbackFor：默认情况下，只有出现 <strong>RuntimeException</strong> 才回滚异常。rollbackFor 属性用于<strong>控制</strong>出现何种异常类型时，回滚事务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transaction(rollbackFor = Exception.class)</span></span><br></pre></td></tr></table></figure><p>上面这条语句使得事务在执行时出现任何异常时都回滚</p></li><li><p>propagation：控制事务的传播行为</p><blockquote><p>事务传播行为：指的就是当一个事务方法被另一个事务方法调用时，这个被调用的事务方法应该如何进行事务控制</p><p>常见事务传播行为：</p><table><thead><tr><th>属性值</th><th>含义</th></tr></thead><tbody><tr><td><strong>REQUIRED</strong></td><td>【默认值】需要事务，有则加入（共用一个事务，任何一方抛异常都会导致两方的操作都无法完成），无则创建新事务</td></tr><tr><td><strong>REQUIRED_NEW</strong></td><td>需要新事务，无论有无，总是创建新事物（两方事务不会互相影响）</td></tr><tr><td>SUPPORTS</td><td>支持事务，有则加入，无则在无事务状态中运行</td></tr><tr><td>NOT_SUPPORTED</td><td>不支持事务，在无事务状态下运行，如果当前存在已有事务，则挂起当前事务</td></tr><tr><td>MANDATORY</td><td>必须有事务，否则抛异常</td></tr><tr><td>NEVER</td><td>必须没事务，否则抛异常</td></tr><tr><td>…</td><td>…</td></tr></tbody></table></blockquote></li></ul><h4 id="AOP">AOP</h4><h5 id="AOP-基础">AOP 基础</h5><h6 id="AOP-概述">AOP 概述</h6><ul><li>AOP：<strong>A</strong>spect <strong>O</strong>riented <strong>P</strong>rogramming（<strong>面向切面编程</strong>），其实就是面向特定方法编程</li><li>实现：<strong>动态代理</strong>是面向切面编程最主流的实现。而 SpringAOP 是 Spring 框架的高级技术，目的是在管理 bean 对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程</li></ul><h6 id="AOP-快速入门">AOP 快速入门</h6><ul><li><p>案例：统计各个业务层方法的执行耗时</p></li><li><p>步骤：</p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写 AOP 程序：针对于特定方法根据业务需要进行编程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 前一个 * 表示返回值任意，后面的一串指定要将切面应用于哪些方法，(..)表示方法的参数任意</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.yl.service.*.*(..))&quot;)</span> <span class="comment">// 切入点表达式</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">recordTime</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 获取开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 调用原始方法运行，返回值 rtn 是原始方法的返回值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">rtn</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">        <span class="comment">// 获取结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.info(proceedingJoinPoint.getSignature() + <span class="string">&quot;执行耗时：&#123;&#125;ms&quot;</span>, end - begin);</span><br><span class="line">        <span class="keyword">return</span> rtn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>场景：</p><ul><li>记录操作日志</li><li>权限控制</li><li>事务管理（底层就是通过 AOP 来完成的）</li><li>…</li></ul></li><li><p>优势：</p><ul><li>代码无侵入</li><li>减少重复代码</li><li>提高开发效率</li><li>维护方便</li></ul></li></ul><h6 id="AOP-核心概念">AOP 核心概念</h6><ul><li>**连接点：JointPoint，**指可以被 AOP 控制的方法（暗含方法执行时的相关信息）</li><li>**通知：Advice，**指那些被抽取出来的重复的逻辑，也就是共性功能（最终体现为一个方法）</li><li>**切入点：PointCut，**匹配连接点的条件，通知仅会在切入点方法执行时被应用（用切入点表达式来描述）</li><li>**切面：Aspect，**描述通知与切入点的对应关系（通知 + 切入点）</li><li>**目标对象：Target，**通知所应用的对象</li><li>执行流程：<ul><li>AOP 会动态代理目标对象，生成增强之后的代理对象实例，并将此实例进行依赖注入</li><li>当执行到对应方法时，执行的是代理对象实例的增强方法，而不是原方法</li></ul></li></ul><h5 id="AOP-进阶">AOP 进阶</h5><h6 id="通知类型">通知类型</h6><table><thead><tr><th>通知类型</th><th>功能</th></tr></thead><tbody><tr><td><strong>@Around</strong></td><td>环绕通知，此注解标注的通知方法在目标<strong>方法前、后都被执行</strong></td></tr><tr><td><strong>@Before</strong></td><td>前置通知，此注解标注的通知方法在目标<strong>方法前被执行</strong></td></tr><tr><td><strong>@After</strong></td><td>后置通知，此注解标注的通知方法在目标<strong>方法后被执行</strong>，<strong>无论是否有异常都会执行</strong></td></tr><tr><td><strong>@AfterReturning</strong></td><td>返回后通知，此注解标注的通知方法在目标<strong>方法后被执行</strong>，<strong>有异常不会执行</strong></td></tr><tr><td><strong>@AfterThrowing</strong></td><td>异常后通知，此注解标注的通知方法<strong>发生异常后执行</strong></td></tr></tbody></table><blockquote><p>注意事项：</p><ul><li>@Around 环绕通知需要自己调用 <code>ProceedingJointPoint.proceed()</code> 来让原始方法执行，其他通知不需要考虑目标方法执行</li><li>@Around 环绕通知方法的返回值，必须指定为 Object，来接收原始方法的返回值并返回</li></ul></blockquote><p>避免重复，抽取切入点表达式，进行复用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽取切入点表达式</span></span><br><span class="line"><span class="meta">@PointCut(&quot;execution(* com.yl.service.*.*(..))&quot;)</span></span><br><span class="line"><span class="comment">// 访问修饰符可以限定此切入点表达式的被引用范围，规则同访问修饰符的规则</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用切入点表达式</span></span><br><span class="line"><span class="meta">@Around(&quot;pt()&quot;)</span></span><br></pre></td></tr></table></figure><h6 id="通知顺序">通知顺序</h6><p>当有<strong>多个切面类的切入点</strong>都匹配到了目标方法，目标方法运行时，<strong>多个通知方法都会被执行</strong></p><ol><li>不同切面类中，默认按照切面类的<strong>类名字母排序</strong>：<ul><li>目标方法前的通知方法：字母排名靠前的<strong>先</strong>执行</li><li>目标方法后的通知方法：字母排名靠前的<strong>后</strong>执行</li></ul></li><li><strong>用 @Order(数字) 加在切面类上来控制顺序</strong><ul><li>目标方法<strong>前</strong>的通知方法：数字<strong>小的先</strong>执行</li><li>目标方法<strong>后</strong>的通知方法：数字<strong>大的先</strong>执行</li></ul></li></ol><p>当<strong>一个切面类的中的多个通知方法</strong>匹配到了目标方法时，通知方法执行顺序：</p><ol><li>未抛异常情况：环绕前置 -&gt; @Before -&gt; 目标方法执行 -&gt; @AfterReturning -&gt; @After -&gt; 环绕返回 -&gt; 环绕最终</li><li>抛异常情况：环绕前置 -&gt; @Before -&gt; 目标方法执行 -&gt; @AfterThrowing -&gt; @After -&gt; 环绕异常 -&gt; 环绕最终</li></ol><h6 id="切入点表达式">切入点表达式</h6><ul><li><p>切入点表达式：描述切入点方法的一种表达式</p></li><li><p>作用：主要用来决定项目中的哪些方法需要加入通知</p></li><li><p>常见形式</p><ul><li><p><code>execution(...)</code>：根据<strong>方法签名</strong>来匹配</p><ul><li><p>主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配，<strong>语法</strong>为：</p><p><code>execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数类型全类名) throws 异常?)</code></p><ul><li>其中带 ? 的标识可以省略的部分<ul><li>访问修饰符：可省略</li><li>包名.类名：可省略，但不建议</li><li>throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常）</li></ul></li></ul></li><li><p>可以使用<strong>通配符</strong>描述切入点</p><ul><li>*：单个独立的任意符号，可以通配任意返回值、包名、类型、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分</li><li>…：多个连续的任意符号，可以通配任意层级的包、或任意类型、任意个数的参数</li></ul></li><li><p>组合切入点表达式</p><ul><li><p>可以使用 &amp;&amp;、||、! 来组合比较复杂的切入点表达式，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有满足发送  或者  接收  这个切面都会切进去</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;logSender() || logReceiver()&quot;)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>书写建议：</p><ul><li>所有业务<strong>方法名</strong>在命名时尽量<strong>规范</strong>，方便切入点表达式快速匹配。如：查询类方法都是 find 开头，更新类方法都是 update 开头</li><li>描述切入点方法通常<strong>基于接口描述</strong>，而不是直接描述实现类，<strong>增强拓展性</strong></li><li>在满足业务需要的前提下，<strong>尽量缩小切入点的匹配范围</strong>。如：包名尽量不使用…，使用 * 匹配单个包</li></ul></li></ul></li><li><p><code>@Annotation(...)</code>：根据注解匹配</p><ul><li><p>@Annotation 切入点表达式，用于匹配标识有特定注解的方法，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@annotation(com.yl.anno.Log)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;@annotation(com.yl.anno.Log)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h6 id="连接点">连接点</h6><ul><li><p>在 Spring 中用 <code>JointPoint</code> 抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等</p><blockquote><ul><li>对于 <code>@Around</code> 通知，获取连接点信息只能使用 <code>ProceedingJointPoint</code></li><li>对于其他四种通知，获取连接点信息只能使用 <code>JointPoint</code>，它是 <code>ProceedingJointPoint</code> 的父类型</li></ul></blockquote></li><li><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td><code>getTarget().getClass().getName()</code></td><td>获取目标对象的全类名</td></tr><tr><td><code>getSignature().getName()</code></td><td>获取目标方法的方法名</td></tr><tr><td><code>getArgs()</code></td><td>获取目标方法的参数</td></tr><tr><td><code>proceed()</code></td><td>执行目标方法</td></tr></tbody></table></li></ul><h5 id="AOP-案例">AOP 案例</h5><p>案例：将项目中 <strong>增删改</strong> 相关接口的操作日志记录到数据库表中</p><p>日志信息包括：操作人、操作时间、执行方法的全类名、执行方法名、方法运行时参数、返回值、方法执行时长</p><p>步骤：</p><ol><li>准备：<ol><li>引入 AOP 起步依赖</li><li>创建好数据库表结构，准备好日志实体类</li></ol></li><li>编码<ol><li>自定义注解 @Log</li><li>定义切面类，完成记录操作日志的逻辑</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperateLogAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OperateLogMapper logMapper;</span><br><span class="line">    <span class="comment">// 拿到http请求，以获取请求头中的jwt令牌</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(com.yl.annotation.OperateLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">recordOperateLog</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 用户id，通过获取jwt令牌中存储的用户信息来获得</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtils.parseJWT(jwt);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">operateUser</span> <span class="operator">=</span> (Integer) claims.get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="comment">// 操作时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">operateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="comment">// 类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getName();</span><br><span class="line">        <span class="comment">// 方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        <span class="comment">// 方法参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodParams</span> <span class="operator">=</span> Arrays.toString(joinPoint.getArgs());</span><br><span class="line">        <span class="comment">// 记录方法耗时</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">rtn</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 方法返回值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">returnValue</span> <span class="operator">=</span> JSONObject.toJSONString(rtn);</span><br><span class="line">        <span class="comment">// 计算方法耗时</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">costTime</span> <span class="operator">=</span> end - begin;</span><br><span class="line">        <span class="comment">// id主键自增，不用赋值，直接给 null</span></span><br><span class="line">        <span class="type">OperateLog</span> <span class="variable">operateLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OperateLog</span>(<span class="literal">null</span>, operateUser, operateTime, className, methodName, methodParams, returnValue, costTime);</span><br><span class="line">        logMapper.insert(operateLog);</span><br><span class="line">        log.info(<span class="string">&quot;AOP 记录的操作日志：&#123;&#125;&quot;</span>, operateLog);</span><br><span class="line">        <span class="keyword">return</span> rtn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBoot-Web-进阶篇（原理篇）">SpringBoot Web 进阶篇（原理篇）</h3><h4 id="配置优先级">配置优先级</h4><ul><li><p>SpringBoot 中支持三种格式的配置文件：</p><ul><li>.properties</li><li>.yml</li><li>.yaml</li><li>三种配置文件优先级：properties &gt; yml &gt; yaml</li></ul></li><li><p>SpringBoot 除了支持配置文件属性配置，还支持 <strong>Java 系统属性</strong> 和 <strong>命令行参数</strong> 的方式进行属性配置</p><ul><li><p>Java 系统属性</p><p><code>-Dserver.port=9000</code></p></li><li><p>命令行参数</p><p><code>--server.port:10010</code></p></li><li><p>优先级：命令行参数 &gt; Java 系统属性</p></li><li><p>在打包后添加这两个参数的方法：</p><ol><li><p>执行 maven 打包指令 package</p></li><li><p>执行 java 指令，运行 jar 包</p><p><code>java -Dserver.port=9000 -jar tlias-web-management-0.0.1-SNAPSHOT.jar --server.port=10010</code></p></li></ol></li></ul></li><li><p>总优先级（高 -&gt; 低）：</p><ul><li>命令行参数</li><li>Java 系统属性</li><li>properties</li><li>yml</li><li>yaml</li></ul></li></ul><h4 id="Bean-管理">Bean 管理</h4><h5 id="获取-bean">获取 bean</h5><ul><li><p>默认情况下，Spring 项目启动时，会把 bean 都创建好放在 IOC 容器中，如果想要主动获取这些 bean，可以通过如下方式：</p><ul><li><p>先获取 IOC 容器对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApplicationContext applicationContext;</span><br></pre></td></tr></table></figure></li><li><p>再调用下列方法来获取 bean</p></li><li><p>根据 name 获取 bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">getBean</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure></li><li><p>根据类型获取 bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span></span><br></pre></td></tr></table></figure></li><li><p>根据 name 获取 bean（带类型转换）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>上述【Spring 项目启动时，会把 bean 都创建好放在 IOC 容器中】还会收到作用域及延迟初始化影响，这里主要针对 默认的<strong>单例非延迟加载</strong>的 bean 而言</p></blockquote><h5 id="bean-作用域">bean 作用域</h5><ul><li><p>Spring 支持五种作用域，后三种在 Web 环境才生效</p><table><thead><tr><th>作用域</th><th>说明</th></tr></thead><tbody><tr><td><strong>singleton</strong></td><td>IOC 容器内相同名称的 bean 只有一个实例（单例）（默认）</td></tr><tr><td><strong>prototype</strong></td><td>每次使用该 bean 时会创建新的实例（非单例）</td></tr><tr><td>request</td><td>每个请求范围内会创建新的实例（Web 环境中，了解）</td></tr><tr><td>session</td><td>每个会话范围内会创建新的实例（Web 环境中，了解）</td></tr><tr><td>application</td><td>每个应用范围内会创建新的实例（Web 环境中，了解）</td></tr></tbody></table></li><li><p>可以通过 @Scope 注解来配置作用域，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br></pre></td></tr></table></figure></li><li><p>如果想要在<strong>第一次使用 bean 时才创建实例</strong>，可以在 bean 上添加注解 <code>@Lazy</code></p></li></ul><blockquote><p>注意事项：</p><ul><li>默认 singleton 的 bean，在容器启动时被创建，可以使用 @Lazy 注解来延迟初始化</li><li>prototype 的 bean，每一次使用该 bean 的时候都会创建一个新的实例</li><li>实际开发当中，绝大部分的 bean 是单例的，也就是说绝大部分的 bean 不需要配置 Scope 属性</li></ul></blockquote><h5 id="第三方-bean">第三方 bean</h5><ul><li><p>第三方的类无法通过直接在类上加注解的形式来声明为 bean，如果要将第三方的类交给 IOC 容器管理成为项目中的 bean，就需要用到 <strong>@Bean</strong> 注解，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不建议在启动类中声明第三方bean</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootWebConfig2Application</span> &#123;</span><br><span class="line">    <span class="comment">// Spring会自动执行该方法，并将方法返回值交给IOC容器管理，成为IOC容器的bean对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SAXReader <span class="title function_">saxReader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建议单独开一个类来集中声明第三方bean</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 可以通过@Bean的name或value属性来指定bean的名称，默认为方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SAXReader <span class="title function_">saxReader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意事项：</p><ul><li>通过 @Bean 注解的 name 或 value 属性可以设置 bean 的名称，默认名称为方法名</li><li>如果第三方 bean 需要依赖其他 bean 对象，直接在 bean 定义方法中设置形参即可，IOC 容器会根据类型自动装配</li></ul></blockquote><h4 id="SpringBoot-原理">SpringBoot 原理</h4><h5 id="起步依赖">起步依赖</h5><p>为什么 SpringBoot 项目只需要引入一个起步依赖就可以使用诸多功能了？</p><p>原理&amp;解答：Maven 的<strong>依赖传递</strong></p><h5 id="自动配置">自动配置</h5><h6 id="什么是自动配置">什么是自动配置</h6><ul><li>SpringBoot 的自动配置就是当 Spring 容器启动后，一些配置类、bean 对象就自动存入到了 IOC 容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作</li></ul><h6 id="自动配置原理">自动配置原理</h6><p><strong>@SpringBootApplication</strong></p><ul><li><p>该注解标识在 SpringBoot 工程引导类上，是 SpringBoot 中<strong>最最最</strong>重要的注解。该注解由三个部分组成</p><ul><li><p>@SpringBootcConfiguration：该注解与 @Configuration 注解作用相同，用来声明当前类也是一个配置类</p></li><li><p>@ComponentScan：组件扫描，默认扫描当前引导类所在包及其子包</p></li><li><p>@EnableAutoConfiguration：SpringBoot 实现自动化配置的核心注解</p><ul><li><p>该注解中封装了 @Import 注解，此注解制定了一个 InportSelector 接口的实现类，该实现类实现了 InportSelector 接口的方法 selectImports，该方法返回一个 String类型的数组，数组封装了要导入到 IOC 容器的全部的配置类的全类名</p></li><li><p>selectImports 方法中加载了文件：</p><p><code>META/INF/spring/org.springframework.boot.autoconfiguration.AutoConfiguration.imports</code></p></li><li><p>这个文件中就包含了所有要导入到 IOC 容器的配置类的全类名</p></li><li><p>导入到 IOC 容器的配置类中配置了该项目的所有 bean，所以导入该配置类就可以导入所有的 bean</p></li></ul></li></ul></li></ul><p><strong>@Conditional</strong></p><ul><li>作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的 bean 对象到 IOC 容器中</li><li>位置：方法、类</li><li>@Conditional 本身是一个父注解，派生出大量的子注解，如：<ul><li>@ConditionalOnClass：判断环境中是否有对应字节码文件，有才注册 bean 到 IOC 容器</li><li>@ConditionalOnMissingBean：判断环境中是否没有对应的 bean（类型或名称），没有才注册 bean 到 IOC 容器</li><li>@ConditionalOnProperty：判断配置文件中是否有对应的属性和值，有才注册 bean 到 IOC 容器</li></ul></li></ul><h5 id="自定义-starter">自定义 starter</h5><p><strong>需求</strong></p><ul><li>需求：自定义 aliyun-oss-spring-boot-starter，完成阿里云 OSS 操作工具类 AliyunOssUtils 的自动配置</li><li>目标：引入起步依赖之后，要想使用阿里云OSS，直接注入 AliyunOssUtils 直接使用即可</li></ul><p><strong>步骤</strong></p><ol><li>创建 <code>aliyun-oss-spring-boot-starter</code> 模块</li><li>创建 <code>aliyun-oss-spring-boot-autoconfigure</code> 模块，在 <code>starter</code> 中引入该模块</li><li>在 <code>aliyun-oss-spring-boot-autoconfigure</code> 模块中自定义自动配置功能，并定义自动配置文件 <code>META-INF/spring/xxx.imports</code></li></ol><h3 id="Maven-高级">Maven 高级</h3><h4 id="分模块设计与开发">分模块设计与开发</h4><p>当开发中大型项目时，如果把所有的代码都写在一个模块中，则代码会难以维护且不便复用，为了解决这些问题，Maven 中引入了分模块设计与开发的思想</p><img src="/2025/03/02/Basic-Web-Development/%E5%88%86%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1.png" class=""><p>将项目按照功能拆分成若干个子模块，方便项目的管理维护、扩展，也方便模块间的相互调用、资源共享</p><p>现在，我们来对 Tlias 案例进行模块拆分</p><ol><li>创建 maven 模块 tlias-pojo，存放实体类</li><li>创建 maven 模块 tlias-utils，存放相关工具类</li></ol><blockquote><p>注意：分模块开发需要先针对模块功能进行设计，再进行编码，不会先将工程开发完毕，然后进行拆分</p></blockquote><p>几点注意事项：</p><ol><li>创建模块选择 <code>New Module</code>，然后选择 Maven 作为构建工具</li><li>在高级设置中填写自己的 <code>GroupId</code></li><li>多个模块最好放在同一工程文件夹中</li><li>复制相应的代码到新模块中，并把需要的依赖配置在 <code>pom.xml</code> 文件中</li><li>最后在主模块的 <code>pom.xml</code> 文件中引入这些分模块即可</li></ol><h4 id="继承与聚合">继承与聚合</h4><h5 id="继承">继承</h5><h6 id="继承关系">继承关系</h6><ul><li>概念：继承描述的是两个工程间的关系，与 Java 中的继承相似，子工程可以继承父工程中的配置信息，<strong>常见于依赖关系的继承</strong>，即可以把通用的依赖写在父工程中，然后子工程直接继承</li><li>作用：<strong>简化依赖配置、统一管理依赖</strong></li><li>实现：在子工程的 <code>pom.xml</code> 文件中用 <code>&lt;parent&gt;...&lt;/parent&gt;</code> 标签来指定父工程的坐标</li></ul><p>现在，我们下面就创建一个父工程，把我们目前三个模块中所有的共同依赖放到父工程中，有以下几个步骤：</p><ol><li><p>创建 maven 模块 tlias-parent，该工程为<strong>父工程</strong>，<strong>设置打包方式为 pom</strong>（默认为 jar）</p><blockquote><p>maven 中的三种打包方式：</p><ul><li>jar：普通模块打包，springboot 项目基本都是 jar 包（内嵌 tomcat 运行）</li><li>war：普通 web 程序打包，需要部署在外部的 tomcat 服务器中运行</li><li>pom：父工程或聚合工程，该模块不写代码，仅进行依赖管理</li></ul><p>设置方法如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tlias-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p>由于 maven 项目只能有一个父工程，而我们的 <code>tlias-web-management</code> 项目已经继承了 springboot 项目的父工程，所以为了实现我们的需求，我们将继承关系更改为如下（采用级联继承）：</p><img src="/2025/03/02/Basic-Web-Development/maven%E7%BB%A7%E6%89%BF.png" class=""></li><li><p>在子工程的 <code>pom.xml</code> 文件中，配置继承关系，如</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tlias-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--在该标签中指定父工程pom文件的相对路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../tlias-parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在父工程中配置各个子工程共有的依赖</p></li></ol><blockquote><p>若父工程和子工程都配置了同一个依赖的不同版本，以子工程的为准</p></blockquote><h6 id="版本锁定">版本锁定</h6><p>版本锁定用于统一管理项目中各个模块的各个依赖的版本，如我们想控制各个子工程的 jwt 依赖的版本为 0.9.1，则可以这样做：</p><ol><li><p>在父工程的 pom 文件中通过 <code>&lt;dependencyManagement&gt;</code> 标签来统一管理版本</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在子工程中引入该依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>此时，子工程引入依赖就不需要再指定版本号，版本号由父工程统一管理。要变更依赖版本，只需在父工程中统一变更。</p><p>此时，各个依赖的版本号还是零散地分布在 <code>&lt;dependencyManagement&gt;</code>，为了解决这一问题，我们可以使用 <em>自定义属性/引用属性</em>，如</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.18.24<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jjwt.version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">jjwt.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在版本控制和引入依赖时使用自定义属性：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jjwt.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="聚合">聚合</h5><p>分模块开发完毕后，如果要对主模块打包，需要把主模块依赖的全部分模块和它的父模块都安装到 maven 本地仓库中（使用 maven 声明周期的 install 命令），十分繁琐且枯燥，因此，为了解决这个问题，就引入了 maven 的聚合功能。</p><ul><li><p>聚合：将多个模块组织成一个整体，同时进行项目的构建，可以实现一键打包，一键安装等操作</p></li><li><p>要实现聚合功能，需要提供一个<strong>聚合工程</strong>——一个不具有业务功能的 ”空“ 工程，有且仅有一个 pom 文件，一般由 <strong>父工程</strong> 来充当聚合工程的角色</p></li><li><p>作用：快速构建项目（无需根据依赖关系手动构建，直接在聚合工程上构建即可）</p></li><li><p>实现：只要在聚合工程的 pom 文件中用 <code>modules</code> 标签设置当前聚合工程所包含的子模块的名称即可，如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>tlias-pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>tlias-utils<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>tlias-web-management<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>maven 会自动根据模块间的依赖关系来设置构建顺序，与聚合工程中模块的配置书写位置无关</p><p>配置聚合工程后，只需要对聚合工程实行 maven 声明周期指令就可以对其下的所有子工程实行相同的 maven 指令</p></blockquote></li></ul><p>小结：继承与聚合的异同</p><img src="/2025/03/02/Basic-Web-Development/%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%81%9A%E5%90%88%E7%9A%84%E5%BC%82%E5%90%8C.png" class=""><h4 id="私服">私服</h4><h5 id="介绍-5">介绍</h5><p>私服是一种<strong>特殊的远程仓库</strong>，它是架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部<strong>资源共享与资源同步</strong>问题。</p><img src="/2025/03/02/Basic-Web-Development/%E7%A7%81%E6%9C%8D.png" class=""><p>依赖查找顺序：</p><ol><li>本地仓库</li><li>私服</li><li>中央仓库</li></ol><h5 id="资源上传与下载">资源上传与下载</h5><img src="/2025/03/02/Basic-Web-Development/%E7%A7%81%E6%9C%8D%E8%B5%84%E6%BA%90%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD.png" class=""><p>项目版本：</p><ul><li>RELEASE（发行版本）：功能趋于稳定，当前停止更新，可用于发行的版本，存储在私服的 RELEASE 仓库中。</li><li>SNAPSHOT（快照版本）：功能不稳定，尚处于开发中的版本，即快照版本，存储在私服的 SNAPSHOT 仓库中。</li></ul><p>步骤：</p><ol><li><p>设置私服的访问用户名/密码（<code>settings.xml</code> 中的 <code>servers</code> 中配置），如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-snapshot<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 IDEA 的 maven 工程的 pom 文件中配置上传（发布）地址，如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置releases仓库的地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--id需要与server中配置的id一致，用于对应用户名和密码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-releases<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置snapshots仓库的地址--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>设置从私服下载依赖的对应仓库组的地址（<code>settings.xml</code> 中的 <code>mirrors</code>、<code>profiles</code> 中配置），如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--如果配置过阿里云的地址，需要删除掉，mirror标签只能有一对--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>allow-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启可以下载快照版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定下载的仓库组位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定id，url以及允许下载releases仓库和snapshots仓库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>配置好后，执行 maven 生命周期的 deploy 指令就可以将工程上传到私服</p><blockquote><p>如果工程的版本号末尾带 <code>SNAPSHOT</code>，则会上传到快照仓库，其他的一律上传到发布仓库</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Web Development Projects </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web Development </tag>
            
            <tag> Vue </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Learning Road Map</title>
      <link href="/2025/03/02/Java-Learning-Road-Map/"/>
      <url>/2025/03/02/Java-Learning-Road-Map/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="Java学习路径.pdf" width="100%" height="550" type="application/pdf"></div><h1>Java学习路径</h1><h2 id="第一部分：Java基础">第一部分：Java基础</h2><h3 id="变量">变量</h3><h3 id="控制结构">控制结构</h3><ul><li><p>顺序结构</p></li><li><p>循环</p></li><li><p>分支</p></li></ul><h3 id="OOP">OOP</h3><ul><li><p>封装</p></li><li><p>继承</p></li><li><p>多态</p></li></ul><h3 id="数组">数组</h3><h3 id="JAVA-API">JAVA API</h3><h3 id="异常和处理">异常和处理</h3><h3 id="集合">集合</h3><h3 id="泛型">泛型</h3><h3 id="IO">IO</h3><h3 id="反射">反射</h3><h3 id="网络通信">网络通信</h3><h3 id="Mysql基础">Mysql基础</h3><ul><li><p>SQL</p></li><li><p>JDBC</p><ul><li><p>PreparedStatement</p></li><li><p>JDBCUtils</p></li><li><p>事务</p></li></ul></li><li><p>连接池</p><ul><li><p>c3p0</p></li><li><p>DBCP</p></li><li><p>Druid（德鲁伊，阿里推荐）</p></li></ul></li></ul><h2 id="第二部分：Java-高级">第二部分：Java 高级</h2><h3 id="Java-多线程-高并发">Java 多线程 / 高并发</h3><ul><li><p>并发基础</p><ul><li><p>互斥同步</p></li><li><p>非阻塞同步</p></li><li><p>指令重排</p></li><li><p>synchronized</p></li><li><p>volatile</p></li></ul></li><li><p>线程</p></li><li><p>锁</p><ul><li><p>自旋锁</p></li><li><p>偏向锁</p></li><li><p>可重入锁</p></li></ul></li><li><p>线程池</p></li><li><p>并发容器</p></li><li><p>JUC</p><ul><li><p>executor</p></li><li><p>collections</p></li><li><p>locks</p></li><li><p>atomic（原子类）</p></li><li><p>tools（CountDownLatch，Exchanger，ThreadLocal，CyclicBarrier）</p></li></ul></li></ul><h3 id="数据结构和算法">数据结构和算法</h3><ul><li><p>数据结构</p><ul><li><p>数组（稀松数组）</p></li><li><p>队列</p></li><li><p>栈</p></li><li><p>链表</p></li><li><p>树</p></li><li><p>散列</p></li><li><p>堆</p></li><li><p>图</p></li></ul></li><li><p>算法</p><ul><li><p>排序（八种）</p></li><li><p>查找</p></li><li><p>分治</p></li><li><p>动态规划（背包问题）</p></li><li><p>回溯（骑士周游问题）</p></li><li><p>贪心算法</p></li><li><p>KMP</p></li><li><p>Prim</p></li><li><p>floyd-最短路径</p></li><li><p>Dijkstra-最短路径</p></li></ul></li></ul><h3 id="设计模式">设计模式</h3><ul><li><p>单例模式</p></li><li><p>观察者模式</p></li><li><p>工厂模式</p></li><li><p>适配器模式</p></li><li><p>装饰者模式</p></li><li><p>代理模式</p></li><li><p>模版模式</p></li><li><p>职责链模式</p></li><li><p>其他（组合模式，桥接模式，原型模式···）</p></li></ul><h3 id="JVM">JVM</h3><ul><li><p>JVM 体系</p></li><li><p>类加载过程/机制</p></li><li><p>双亲委派机制 / 沙箱安全机制</p></li><li><p>JMM（Java 内存模式）</p></li><li><p>字节码执行过程/机制</p></li><li><p>GC（垃圾回收机制）</p></li><li><p>JVM 性能监控和故障定位</p></li><li><p>JVM 调优</p></li></ul><h2 id="第三部分：Java-web">第三部分：Java web</h2><h3 id="前端基础">前端基础</h3><ul><li><p>html</p></li><li><p>css</p></li><li><p>JavaScript</p></li><li><p>Ajax</p></li><li><p>Jquery</p></li></ul><h3 id="前端框架（可弱化）">前端框架（可弱化）</h3><ul><li><p>VUE</p></li><li><p>React</p></li><li><p>Angular</p></li><li><p>bootstrap</p></li><li><p>Node.js</p></li></ul><h3 id="Java-web后端">Java web后端</h3><ul><li><p>Tomcat</p></li><li><p>Servlet</p></li><li><p>JSP</p></li></ul><h2 id="第四部分：主流框架和项目管理">第四部分：主流框架和项目管理</h2><h3 id="Linux（必学）">Linux（必学）</h3><h3 id="Nginx（做反向代理的web服务器）">Nginx（做反向代理的web服务器）</h3><h3 id="SSM">SSM</h3><ul><li><p>Spring（轻量级的容器框架）</p></li><li><p>SpringMVC（分层的web开发框架）</p></li><li><p>MyBatis（持久化框架）</p></li></ul><h3 id="项目管理">项目管理</h3><ul><li><p>Maven</p></li><li><p>Git &amp; GitHub</p></li><li><p>SVN（过时）</p></li></ul><h3 id="数据库">数据库</h3><ul><li><p>Redis</p></li><li><p>Mysql</p></li><li><p>Oracle</p></li></ul><h3 id="其他框架">其他框架</h3><ul><li><p>WebService（即SOA）</p></li><li><p>Activiti（工作流框架/引擎）</p></li><li><p>Shiro（安全引擎）</p></li><li><p>Spring Security（安全框架）</p></li><li><p>JPA（持久化）</p></li><li><p>SpringData（是持久层的通用解决方案）</p></li></ul><h2 id="第五部分：分布式-微服务-并行架构">第五部分：分布式 微服务 并行架构</h2><h3 id="Netty">Netty</h3><h3 id="Dubbo（PRC框架）">Dubbo（PRC框架）</h3><h3 id="FastDFS（分布式的文件系统）">FastDFS（分布式的文件系统）</h3><h3 id="Docker（应用容器引擎）">Docker（应用容器引擎）</h3><h3 id="Spring-家族">Spring 家族</h3><ul><li><p>Spring Boot</p></li><li><p>Spring Cloud（组件很多）</p><ul><li><p>Nacos（阿里，服务发现，配制和管理）</p></li><li><p>Seata（阿里，分布式事务的中间件）</p></li><li><p>Sentinel（阿里，流量控制，熔断，系统负载保护）</p></li><li><p>GateWay（网关，限流，日志，监控，鉴权）</p></li></ul></li></ul><h3 id="搜索引擎">搜索引擎</h3><ul><li><p>ElasticSearch</p></li><li><p>Solr</p></li></ul><h3 id="中间件">中间件</h3><ul><li><p>MyCat（数据库中间件，分库分表）</p></li><li><p>消息中间件</p><ul><li><p>ActiveMQ</p></li><li><p>RabbitMQ</p></li><li><p>Kafka</p></li></ul></li></ul><h3 id="日志分析与监控（ELK）">日志分析与监控（ELK）</h3><ul><li><p>ElasticSearch（搜集，存储数据）</p></li><li><p>LogStash（分析日志）</p></li><li><p>Kibana（可视化）</p></li></ul><h3 id="Zookeeper（一致性服务：比如配置维护，域名维护，分布式同步）">Zookeeper（一致性服务：比如配置维护，域名维护，分布式同步）</h3><h2 id="第六部分：DevOps（开发运维一体化）（自动化部署管理项目）">第六部分：DevOps（开发运维一体化）（自动化部署管理项目）</h2><ul><li>k8s（让部署容器化的应用简单高效）</li><li>普罗米修斯（prometheus）（系统监控和报警）</li><li>Jenkins（监控持续的工作，比如部署、集成、交付）</li><li>Harbor（容器的镜像仓库）</li><li>GitLab</li><li>sonarqube（项目工程代码质量检测）</li></ul><h2 id="第七部分：大数据技术（可以弱化）">第七部分：大数据技术（可以弱化）</h2><ul><li>Hadoop</li><li>Hive</li><li>Impals</li><li>spark</li><li>flink</li></ul><h2 id="第八部分：项目">第八部分：项目</h2><h3 id="电商">电商</h3><h3 id="金融">金融</h3><h3 id="教育">教育</h3><h3 id="直播">直播</h3><h3 id="CRM，ERP">CRM，ERP</h3><h2 id="第九部分：大厂的高频面试题">第九部分：大厂的高频面试题</h2><h3 id="重点关注">重点关注</h3><ul><li><p>第二部分：Java 高级</p></li><li><p>SSM</p></li><li><p>数据库</p></li><li><p>Spring 家族</p></li><li><p>Netty</p></li><li><p>中间件</p></li><li><p>项目</p></li></ul><h2 id="第十部分：底层源码-内核研究">第十部分：底层源码 / 内核研究</h2><h2 id="编程基础扩展">编程基础扩展</h2><h3 id="计网">计网</h3><h3 id="操作系统">操作系统</h3><h3 id="编译原理">编译原理</h3><h3 id="离散数学">离散数学</h3><h3 id="数值分析">数值分析</h3><h3 id="计组">计组</h3><h3 id="汇编语言">汇编语言</h3>]]></content>
      
      
      <categories>
          
          <category> Programming Language </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Road Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Programming Language</title>
      <link href="/2025/03/02/Java-Programming-Language/"/>
      <url>/2025/03/02/Java-Programming-Language/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="Java编程基础_compressed.pdf" width="100%" height="550" type="application/pdf"></div><blockquote><p>Tips: Poor typesetting(no space between Chinese and non-Chinese words) content exists, please mainly refer to the mind map.</p></blockquote><h1>Java编程基础</h1><h2 id="第一章：内容介绍">第一章：内容介绍</h2><h2 id="第二章：Java概述">第二章：Java概述</h2><h2 id="第三章：变量">第三章：变量</h2><h2 id="第四章：运算符">第四章：运算符</h2><h2 id="第五章：程序控制结构">第五章：程序控制结构</h2><h2 id="第六章：数组、排序和查找">第六章：数组、排序和查找</h2><h2 id="第七章：面向对象编程（初级）">第七章：面向对象编程（初级）</h2><h3 id="7-1-类与对象">7.1 类与对象</h3><ul><li><p>引出</p><ul><li><p>单个声明每一个变量不利于数据的管理</p></li><li><p>使用数组不利于将意义与数据对应，效率低</p></li></ul></li><li><p>类与对象的关系</p><ul><li>类是对象的抽象，对象是类的实例化</li></ul></li><li><p>类与对象的区别和联系</p><ul><li><p>类是抽象的、概念的，代表一类事物，比如人类、猫类…，即类是数据类型</p></li><li><p>对象是具体的，实际的，代表一个具体事物，即是实例</p></li><li><p>类是对象的模板，对象是类的一个个体，对应一个实例</p></li></ul></li><li><p>对象在内存中的存在形式</p><ul><li></li></ul></li><li><p>属性/成员变量/字段</p><ul><li><p>基本介绍</p><ul><li><p>从概念或叫法上看：成员变量和属性、字段是一个意思。</p></li><li><p>属性是类的一个组成部分，一般是基本数据类型，也可以是引用类型</p></li></ul></li><li><p>注意事项的细节说明</p><ul><li><p>属性的定义语法同变量</p></li><li><p>属性的定义类型可以为任意类型，包含基本类型或引用类型</p></li><li><p>属性如果不赋值，会有默认值，规则和数组是一致的。<br>具体说，int, short, byte, long 是 0，float 和 double 是 0.0，char 是 \u0000，boolean 是 false，String 是 null</p></li></ul></li></ul></li><li><p>如何创建对象</p><ul><li><p>先声明再创建</p><ul><li>先声明，再分配内存</li></ul></li><li><p>直接创建</p><ul><li>声明和创建放在一起</li></ul></li></ul></li><li><p>如何访问属性</p><ul><li>运用点（.）运算符</li></ul></li><li><p>类和对象的内存分配机制</p><ul><li><p>Java 的内存结构分析</p><ul><li><p>栈</p><ul><li>一般存放基本数据类型（局部变量）</li></ul></li><li><p>堆</p><ul><li>存放对象、数组等</li></ul></li><li><p>方法区</p><ul><li>存放常量池，类加载信息</li></ul></li></ul></li><li><p>Java创建对象的流程简单分析</p><ul><li><p>先加载类信息（属性和方法信息，对一个类只会加载一次）</p></li><li><p>在堆中分配空间，进行默认初始化</p></li><li><p>把地址赋给标识符，标识符就指向对象</p></li><li><p>进行指定初始化（即在类定义时已经书写的初始化）</p></li></ul></li></ul></li></ul><h3 id="7-2-成员方法">7.2 成员方法</h3><ul><li><p>基本介绍</p><ul><li>在某些情况下，我们需要定义成员方法（简称方法）。比如人类，除了有一些属性外，人类还有一些行为比如：说话、吃饭、学习。这时就要用成员方法才能完成。</li></ul></li><li><p>方法的调用机制</p><ul><li></li></ul></li><li><p>成员方法的好处</p><ul><li><p>提高代码的复用性</p></li><li><p>可以将实现的细节封装起来，然后供其他用户来调用即可</p></li></ul></li><li><p>成员方法的定义</p><ul><li><p>形参列表</p><ul><li>表示成员方法输入</li></ul></li><li><p>返回数据类型</p><ul><li>表示成员方法的输出（返回值）</li></ul></li><li><p>方法主体</p><ul><li>实现某一功能的代码块</li></ul></li><li><p>return 语句（对于 void 类型不必要）</p></li></ul></li><li><p>注意事项和使用细节</p><ul><li><p>访问修饰符</p><ul><li>不写默认是默认修饰符</li></ul></li><li><p>返回数据类型</p><ul><li><p>一个方法最多有一个返回值（需要多个返回值可以返回数组）</p></li><li><p>返回类型可以为任意类型，包括基本类型和引用类型（数组对象字符串）</p></li><li><p>如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 语句；而且要求返回值类型和 return 的值类型一致或兼容</p></li><li><p>如果方法是 void，则方法体中可以没有 return 语句，或者只写 return；</p></li></ul></li><li><p>方法名</p><ul><li>遵循驼峰命名法，最好见名知义，表达出该功能的意思即可</li></ul></li><li><p>形参列表</p><ul><li><p>一个方法可以有 0 个参数，也可以有多个参数，中间用逗号隔开</p></li><li><p>参数类型可以为任意类型，包含基本类型和引用类型</p></li><li><p>调用带参数的方法时，一定对应着参数列表传入下相同类型或兼容类型的参数</p></li><li><p>方法定义时的参数称为形式参数，简称形参‘方法调用时传入的参数称为实际参数，简称实参，实参和形参的类型要一致或兼容，个数、顺序必须一致</p></li></ul></li><li><p>方法体</p><ul><li>几乎无限制，但注意方法体内不能再定义方法</li></ul></li><li><p>方法调用</p><ul><li><p>同一个类中的方法：直接调用</p></li><li><p>跨类中的方法调用：需要通过对象名调用，即要先创建对象才能调用</p></li><li><p>跨类方法调用还与方法的访问修饰符相关，后面会具体讲到</p></li></ul></li></ul></li></ul><h3 id="7-3-成员方法传参机制">7.3 成员方法传参机制</h3><ul><li><p>基本数据类型传参是值拷贝，不会影响主调方法中的变量</p></li><li><p>引用数据类型传参是地址拷贝，会影响主调方法中的引用数据类型变量</p></li></ul><h3 id="7-4-方法递归调用">7.4 方法递归调用</h3><ul><li><p>基本介绍</p><ul><li>递归就是方法自己调用自己</li></ul></li><li><p>例子</p><ul><li><p>阶乘运算</p></li><li><p>猴子吃桃问题</p></li><li><p>迷宫问题</p></li><li><p>汉诺塔问题</p></li><li><p>八皇后问题</p></li></ul></li></ul><h3 id="7-5-方法重载">7.5 方法重载</h3><ul><li><p>基本介绍</p><ul><li>Java 中允许同一个类中，多个同名方法的存在，但要求形参列表不一致</li></ul></li><li><p>重载的好处</p><ul><li><p>减轻了起名的麻烦</p></li><li><p>减轻了记名的麻烦</p></li></ul></li><li><p>注意事项和使用细节</p><ul><li><p>方法名：必须相同</p></li><li><p>形参列表：必须不同。简单地说，要一眼看上去就能通过形参列表区分两个方法，这样才构成重载</p></li><li><p>返回类型：无要求<br>理解：形参列表要求不同那么返回类型肯定会有不同，所以返回类型无要求</p></li></ul></li></ul><h3 id="7-6-可变参数">7.6 可变参数</h3><ul><li><p>基本概念</p><ul><li>java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。</li></ul></li><li><p>基本语法</p><ul><li>访问修饰符 返回类型 方法名(数据类型… 形参名)</li></ul></li><li><p>注意事项和使用细节</p><ul><li><p>可变参数的实参可以为 0 个或任意多个</p></li><li><p>可变参数的实参可以为数组</p></li><li><p>可变参数的本质就是数组</p></li><li><p>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</p></li><li><p>一个形参列表中只能出现一个可变参数</p></li></ul></li></ul><h3 id="7-7-作用域">7.7 作用域</h3><ul><li><p>基本使用</p><ul><li><p>在 Java 编程中，主要的变量就是属性和局部变量</p></li><li><p>我们说的局部变量一般是指在成员方法中定义的变量</p></li><li><p>Java 中作用域的分类</p><ul><li><p>全局变量</p><ul><li>也就是属性，作用域为整个类体</li></ul></li><li><p>局部变量</p><ul><li>也就是除了属性之外的其他变量，作用域为定义它的代码块中</li></ul></li></ul></li><li><p>全局变量可以不赋值，直接使用，因为有默认值。局部变量必须赋值后。才能使用，因为没有默认值</p></li></ul></li><li><p>注意事项和细节使用</p><ul><li><p>属性和局部变量可以重名，访问时遵循就近原则</p></li><li><p>在同一个作用域中，比如同一个成员方法中，两个局部变量不能重名</p></li><li><p>属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量生命周期较短，伴随着它的代码块的执行而创建，伴随这代码块的结束而销毁，即在一次方法调用过程中。</p></li><li><p>作用域范围不同</p><ul><li><p>全局变量 / 属性：可以被本类使用，或被其他类调用（通过对象调用）</p></li><li><p>局部变量：只能在本类中对应的方法中使用</p></li></ul></li><li><p>修饰符不同</p><ul><li><p>全局变量 / 属性可以加修饰符</p></li><li><p>局部变量不可以加修饰符</p></li></ul></li></ul></li></ul><h3 id="7-8-构造器">7.8 构造器</h3><ul><li><p>基本介绍</p><ul><li>构造器，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化</li></ul></li><li><p>基本语法</p><ul><li>访问修饰符 方法名(形参列表){<br>方法体;<br>}<ul><li><p>注意</p><ul><li><p>构造器的修饰符可以是默认，也可以是 public protected private</p></li><li><p>构造器没有返回值</p></li><li><p>方法名和类名必须一样</p></li><li><p>参数列表和成员方法是一样的规则</p></li><li><p>构造器的调用，由系统完成</p></li></ul></li></ul></li></ul></li><li><p>特点</p><ul><li><p>方法名和类名相同</p></li><li><p>没有返回值</p></li><li><p>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化</p></li></ul></li><li><p>注意事项和使用细节</p><ul><li><p>一个类可以定义多个不同的构造器，即构造器重载</p></li><li><p>构造器名和类名要相同</p></li><li><p>构造器没有返回值</p></li><li><p>构造器是完成对象的初始化，并不是创建对象</p></li><li><p>在创建对象时，系统自动地调用该类的构造器</p></li><li><p>如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器</p></li><li><p>一旦定义了自己的构造器，默认的构造器就被覆盖了，就不能再使用默认的无参构造器，除非显式地定义一下</p></li></ul></li></ul><h3 id="7-9-对象创建流程分析">7.9 对象创建流程分析</h3><ul><li><p>流程</p><ul><li><p>加载类信息，且只会加载一次</p></li><li><p>在堆中分配空间（地址）</p></li><li><p>完成对象初始化</p><ul><li><p>默认初始化</p></li><li><p>显式（定义中的）初始化</p></li><li><p>构造器的初始化</p></li></ul></li><li><p>把对象在堆中的地址返回给标识符</p></li></ul></li></ul><h3 id="7-10-this-关键字">7.10 this 关键字</h3><ul><li><p>什么是 this</p><ul><li><p>Java 虚拟机会给每个对象分配 this，代表当前对象</p></li><li><p>简单地说，哪个对象调用，this 就代表哪个对象</p></li><li></li></ul></li><li><p>this 的注意事项和使用细节</p><ul><li><p>this 关键字可以用来访问本类的属性、方法、构造器</p></li><li><p>this 用于区别当前类的属性和局部变量</p></li><li><p>访问成员方法的语法，this.方法名(参数列表)</p></li><li><p>访问构造器语法：this(参数列表)。注意只能在构造器中访问另外一个构造器，且必须放在该构造器的第一条语句处</p></li><li><p>this 不能在类定义的外部使用，只能在类定义的方法中使用</p></li></ul></li></ul><h2 id="第八章：面向对象编程（中级）">第八章：面向对象编程（中级）</h2><h3 id="8-1-8-3-IDE-IDEA">8.1~8.3 IDE - IDEA</h3><ul><li><p>常用快捷键</p><ul><li><p>ctrl + d 删除当前行</p></li><li><p>ctrl + alt + 下箭头 复制当前行</p></li><li><p>alt + / 补全代码</p></li><li><p>ctrl + / 多行添加或删除注释</p></li><li><p>alt + enter 导入该行需要的类</p></li><li><p>ctrl + alt + L 快速格式化代码</p></li><li><p>alt + r 快速运行程序</p></li><li><p>alt + insert 生成构造器</p></li><li><p>ctrl + h 查看一个类的层级关系</p></li><li><p>ctrl + b 光标放在一个方法上时可以定位到方法处</p></li><li><p>.var 自动分配变量名</p></li></ul></li><li><p>模板 / 自定义模板</p><ul><li>file -&gt; settings -&gt; editor -&gt; Live templates</li></ul></li></ul><h3 id="8-4-包">8.4 包</h3><ul><li><p>包的三大作用</p><ul><li><p>区分相同名字的类</p></li><li><p>当类很多时，可以很好地管理类</p></li><li><p>控制访问范围</p></li></ul></li><li><p>包的基本语法</p><ul><li><p>package 包名</p></li><li><p>说明</p><ul><li><p>package 关键字，表示打包</p></li><li><p>包名中的（.）用于表示子目录</p></li></ul></li></ul></li><li><p>包的本质分析</p><ul><li>包的本质，实际上就是创建不同的文件夹 / 目录来保存类文件</li></ul></li><li><p>包的命名</p><ul><li><p>命名规则</p><ul><li>只能包含数字、字母、下划线和小圆点，但不能用数字开头，不能有关键字或保留字</li></ul></li><li><p>命名规范</p><ul><li><p>一般是小写字母 + 小圆点</p></li><li><p>一般命名为 com.公司名.项目名.业务模块名</p></li></ul></li></ul></li><li><p>常用的包</p><ul><li><p>java.lang.*</p><ul><li>lang 包是基本包，默认导入，不需要再导入</li></ul></li><li><p>java.util.*</p><ul><li>util 包是系统提供的工具包</li></ul></li><li><p><a href="http://java.net">java.net</a>.*</p><ul><li>网络包，用于网络开发</li></ul></li><li><p>java.awt.*</p><ul><li>GUI 界面包，用于做可视化界面</li></ul></li></ul></li><li><p>如何导入包</p><ul><li><p>语法</p><ul><li>import 包名</li></ul></li><li><p>引入一个包的主要目的是要使用该包下的类</p></li><li><p>建议需要哪个类就导入哪个类，不建议使用 * 导入</p></li></ul></li><li><p>注意事项和使用细节</p><ul><li><p>package 的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句 package</p></li><li><p>import 指令位置放在 package 下面，类定义的前面，可以有多句且顺序无要求</p></li></ul></li></ul><h3 id="8-5-访问修饰符">8.5 访问修饰符</h3><ul><li><p>基本介绍</p><ul><li><p>Java 提供四种访问控制修饰符号，用于控制方法和属性的访问范围</p><ul><li><p>public</p><ul><li>对外公开</li></ul></li><li><p>protected</p><ul><li>对子类和同一个包中的类公开</li></ul></li><li><p>默认</p><ul><li>对同一个包中的类公开</li></ul></li><li><p>private</p><ul><li>只对本类公开，不对外公开</li></ul></li></ul></li></ul></li><li><p>访问范围</p><ul><li></li></ul></li><li><p>使用的注意事项</p><ul><li><p>访问修饰符可以用来修饰类中的属性、方法和类本身</p></li><li><p>只有默认和 public 修饰符可以修饰类，并且遵循上述访问权限的特点</p></li><li><p>子类的访问权限会在讲完继承后讲解</p></li><li><p>成员方法的访问规则和属性完全一样</p></li></ul></li></ul><h3 id="8-6-面向对象编程三大特征">8.6 面向对象编程三大特征</h3><ul><li><p>封装</p></li><li><p>继承</p></li><li><p>多态</p></li></ul><h3 id="8-7-封装">8.7 封装</h3><ul><li><p>介绍</p><ul><li>封装就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作，才能对数据进行操作</li></ul></li><li><p>优点</p><ul><li><p>隐藏实现细节</p></li><li><p>可以对数据进行验证，保证安全合理</p></li></ul></li><li><p>实现步骤</p><ul><li><p>将属性私有化【使属性不能被直接修改】</p></li><li><p>提供一个 public 的 set 方法，用于对属性进行合法判断和赋值</p></li><li><p>提供一个 public 的 get 方法，用于验证权限和获取属性的值</p></li></ul></li></ul><h3 id="8-8-继承">8.8 继承</h3><ul><li><p>基本介绍和示意图</p><ul><li><p>继承可以解决代码复用，让我们的编程更加靠近人类思维。当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可。</p></li><li></li></ul></li><li><p>基本语法</p><ul><li><p>class 子类 extends 父类</p></li><li><p>说明</p><ul><li><p>子类会自动拥有父类定义的属性和方法</p></li><li><p>父类又叫超类、基类</p></li><li><p>子类又叫派生类</p></li></ul></li></ul></li><li><p>优点</p><ul><li><p>代码的复用性提高了</p></li><li><p>代码的扩展性和可维护性提高了</p></li></ul></li><li><p>继承的深入讨论和细节</p><ul><li><p>子类继承了父类所有的属性和方法，其中非私有的属性和方法可以在子类中直接访问，但是私有的属性和方法不能再子类中直接访问，要通过父类提供的公共的方法去访问</p></li><li><p>子类的构造器中必须调用父类的构造器，以完成父类的初始化</p></li><li><p>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成父类的初始化，否则编译不通过</p></li><li><p>如果希望指定去调用父类的某个构造器，则显式地调用一下</p></li><li><p>super 在使用时，必须放在构造器的第一行</p></li><li><p>super() 和 this() 都只能放在构造器的第一行，因此这两个方法不能在一个构造器中共存</p></li><li><p>Java 所有类都是 Object 类的子类，Object 类是所有类的父类</p></li><li><p>父类构造器的调用不限于直接父类！将一致往上追溯直到 Object 类</p></li><li><p>子类最多只能继承一个父类（指直接继承），即 Java 中是单继承机制</p></li><li><p>不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系</p></li></ul></li><li><p>继承的本质分析</p><ul><li><p>本质</p><ul><li><p>当子类对象创建好后，建立【查找】的关系</p></li><li></li></ul></li><li><p>JVM 如何知道要访问哪个属性？</p><ul><li><p>按照查找关系来返回信息</p><ul><li><p>首先看当前类是否有该属性</p></li><li><p>如果当前类有，并且可以访问，则返回信息</p></li><li><p>如果当前类没有这个属性，就看这个类的父类有没有这个属性（如果这个类的父类有该属性，并且可以访问，就返回信息）</p></li><li><p>如果这个类的父类没有，则按照3的规则，继续找上级父类，直到 Object</p></li></ul></li><li><p>对于方法的查找也是相同的规则</p></li></ul></li></ul></li></ul><h3 id="8-9-super关键字">8.9 super关键字</h3><ul><li><p>基本介绍</p><ul><li>super 代表父类的引用，用于访问父类的属性、方法和构造器</li></ul></li><li><p>基本语法</p><ul><li><p>访问父类的属性，但不能访问 private 属性<br>super.属性名</p></li><li><p>访问父类的方法，但不能访问 private 的方法<br>super.方法名(参数列表）</p></li><li><p>访问父类的构造器<br>super(参数列表)<br>只能放在构造器的第一句，只能出现一句</p></li></ul></li><li><p>给编程带来的便利</p><ul><li>分工明确，父类属性由父类初始化，子类属性由子类初始化</li></ul></li><li><p>注意细节</p><ul><li><p>当子类中有和父类中的属性和方法重名时，为了访问父类的属性和方法，必须通过 super。如果没有重名，使用 super，this，直接访问时一样的效果</p></li><li><p>super 的访问不限于直接父类，如果爷爷类和本类中有同名的属性或方法，也可以使用 super 去访问爷爷类的成员；如果多个上级类中都有重名的成员，使用 super 访问遵循就近原则，且遵守访问权限的相关规则</p></li></ul></li><li><p>this 和 super 的比较</p><ul><li></li></ul></li></ul><h3 id="8-10-方法重写-覆盖">8.10 方法重写/覆盖</h3><ul><li><p>基本介绍</p><ul><li>方法覆盖（重写）就是指子类有一个方法，和父类的某个方法的名称、返回类型、参数都一样。那么我们就说子类的这个方法覆盖了父类的方法</li></ul></li><li><p>注意事项和使用细节</p><ul><li><p>子类方法的形参列表、方法名称必须要和父类的完全一样</p></li><li><p>子类方法的返回类型和父类方法的返回类型一样，或者是父类返回类型的子类<br>比如父类返回 Object 类型，子类返回 String 类型，也构成方法重写</p></li><li><p>子类方法不能缩小父类方法的访问权限</p></li></ul></li><li><p>重写与重载的比较</p><ul><li></li></ul></li></ul><h3 id="8-11-多态">8.11 多态</h3><ul><li><p>引出</p><ul><li><p>传统的方法存在代码的复用性不高，不利于代码维护等缺点</p><ul><li>于是需要引入多态来解决</li></ul></li></ul></li><li><p>基本介绍</p><ul><li>方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的</li></ul></li><li><p>多态的具体体现</p><ul><li><p>方法的多态</p><ul><li><p>方法重写</p></li><li><p>方法重载</p></li></ul></li><li><p>对象的多态</p><ul><li><p>首先，几句前置知识</p><ul><li><p>一个对象的编译类型和运行类型可以不一致</p></li><li><p>编译类型在定义对象时，就确定了，不能改变</p></li><li><p>运行类型是可以变化的</p></li><li><p>编译类型看定义时 = 的左边，运行类型看 = 的右边</p></li></ul></li></ul></li></ul></li><li><p>多态的注意事项和细节</p><ul><li><p>前提</p><ul><li>对象多态的前提是：两个对象（类）存在继承关系</li></ul></li><li><p>向上转型</p><ul><li><p>本质：父类的引用指向了子类的对象</p></li><li><p>语法： 父类类型 引用名 = new 子类类型();</p></li><li><p>特点</p><ul><li><p>编译类型看左边，运行类型看右边</p></li><li><p>可以调用编译类型中的所有成员（需要遵循访问权限）</p></li><li><p>不能调用运行类型中的特有成员</p></li><li><p>最终运行效果决定于运行类型的具体实现（即调用方法时，按照从运行类型开始查找方法的调用规则【同继承】来查找方法）</p></li></ul></li></ul></li><li><p>向下转型</p><ul><li><p>语法： 子类类型 引用名 = (子类类型)父类引用;</p></li><li><p>特点</p><ul><li><p>只是强转父类的引用，不是强转父类的对象（即只是引用类型被转变，具体对象在内存中的形式没有变化）</p></li><li><p>要求父类的引用必须指向的是当前强转类型的对象</p></li><li><p>当向下转型后，可以调用子类中所有成员（遵循访问限制）</p></li></ul></li></ul></li><li><p>属性没有重写一说！直接调用属性时具体属性的值取决于编译类型</p></li><li><p>instanceof 比较操作符，用于判断对象的【运行】类型是否为 XX 类型或者 XX 类型的子类</p></li></ul></li><li><p>动态绑定机制</p><ul><li><p>当调用对象方法的时候，该方法会和该对象的运行类型绑定（即调用对象方法时，总是调用该对象的运行类型的方法，若没有，才依次往上看）</p></li><li><p>当在方法中调用对象属性时，没有动态绑定机制，其返回的值遵循就近原则</p></li></ul></li><li><p>应用</p><ul><li><p>多态数组</p><ul><li>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型</li></ul></li><li><p>多态参数</p><ul><li>方法定义的形参类型为父类类型，实参类型允许为子类类型</li></ul></li></ul></li></ul><h3 id="8-12-Object类详解">8.12 Object类详解</h3><ul><li><p>equals 方法</p><ul><li><p>== 和 equals 对比</p><ul><li><p>== 是一个比较运算符，equals 是一个方法</p></li><li><p>== 既可以判断基本类型，又可以判断引用类型</p></li><li><p>== 如果判断基本类型，判断的是值是否相等</p></li><li><p>== 如果判断引用类型，判断的是地址是否相等</p></li><li><p>equals 是 Object 类方法，只能判断引用类型</p></li><li><p>equals 默认判断的是地址是否相等，子类往往重写该方法，用于判断内容是否相等</p></li></ul></li><li><p>重写 equals 方法</p><ul><li><p>先判断是否是本身，是则返回 true</p></li><li><p>再判断类型是否匹配，是则判断值，不是则返回 false</p></li><li><p>类型如果匹配，则判断值，值都相等，则返回 false</p></li><li><p>如果上述均不满足，则返回 false</p></li></ul></li></ul></li><li><p>hashCode 方法</p><ul><li><p>用处：提高具有哈希结构的容器的效率</p></li><li><p>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的</p></li><li><p>两个引用，如果指向的是不同对象，则哈希值一般不同</p></li><li><p>哈希值主要是根据地址来算得的，但并不等价于地址</p></li><li><p>后面在集合中，hashCode 如果需要的话也会重写，在讲解集合时会说如何重写</p></li></ul></li><li><p>toString 方法</p><ul><li><p>基本介绍</p><ul><li>默认返回：全类名 + @ + 哈希值的十六进制<br>子类往往重写 toString 方法，用于返回对象的属性信息</li></ul></li><li><p>重写 toString 方法</p><ul><li>是为了打印对象或拼接对象时，调用该对象的 toString 方法来方便开发</li></ul></li><li><p>当直接输出一个对象时，toString 方法会被默认调用</p></li></ul></li><li><p>finalize 方法</p><ul><li><p>当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作</p></li><li><p>什么时候被回收：当某个对象没有任何引用时，则 JVM 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁对象前，会调用 finalize 方法</p></li><li><p>垃圾回收机制的调用，是由系统来决定（有自己的 GC 算法），也可以通过 System.gc() 来主动调用垃圾回收期</p></li><li><p>注：在实际开发中，几乎不会运用 finalize，所以更多是为了应付面试</p></li></ul></li></ul><h3 id="8-13-断点调试">8.13 断点调试</h3><h3 id="8-14-零钱通项目">8.14 零钱通项目</h3><h2 id="第九章：房屋出租系统">第九章：房屋出租系统</h2><h3 id="分层模式设计">分层模式设计</h3><ul><li></li></ul><h3 id="源码">源码</h3><ul><li><p>HouseInterface.java</p></li><li><p>HouseService.java</p></li><li><p>Utility.java</p></li><li><p>House.java</p></li><li><p>HouseRentApp.java</p></li></ul><h2 id="第十章：面向对象编程（高级）">第十章：面向对象编程（高级）</h2><h3 id="10-1-类变量和类方法">10.1 类变量和类方法</h3><ul><li><p>类变量</p><ul><li><p>什么是类变量</p><ul><li>类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。</li></ul></li><li><p>如何定义类变量</p><ul><li>访问修饰符 static 数据类型 变量名;</li></ul></li><li><p>如何访问类变量</p><ul><li><p>类名.类变量名</p></li><li><p>对象名.类变量名</p></li></ul></li><li><p>类变量的内存布局</p><ul><li></li><li><p>static 变量是同一个类所有对象共享<br>static 类变量，在类加载的时候就生成了</p></li></ul></li><li><p>类变量使用注意事项和细节讨论</p><ul><li><p>什么时候需要用类变量</p><ul><li>当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量</li></ul></li><li><p>类变量与实例变量的区别</p><ul><li>类变量时该类的所有对象共享的，而实例变量是每个对象独享的</li></ul></li><li><p>加上 static 称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量</p></li><li><p>类变量可以通过类名.类变量名或者对象名.类变量名来访问，推荐使用前者方式访问【前提是：满足访问修饰符的访问权限和范围】</p></li><li><p>实例变量不能通过类名.类变量名来访问</p></li><li><p>类变量是在类加载时就初始化了，也就是说，即使没有创建对象，只要类加载了，就可以使用类变量了</p></li><li><p>类变量的生命周期是随类的加载开始，随着类消亡而销毁</p></li></ul></li></ul></li><li><p>类方法</p><ul><li><p>基本介绍</p><ul><li>类方法也叫静态方法，形式如下：<br>访问修饰符 static 数据返回类型 方法名（）{ }</li></ul></li><li><p>调用</p><ul><li>类名.类方法名或对象名.类方法名【前提要满足访问修饰符的访问权限和范围】</li></ul></li><li><p>Best Practice</p><ul><li><p>当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率<br>【即这个方法不跟对象捆绑使用，则就可以设计成静态方法】</p></li><li><p>在程序员实际开发中，往往会将一些通用的方法设计成静态方法，这样我们不需要创建对象就可以使用了</p></li></ul></li><li><p>类方法使用注意事项和细节讨论</p><ul><li><p>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：<br>类方法中不能使用this关键字，但普通方法可以</p></li><li><p>类方法可以通过类名调用，也可以通过对象名调用</p></li><li><p>普通方法和对象有关，需要通过对象名调用，不能通过类名调用</p></li><li><p>类方法中不允许使用和对象有关的关键字，比如 this 和 super，普通方法可以</p></li><li><p>静态方法只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员【遵守访问权限】</p></li></ul></li></ul></li></ul><h3 id="10-2-理解-main-方法语法">10.2 理解 main 方法语法</h3><ul><li><p>深入理解 main 方法</p><ul><li><p>main 方法是由 JVM 调用的</p></li><li><p>JVM 在执行 main() 方法时不必创建对象，所以该方法必须是 static</p></li><li><p>JVM 需要调用类的 main 方法，所以该方法的访问权限必须是 public</p></li><li><p>该方法接受 String 类型的数组参数，该数组中保存执行 Java 命令时所传递给所运行的类的参数</p></li><li><p>传值命令： java 执行的程序 参数1 参数2 参数3…</p></li></ul></li><li><p>特别提示</p><ul><li><p>在 main() 方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性（静态成员）</p></li><li><p>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员<br>【即同 static 的访问规则】</p></li></ul></li><li><p>在 idea 中如何传递参数</p><ul><li>run 旁边的三点-&gt; run with parameters -&gt; 在 program arguments 处添加</li></ul></li></ul><h3 id="10-3-代码块">10.3 代码块</h3><ul><li><p>基本介绍</p><ul><li><p>代码块又称初始化块，属于类中的成员，类似于方法将逻辑语句封装在方法体中，通过 {} 包围起来</p></li><li><p>但和方法不同，没有方法名，没有返回数据类型，没有参数，只有方法体，而且不用通过对象或类显式调用，而是在加载类或创建对象时隐式调用</p></li></ul></li><li><p>基本语法</p><ul><li><p>[修饰符] {<br>代码<br>};</p></li><li><p>注意</p><ul><li><p>修饰符仅有 static，是可选项</p></li><li><p>代码块分为两类，使用 static 修饰的叫静态代码块，没有 static 修饰的，叫普通代码块</p></li><li><p>逻辑语句可以为任何语句</p></li><li><p>;可以写上，也可以省略</p></li></ul></li></ul></li><li><p>好处</p><ul><li><p>相当于构造器的补充，可以帮助构造器做初始化的工作</p></li><li><p>如果多个构造器中都有重复的语句，可以抽取到代码块中，提高代码的重用性</p></li></ul></li><li><p>使用注意事项和细节讨论</p><ul><li><p>static 代码块也叫静态代码块，作用就是对类进行初始化，它随着类的加载而执行，并且只会执行一次。普通代码块，每创建一个对象就执行一次</p></li><li><p>类何时被加载？</p><ul><li><p>创建对象实例时 (new)</p></li><li><p>创建子类对象实例，父类也会被加载<br>联想继承下的对象创建顺序</p></li><li><p>使用类的静态成员(静态属性或方法）时</p></li></ul></li><li><p>普通的代码块，在创建对象实例时，会被隐式地调用，对象被创建一次，就会调用一次<br>如果只是使用类的静态成员，普通代码块不会被调用</p></li></ul></li><li><p>创建一个对象时，在一个类中的调用顺序</p><ul><li><p>完成类加载，调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化的优先级一样，如果有多个静态代码块和多个静态属性初始化，则按他们定义的顺序来依次调用）</p></li><li><p>完成对象属性（非静态属性）的初始化，即调用普通代码块和普通属性的初始化（注意事项同上）</p></li><li><p>调用构造器完成构造器中的初始化</p></li></ul></li><li><p>构造器的最前面隐含了 super() 与普通代码块的调用和普通属性初始化（即在调用子类的构造器初始化之前，先完成父类的初始化和子类普通属性初始化（包括普通代码块调用）</p></li></ul><p>静态代码块和静态属性初始化在类加载时就执行完毕，因此其执行顺序是优先于构造器和普通代码块的</p><ul><li><p>具有继承关系的类创建对象时，静态代码块、属性，普通代码块、属性和构造器的调用顺序</p><ul><li><p>父类的静态代码块和静态属性</p></li><li><p>子类的静态代码块和静态属性</p></li><li><p>父类的普通代码块和普通属性初始化</p></li><li><p>父类的构造器</p></li><li><p>子类的普通代码块和普通属性初始化</p></li><li><p>子类的构造器</p></li></ul></li><li><p>静态代码块只能直接调用静态成员，普通代码块可以调用任意成员</p></li></ul><h3 id="10-4-单例设计模式">10.4 单例设计模式</h3><ul><li><p>什么是设计模式</p><ul><li>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格以及解决问题的思考方式。<br>打个比方，设计模式就像是经典的棋谱，对于不同的棋局使用不同的棋谱，免去再思考和摸索的过程</li></ul></li><li><p>什么是单例模式</p><ul><li><p>单例（单个实例）（单个对象）</p><ul><li><p>所谓类的单例模式，就是采取一定的方法保证在整个软件系统中，对某个类只存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p></li><li><p>单例模式有两种方式：饿汉式和懒汉式</p></li></ul></li></ul></li><li><p>饿汉式和懒汉式单例模式的实现</p><ul><li><p>将构造器私有化 -&gt; 防止new生成更多对象</p></li><li><p>在类的内部创建静态对象</p></li><li><p>向外暴露一个静态的公共获取实例的方法</p></li></ul></li><li><p>饿汉式和懒汉式的区别</p><ul><li><p>二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载时就创建了对象实例，而懒汉式是在使用时才创建（具体是在调用 getInstance 方法时创建）</p></li><li><p>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</p></li><li><p>饿汉式存在资源浪费的可能，而懒汉式不存在这个问题</p></li><li><p>JavaSE 中的 java.lang.Runtime 就是经典的单例模式</p></li></ul></li></ul><h3 id="10-5-final-关键字">10.5 final 关键字</h3><ul><li><p>基本介绍</p><ul><li><p>final 可以修饰类、属性、方法、局部变量和形参</p></li><li><p>有以下需求时，就会使用到 final</p><ul><li><p>当不希望某个类被继承时，可以用 final 关键字修饰</p></li><li><p>当不希望父类的某个方法被子类重写时，可以用 final 关键字修饰</p></li><li><p>当不希望类的某个属性的值被修改，就可以用 final 关键字修饰</p></li><li><p>当不希望某个局部变量被修改时，就可以使用 final 关键字修饰</p></li></ul></li></ul></li><li><p>注意事项和细节讨论</p><ul><li><p>final 修饰的属性又叫常量，一般用 XX_XXX_XX 来命名</p></li><li><p>final 修饰的属性在定义时必须赋初值，并且以后不能再修改，赋值可以在如下位置之一<br>（1）定义时<br>（2）在构造器中<br>（3）在代码块中</p></li><li><p>如果final修饰的属性是静态的，则赋初值的位置只能是<br>（1）定义时<br>（2）在静态代码块中<br>不能在构造器中赋值</p></li><li><p>final 类不能被继承，但能实例化对象</p></li><li><p>如果类不是 final 类，但是含有 final 类方法，则该方法虽然不能被重写，但是可以被继承</p></li><li><p>一般来说，如果一个类已经是 final 类了，就没有必要再将方法修饰成 final 方法</p></li><li><p>final 不能修饰构造器</p></li><li><p>final 和 static 往往搭配使用，用于在希望不进行类加载的情况下访问某个类的静态属性，这样会使效率更高，因为底层编译器对此做了优化</p></li><li><p>包装类和 String 也是 final 类</p></li></ul></li></ul><h3 id="10-6-抽象类">10.6 抽象类</h3><ul><li><p>为何需要？</p><ul><li>在继承中，当父类的某些方法需要声明，但又不确定如何实现时，可以将其声明为抽象方法，该类成为抽象类</li></ul></li><li><p>介绍</p><ul><li><p>用abstract关键字来修饰一个类时，这个类就叫抽象类</p></li><li><p>用abstract关键字来修饰一个方法时，这个方法就是抽象方法<br>语法：访问修饰符 abstract 返回数据类型 方法名(参数列表)；</p></li><li><p>抽象类的价值更多在于设计，用于明晰子类所具有的方法和属性，并解决代码冗余问题</p></li><li><p>抽象类在框架和设计模式使用较多</p></li></ul></li><li><p>使用注意事项和细节讨论</p><ul><li><p>抽象类不能被实例化</p></li><li><p>抽象类不一定要包含抽象方法，也就是说抽象类可以没有抽象方法</p></li><li><p>一旦类包含了抽象方法，则这个类必须声明为抽象类</p></li><li><p>abstract关键字只能修饰类和方法，不能修饰属性和其他的</p></li><li><p>抽象类可以有任意成员【即抽象类的本质还是类，满足类的性质】</p></li><li><p>抽象方法不能有方法体（{}和其中的语句)，即不能实现</p></li><li><p>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为抽象类</p></li><li><p>抽象方法不能使用private，final和static修饰，因为这些关键字与重写相违背</p></li></ul></li></ul><h3 id="10-7-抽象类最佳实践：模板设计模式">10.7 抽象类最佳实践：模板设计模式</h3><ul><li><p>Best Practice 模板设计模式</p><ul><li><p>基本介绍</p><ul><li>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式</li></ul></li><li><p>能解决的问题</p><ul><li><p>当功能内部一部分实现时确定的，一部分时不确定的时，可以把不确定的部分暴露出去，让子类来实现</p></li><li><p>编写一个抽象父类，提供多个子类的通用方法，并把一个或多个方法留给其子类实现，这就是一种模板模式</p></li></ul></li></ul></li></ul><h3 id="10-8-接口">10.8 接口</h3><ul><li><p>基本介绍</p><ul><li>接口就是给出一些没有实现的方法，封装到一起，当某个类要使用的时候，再根据具体情况把这些方法写出来</li></ul></li><li><p>语法</p><ul><li><p>interface 接口名{<br>//属性<br>//抽象方法<br>}</p></li><li><p>class 类名 implements 接口{<br>//自己属性<br>//自己方法<br>//必须实现的接口的抽象方法<br>}</p></li></ul></li><li><p>深入理解接口</p><ul><li><p>接口可用于设计规范，便于多人协作开发完成后将各个类组合起来使用</p></li><li><p>接口可以用来设计框架，明晰软件骨架</p></li></ul></li><li><p>注意事项和细节</p><ul><li><p>接口不能被实例化</p></li><li><p>接口中所有方法都是public方法，接口中的抽象方法可以不用abstract修饰</p></li><li><p>一个普通类实现接口，就必须将该接口的所有方法都实现</p></li><li><p>抽象类实现接口，可以不用实现接口的方法</p></li><li><p>一个类可以实现多个接口</p></li><li><p>接口中的属性，只能时final的，而且隐含public static final三个修饰符</p></li><li><p>接口中属性的访问方式：接口名.属性名</p></li><li><p>接口不能继承其他类，但是可以继承【多个】别的接口</p></li><li><p>接口的修饰符只能是public和默认，与类相同</p></li><li><p>1实现接口和继承类是同一层次的行为，如果一个类即继承了其他类，又实现了接口，父类和接口中存在同名属性时，在访问时就会产生混淆，所以必须指明是访问接口名.属性名还是super.属性名</p></li></ul></li><li><p>实现类vs继承接口</p><ul><li><p>继承：当子类继承了父类，就自动地拥有父类的功能<br>实现接口：如果子类需要扩展功能，可以通过实现接口的方式扩展<br>可以理解成：实现接口是对Java单继承机制的一种补充</p></li><li><p>接口和继承解决的问题不同</p><ul><li><p>继承的价值主要在于：解决代码的复用性和可维护性</p></li><li><p>接口的价值主要在于：设计好各种规范（方法），让其他类去实现这些方法，更加灵活</p></li><li><p>接口比继承更加灵活，继承要满足is-a关系，接口只需满足like-a关系</p></li><li><p>接口在一定程度上可实现代码解耦（接口规范性+动态绑定机制）</p></li></ul></li></ul></li><li><p>接口的多态特性</p><ul><li><p>多态参数</p><ul><li>即方法的参数可以用接口数据类型的参数指向实现了该接口的类的对象，并在运行时动态绑定</li></ul></li><li><p>多态数组</p><ul><li>用法同前多态数组</li></ul></li><li><p>多态传递</p><ul><li>如果接口继承了其他接口，则可以用父类接口数据类型指向实现了子接口的类的对象，这称为接口的多态传递</li></ul></li></ul></li></ul><h3 id="10-9内部类">10.9内部类</h3><ul><li><p>基本介绍</p><ul><li>一个类的内部又完整地嵌套了另一个类结构，则被嵌套的类称为内部类，嵌套其的类称为外部类。内部类是类的第五大成员。内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系</li></ul></li><li><p>基本语法</p><ul><li>class Outer{<br>class Inner{<br>}<br>}</li></ul></li></ul><p>class Other{<br>}</p><ul><li><p>分类</p><ul><li><p>定义在外部类局部位置上（方法内和代码块内）</p><ul><li><p>局部内部类（有类名）</p></li><li><p>匿名内部类（无类名）</p></li></ul></li><li><p>定义在外部类的成员位置上（即定义类成员的地方）</p><ul><li><p>成员内部类（无static修饰）</p></li><li><p>静态内部类（有static修饰）</p></li></ul></li></ul></li><li><p>局部内部类</p><ul><li><p>使用</p><ul><li><p>可以直接访问外部类的所有成员，包括私有</p></li><li><p>不能添加访问修饰符，因为它的地位就是一个局部变量，局部变量是不能使用修饰符的。但可以用final修饰，因为局部变量也可以用</p></li><li><p>作用域：仅仅在定义它的方法或代码块中</p></li><li><p>局部内部类访问外部类成员，直接访问</p></li><li><p>外部类访问局部内部类成员，通过创建对象访问</p></li><li><p>外部其他类不能访问局部内部类</p></li><li><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）来访问</p></li><li><p>局部内部类本质仍然是一个类，所以适用于类的规定和特性</p></li></ul></li></ul></li><li><p>匿名内部类</p><ul><li><p>理解</p><ul><li><p>本质是类</p></li><li><p>是内部类</p></li><li><p>该类没有名字</p></li><li><p>同时还是一个对象</p></li></ul></li><li><p>语法</p><ul><li>new 类或接口(参数列表){<br>类体<br>};</li></ul></li><li><p>为何需要</p><ul><li>在某些场景中，我们想使用一个接口并实现该接口并创建对象调用方法。使用传统方法会造成资源浪费，当只需使用一次该类时，就可以用内部匿名类来简化开发</li></ul></li><li><p>基于接口的匿名内部类</p><ul><li><p>语法：<br>接口名 对象引用 = new 接口(){<br>类体<br>};</p><ul><li>相当于定义一个实现了该接口的匿名内部类，类体为实现内容</li></ul></li><li><p>底层细节</p><ul><li>在执行new 接口(){};时，等价于执行class 外部类名$1234… implements 接口{};并立马创建了匿名内部类的实例返回给对象引用，随后这个匿名内部类就被销毁，即不能在后续代码中再通过new 外部类名$1234… 来创建新的对象实例</li></ul></li></ul></li><li><p>基于类的匿名内部类</p><ul><li><p>语法：<br>父类名 对象引用 = new 类(参数列表){<br>类体<br>};</p><ul><li>相当于定义一个继承了该类的匿名内部类，类体为继承后的子类的特有内容或重写方法，参数列表中的参数传递给父类的构造器（如果有有参的话）</li></ul></li><li><p>底层细节同上</p></li></ul></li><li><p>细节</p><ul><li><p>匿名内部类的语法比较奇特，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征</p></li><li><p>可以直接访问外部类的所有成员，包括私有</p></li><li><p>不能添加访问修饰符，因为它的地位就是一个局部变量</p></li><li><p>作用域：仅仅在定义它的方法或代码块中</p></li><li><p>匿名内部类访问外部类成员，直接访问</p></li><li><p>外部类访问匿名内部类成员，不能访问</p></li><li><p>外部其他类访问匿名内部类，不能访问</p></li><li><p>如果外部类和匿名内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）来访问</p></li></ul></li><li><p>Best Practice</p><ul><li><p>将匿名内部类当作实参直接传递，简洁高效省资源</p></li><li><p>f1(new IL() {<br>@Override<br>public void show() {<br>System.out.println(“这是一副名画~~…”);<br>}<br>});</p></li></ul></li></ul></li><li><p>成员内部类</p><ul><li><p>定义：成员内部类时定义在外部类成员位置，并且没有static修饰的类</p></li><li><p>细节</p><ul><li><p>可以直接访问外部类的所有成员，包括私有的</p></li><li><p>可以添加任意访问修饰符，因为它的地位就是一个成员</p></li><li><p>作用域是整个外部类</p></li><li><p>成员内部类访问外部类成员，直接访问</p></li><li><p>外部类访问成员内部类，先创建对象再访问</p></li><li><p>外部其他类访问成员内部类有两种方式</p><ul><li><p>把new 内部类当作外部类的成员<br>Outer08 outer08 = new Outer08();<br>Outer08.Inner08 inner08 = outer08.new Inner08();</p></li><li><p>在外部类中编写一个方法，返回内部类的对象<br>public Inner08 getInner08Instance(){<br>return new Inner08();<br>}</p></li></ul></li><li><p>如果外部类和成员内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）来访问</p></li></ul></li></ul></li><li><p>静态内部类</p><ul><li><p>定义：静态内部类是定义在外部类的成员位置，并且有static修饰的类</p></li><li><p>细节</p><ul><li><p>可以直接访问外部类的所有静态成员，包括私有，但不能访问非静态成员</p></li><li><p>可以添加任意访问修饰符，因为它的地位就是一个成员</p></li><li><p>作用域：整个外部类</p></li><li><p>静态内部类访问外部类静态成员，直接访问</p></li><li><p>外部类访问静态内部类成员，先创建对象，再访问</p></li><li><p>外部其他类访问静态内部类成员，有两种方式</p><ul><li><p>因为静态内部类，是可以通过类名直接访问(前提是满足访问权限)<br>Outer10 outer10 = new Outer10();<br>Outer10.Inner10 inner10 = new Outer10.Inner10();</p></li><li><p>编写一个方法，可以返回静态内部类的对象实例<br>public static Inner10 getInner10_() {<br>return new Inner10();<br>}</p></li></ul></li></ul></li></ul></li></ul><h2 id="第十一章：枚举和注解">第十一章：枚举和注解</h2><h3 id="枚举enumeration">枚举enumeration</h3><ul><li><p>应用场景</p><ul><li>当定义的类中只客观存在几个有限的对象（比如季节）时，可以考虑将其设计为枚举类</li></ul></li><li><p>枚举说明</p><ul><li><p>枚举是一组常量的集合</p></li><li><p>可以这样理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象</p></li></ul></li><li><p>两种实现方法</p><ul><li><p>自定义类实现枚举</p><ul><li><p>步骤</p><ul><li><p>将构造器私有化，防止直接new新对象</p></li><li><p>本类内部创建一组对象供其他类调用</p></li><li><p>对外暴露对象（通过为对象添加public static final修饰符）</p></li><li><p>可以提供get方法获得对象属性，但不要提供set方法</p></li></ul></li></ul></li><li><p>使用enum关键字实现枚举</p><ul><li><p>步骤</p><ul><li><p>使用关键字enum替代class</p></li><li><p>区别于写public static final Season SPRING = new Season(“春天”, “温暖”);<br>可以直接写SPRING(“春天”，“温暖”)，相当于系统帮你补充成了上面那一长串</p></li><li><p>如果枚举类中有多个对象，用“,&quot;间隔即可，最后加上”;“</p></li><li><p>如果使用enum来实现枚举，确保在类的最前面定义创建常量对象</p></li><li><p>如果使用无参构造器创建常量对象，则括号可以省略</p></li><li><p>其他成员比如属性、构造器、方法都可以自行添加以丰富对象的使用</p></li></ul></li><li><p>注意事项</p><ul><li><p>当我们使用enum关键字来开发一个枚举类时，默认会继承Enum类，而且会将我们自己的类设为final类，不能再被继承</p></li><li><p>传统的 public static final Season2 SPRING = new Season2(“春天”, “温暖”);                        简化成SPRING(“春天”, “温暖”)， 这里必<br>须知道，它调用的是哪个构造器</p></li><li><p>如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略</p></li><li><p>当有多个枚举对象时，使用&quot;,&quot;间隔，最后由一个分号结尾</p></li><li><p>枚举对象必须放在枚举类的行首</p></li></ul></li><li><p>继承自Enum的常用方法有哪些</p><ul><li><p>toString</p><ul><li>Enum 类已经重写过了，返回的是当前对象<br>名,子类可以重写该方法，用于返回对象的属性信息</li></ul></li><li><p>name</p><ul><li>返回当前对象名（常量名），子类中不能重写</li></ul></li><li><p>ordinal</p><ul><li>返回当前对象的位置号，默认从 0 开始<br>位置号即为定义时的顺序号</li></ul></li><li><p>values</p><ul><li>返回当前枚举类中所有的常量（对象），是一个对象数组</li></ul></li><li><p>valueOf</p><ul><li>将字符串转换成枚举对象，要求字符串必须<br>为已有的常量名，否则报异常！<br>即搜索特定名字的枚举对象，搜不到的话就报错</li></ul></li><li><p>compareTo</p><ul><li>比较两个枚举常量，比较的就是位置号<br>返回前一个对象的位置号 - 后一个对象的位置号</li></ul></li></ul></li></ul></li><li><p>enum实现接口</p><ul><li><p>使用enum关键字后，就不能再继承其他类了，因为已经隐式继承Enum，而Java是单继承机制</p></li><li><p>enum实现的类本质上还是类，所以可以实现接口</p></li></ul></li></ul></li></ul><h3 id="注解">注解</h3><ul><li><p>理解</p><ul><li><p>注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息</p></li><li><p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息</p></li><li><p>在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角<br>色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML配置等</p></li></ul></li><li><p>基本注解的介绍</p><ul><li><p>@Override</p><ul><li><p>限定某个方法是重写父类方法，该注解只能用于方法</p></li><li><p>使用说明</p><ul><li><p>@Override表示指定重写父类的方法（从编译层面验证），如果父类没有其重写的方法，则会报错</p></li><li><p>如果不写@Override注解，仍然可以重写父类方法</p></li><li><p>@Override只能修饰方法</p></li><li><p>@Target是修饰注解的注解，称为元注解</p></li></ul></li></ul></li><li><p>@Deprecated</p><ul><li><p>用于表示某个程序元素（类、方法等）已过时</p></li><li><p>可以修饰方法、类、字段、包、参数等等</p></li><li><p>@Deprecated可以起到帮助新旧版本的兼容和过渡的作用</p></li></ul></li><li><p>@SuppressWarnings</p><ul><li><p>抑制编译器警告</p></li><li><p>当我们不希望看到某种警告的时候，可以使用@SuppressWarnings来抑制（不显示）警告信息</p></li><li><p>在{”“}中，可以写入你希望抑制的警告信息</p></li><li><p>可以指定的警告类型有</p><ul><li>// all，抑制所有警告<br>// boxing，抑制与封装/拆装作业相关的警告<br>//cast，抑制与强制转型作业相关的警告<br>//dep-ann，抑制与淘汰注释相关的警告<br>//deprecation，抑制与淘汰的相关警告<br>//fallthrough，抑制与 switch 陈述式中遗漏 break 相关的警告<br>//finally，抑制与未传回 finally 区块相关的警告<br>//hiding，抑制与隐藏变数的区域变数相关的警告<br>//incomplete-switch，抑制与 switch 陈述式(enum case)中遗漏项目相关的警告<br>//javadoc，抑制与 javadoc 相关的警告<br>//nls，抑制与非 nls 字串文字相关的警告<br>//null，抑制与空值分析相关的警告<br>//rawtypes，抑制与使用 raw 类型相关的警告<br>//resource，抑制与使用 Closeable 类型的资源相关的警告<br>//restriction，抑制与使用不建议或禁止参照相关的警告<br>//serial，抑制与可序列化的类别遗漏 serialVersionUID 栏位相关的警告<br>//static-access，抑制与静态存取不正确相关的警告<br>//static-method，抑制与可能宣告为 static 的方法相关的警告<br>//super，抑制与置换方法相关但不含 super 呼叫的警告<br>//synthetic-access，抑制与内部类别的存取未最佳化相关的警告<br>//sync-override，抑制因为置换同步方法而遗漏同步化的警告<br>//unchecked，抑制与未检查的作业相关的警告<br>//unqualified-field-access，抑制与栏位存取不合格相关的警告<br>//unused，抑制与未用的程式码及停用的程式码相关的警告</li></ul></li><li><p>作用范围与放置的位置相关</p><ul><li><p>放置在方法上，则范围就是该方法</p></li><li><p>防止在类上，就是整个类</p></li></ul></li></ul></li></ul></li></ul><h3 id="元注解">元注解</h3><ul><li><p>Retention</p><ul><li>指定注解的范围：SOURCE, CLASS, RUNTIME</li></ul></li><li><p>Target</p><ul><li>指定注解可以在哪些地方使用</li></ul></li><li><p>Documented</p><ul><li>指定该注解是否会在javadoc体现</li></ul></li><li><p>Inherited</p><ul><li>使用后子类会继承父类的注解</li></ul></li></ul><h2 id="第十二章：异常-Exception">第十二章：异常-Exception</h2><h3 id="12-1-引出">12.1 引出</h3><ul><li>为了防止程序运行过程和编译过程可能导致程序崩溃的不是特别重要的代码段使程序崩溃而使程序功能无法执行，引入异常处理机制，即使发生了异常，程序也可以继续执行</li></ul><h3 id="12-2-异常介绍">12.2 异常介绍</h3><ul><li><p>基本概念</p><ul><li>Java语言中，将程序执行中发生的不正常情况称为“异常”（开发过程中的语法错误和逻辑错误不是异常）</li></ul></li><li><p>分类</p><ul><li><p>错误Error</p><ul><li>Java虚拟机无法解决的严重问题。例如JVM系统内部错误，资源耗尽（stackoverflow栈溢出和OOM out of memory）。Error是严重错误，程序会崩溃</li></ul></li><li><p>异常Exception</p><ul><li>其他因变成错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等。Exception分为两大类：运行时异常（程序运行时发生的异常）和编译时异常（编译时，编译器检查出的异常）</li></ul></li></ul></li></ul><h3 id="12-3-异常体系图">12.3 异常体系图</h3><ul><li></li><li><p>小结</p><ul><li><p>异常分为两大类，运行时异常和编译时异常</p></li><li><p>运行时异常，编译器检查不出来。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常</p></li><li><p>对于运行时异常，可以不做处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响</p></li><li><p>编译时异常，是编译器要求必须处置的异常</p></li></ul></li></ul><h3 id="12-4-常见的运行时异常">12.4 常见的运行时异常</h3><ul><li><p>NullPointerException</p></li><li><p>ArithmeticException</p></li><li><p>ArrayIndexOutOfBoundsException</p></li><li><p>ClassCastException</p></li><li><p>NumberFormatException</p></li></ul><h3 id="12-5-编译异常">12.5 编译异常</h3><ul><li><p>介绍</p><ul><li>编译异常是指在编译期间，就必须处理的异常，否则代码不能通过编译</li></ul></li><li><p>常见的编译异常</p><ul><li><p>SQLException操作数据库时，查询表可能发生的异常</p></li><li><p>IOException操作文件时，发生的异常</p></li><li><p>FileNotFoundException当操作一个不存在的文件时，发生异常</p></li><li><p>ClassNotFoundException加载类，而该类不存在时，发生异常</p></li><li><p>EOFException操作文件，到文件末尾，发生异常</p></li><li><p>IllegalArgumentException参数异常</p></li></ul></li></ul><h3 id="12-6-异常处理">12.6 异常处理</h3><ul><li><p>基本介绍</p><ul><li>异常处理就是当异常发生时，对异常处理的一些方式</li></ul></li><li><p>方式</p><ul><li><p>try-catch-finally<br>程序员在代码中捕获发生的异常，再自行处理</p><ul><li></li></ul></li><li><p>throws<br>将发生的异常抛出给调用者，交给调用者（方法）来处理，最顶级的处理者是JVM</p><ul><li></li></ul></li></ul></li></ul><h3 id="12-7-try-catch异常处理">12.7 try-catch异常处理</h3><ul><li><p>说明</p><ul><li>Java提供try和catch块来处理异常。try块用于包含可能出错的代码。catch块用于处理try块中发生的异常。可以根据需要在程序中有多个try…catch块</li></ul></li><li><p>基本语法</p><ul><li>try{<br>//可疑代码<br>}catch (异常名 e){<br>//对异常的处理<br>}</li></ul></li><li><p>注意事项</p><ul><li><p>如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块</p></li><li><p>如果异常没有发生，则顺序执行try代码块，不会进入到catch</p></li><li><p>如果希望不管是否发生异常，都执行某段代码（比如关闭连接，释放资源等），则使用finally代码块</p></li><li><p>可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求父类异常在后，子类异常在前，如果发生异常，只会匹配一个catch</p></li><li><p>可以try-finally配合使用，这种用法相当于没有捕获异常，因此程序发生异常会直接崩溃。应用场景：执行一代代码，不管是否发生异常，都必须执行某个业务逻辑</p></li></ul></li><li><p>小结</p><ul><li><p>如果没有出现异常，则执行try块中所有语句，不执行catch块中语句，如果有finally，最后还要执行finally里面的语句</p></li><li><p>如果出现异常，则try块中异常发生后，try块剩下的语句不在执行。将执行catch语句块中的语句，如果有finally，最后还需要执行finally里面的语句</p></li></ul></li></ul><h3 id="12-8-throws异常处理">12.8 throws异常处理</h3><ul><li><p>基本介绍</p><ul><li><p>如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</p></li><li><p>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p></li></ul></li><li><p>注意事项和使用细节</p><ul><li><p>对于编译异常，程序中必须处理，要么try-catch，要么throws</p></li><li><p>对于运行时异常，程序中如果没有处理，默认是throws方法处理</p></li><li><p>子类重写父类方法时，对抛出异常的规定：子类重写的方法所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出异常类型的子类</p></li><li><p>在throws过程中，如果有方法try-catch，就相当于处理异常，则可以不必throws</p></li></ul></li></ul><h3 id="12-9-自定义异常">12.9 自定义异常</h3><ul><li><p>基本概念</p><ul><li>当程序中出现了某些“错误”，但该错误并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息</li></ul></li><li><p>自定义异常步骤</p><ul><li><p>定义类，class 异常类名 extends Exception或者RuntimeException</p></li><li><p>如果继承Exception，则属于编译时异常</p></li><li><p>如果继承RuntimeException，属于运行时异常（一般都继承RuntimeException）</p></li></ul></li></ul><h3 id="12-10-throw和throws的区别">12.10 throw和throws的区别</h3><ul><li><p>一览表</p><ul><li></li></ul></li></ul><h2 id="第十三章：常用类">第十三章：常用类</h2><h3 id="13-1-包装类">13.1 包装类</h3><ul><li><p>包装类的分类</p><ul><li><p>针对八种基本数据类型相应的引用类型-包装类</p></li><li><p>有了类的特点，就可以调用类中的方法</p></li><li><p>八大包装类的类继承关系</p><ul><li></li></ul></li></ul></li><li><p>包装类和基本数据的转换</p><ul><li><p>JDK5之前是手动装箱和拆箱<br>手动装箱：int n1 = 100;<br>Integer integer = new Integer(n1);<br>Integer integer1 = Integer.valueOf(n1）<br>手动拆箱：int i = integer.intValue()</p></li><li><p>JDK5（含）以后，是自动装箱和拆箱方式<br>自动装箱：int n2 = 200；<br>Integer integer2 = n2; //底层使用的是 Integer.valueOf(n2)<br>自动拆箱：int n3 = integer2; //底层仍然使用的是 intValue()方法</p></li><li><p>自动装箱底层调用的是valueOf方法，拆箱调用的是typeValue方法</p></li><li><p>其他包装类的用法类似，不一一举例</p></li></ul></li><li><p>包装类型和String类型的相互转换</p><ul><li><p>方式1：String str1 = i + “”;（i为包装类型）</p></li><li><p>方式2：String str2 =i.toString();<br>调用包装类的toString方法</p></li><li><p>方式3：String str3 = String.valueOf(i);<br>调用包装类的valueOf方法</p></li></ul></li><li><p>Integer类和Character类常用方法</p><ul><li><p>Integer</p><ul><li><p>MIN_VALUE返回Integer类型的最小值</p></li><li><p>MAX_VALUE返回Integer类型的最大值</p></li></ul></li><li><p>Character</p><ul><li><p>isDigit判断是否是数字</p></li><li><p>isLetter判断是否是字母</p></li><li><p>isUpperCase判断是否是大写</p></li><li><p>isLowerCase判断是否是小写</p></li><li><p>isWhitespace判断是否是空格</p></li><li><p>toUpperCase转成大写</p></li><li><p>toLowerCase转成小写</p></li></ul></li></ul></li><li><p>Integer类自动装箱的特性</p><ul><li><p>//1. 如果 i 在 IntegerCache.low(-128)~IntegerCache.high(127),就直接从数组返回<br>//2. 如果不在 -128~127,就直接 new Integer()</p></li><li><p>比如</p><ul><li><p>Integer i = new Integer;<br>Integer j = new Integer;<br>System.out.println(i == j);// False</p></li><li><p>Integer m = 1; //底层 Integer.valueOf; -&gt; 阅读源码<br>Integer n = 1;//底层 Integer.valueOf;<br>System.out.println(m == n); // True</p></li></ul></li><li><p>如果包装类和对应的基本数据类型比较大小，则比较的是值，不是地址</p></li></ul></li></ul><h3 id="13-2-String类">13.2 String类</h3><ul><li><p>String类的理解和创建对象</p><ul><li><p>理解</p><ul><li><p>String对象用于保存字符串，也就是一组字符序列</p></li><li><p>字符串常量是用双引号括起的字符序列</p></li><li><p>字符串的字符使用Unicode字符编码，一个字符（不区分是字母还是汉字）占两个字节</p></li><li><p>String类有很多构造器，构造器的重载，常用的有<br>//String s1 = new String();<br>//String s2 = new String(String original);<br>//String s3 = new String(char[] a);<br>//String s4 = new String(char[] a,int startIndex,int count)<br>//String s5 = new String(byte[]</p></li></ul></li><li><p>String类实现了接口Serializable（String可以串行化：可以在网络传输）<br>实现了接口Comparable（String对象可以比较大小）</p></li><li><p>String是final类，不能被其他类继承</p></li><li><p>String有属性private final char value[]，用于存放字符串常量的地址</p></li><li><p>一定要注意：value是一个final类型，不可以被修改，即value不能指向新的地址，但是可以修改value指向的地址中的内容</p></li></ul></li><li><p>创建String对象的两种方式</p><ul><li><p>方式1：直接赋值String s = “xxx”;</p></li><li><p>方式2：调用构造器String s = new String(“xxx”);</p></li><li><p>区别</p><ul><li><p>方式一：先从常量池查看是否有&quot;xxx&quot;数据空间，如果有，直接让s指向该数据空间；如果没有，则创建，然后让s指向。s最终指向的是常量池的空间地址</p></li><li><p>方式二：先在堆中创建空间，里面维护了value属性，指向常量池的&quot;xxx&quot;空间。如果常量池中没有&quot;xxx&quot;，则创建，再让value指向。最终s指向的是堆中value所存储的地址，通过value指向常量池中的字符串</p></li></ul></li><li><p>内存布局</p><ul><li></li></ul></li></ul></li></ul><h3 id="13-3-字符串的特性">13.3 字符串的特性</h3><ul><li><p>String是一个final类，代表不可变的字符序列</p></li><li><p>字符串是不可变的。一个字符串对象一旦被分配，其指向内容是不可变的。改变指向对象实际上是新创建了一个String对象再重新指向该String对象</p></li><li><p>直接String s = “abc” + “efg&quot;会被优化成<br>String s = “abcefg”，不会分别创建&quot;abc&quot;和&quot;efg”，而只创建&quot;abcefg&quot;<br>所以只创建1个对象</p></li><li><p>String a = “1”;<br>String b = “2”;<br>String c = a + b;</p><ul><li>底层是创建StringBuilder sb = new StringBuilder(); sb.append(a); sb.append(b)<br>来创建String对象的</li></ul></li><li><p>intern方法返回的是常量池中字符串常量的地址</p></li></ul><h3 id="13-4-String类的常用方法">13.4 String类的常用方法</h3><ul><li><p>小说明</p><ul><li>String类是保存字符串常量的，每次更新都需要重新开辟空间，效率较低，因此Java设计者还提供了StringBuilder和StringBuffer来增强String的功能，并提高效率</li></ul></li><li><p>equals</p><ul><li>判断字符串内容是否相等，区分大小写</li></ul></li><li><p>equalsIgnoreCase</p><ul><li>不区分大小写，判断字符串内容是否相等</li></ul></li><li><p>length</p><ul><li>获取字符串的长度，即字符的个数</li></ul></li><li><p>indexOf</p><ul><li>获取某个字符（串）在字符串中第一次出现位置的索引，索引从0开始，找不到则返回-1</li></ul></li><li><p>lastIndexOf</p><ul><li>获取某个字符（串）在字符串中最后一次出现位置的索引，索引从0开始，找不到则返回-1</li></ul></li><li><p>substring</p><ul><li>截取指定范围内的子串</li></ul></li><li><p>trim</p><ul><li>前后去空格</li></ul></li><li><p>charAt</p><ul><li>获取某索引处的字符，注意不能用s[index]这种方式来获取</li></ul></li><li><p>toUpperCase</p><ul><li>转成大写</li></ul></li><li><p>toLowerCase</p><ul><li>转成小写</li></ul></li><li><p>concat</p><ul><li>拼接另一个字符串到此字符串</li></ul></li><li><p>replace</p><ul><li>替换字符串中的所有某个字符（串）为某个字符（串），返回替换后的字符串</li></ul></li><li><p>split</p><ul><li>分割字符串，以某个字符为分割线，逢此字符就分割，返回一个字符串数组</li></ul></li><li><p>compareTo</p><ul><li><p>比较两个字符串的大小</p><ul><li><p>如果长度相同，并且每个字符也相同，就返回0</p></li><li><p>如果长度相同或不相同，但在比较时可以区分大小，就返回if (c1 != c2) {<br>return c1 - c2;<br>}</p></li><li><p>如果前面的部分都相同，就返回str1.length - str2.length</p></li></ul></li></ul></li><li><p>toCharArray</p><ul><li>返回字符串的字符数组</li></ul></li><li><p>format</p><ul><li>格式化字符串，格式化形式类似于C语言的输出语句的格式化字符串形式，返回格式化后的字符串。静态方法</li></ul></li></ul><h3 id="13-5-StringBuffer类">13.5 StringBuffer类</h3><ul><li><p>基本介绍</p><ul><li><p>StringBuffer代表可变的字符序列，可以对字符串内容进行增删</p></li><li><p>很多方法与String相同，但StringBuffer是可变长度的</p></li><li><p>StringBuffer是一个容器</p></li><li><p>类继承关系</p><ul><li><p>直接父类是AbstractStringBuilder</p></li><li><p>实现了Serializable，即StringBuffer对象可以串行化</p></li><li><p>在父类AbstractStringBuilder类中有属性char[] value，但不是final，示意可以改变</p><ul><li>该value数组存放字符串内容，存放在堆中</li></ul></li><li><p>StringBuffer是final类，不可被继承</p></li><li><p>因为StringBuffer字符内容是存储在char[] value中，所以改变字符串内容是不用每次都更换地址，所以效率高于String</p></li></ul></li></ul></li><li><p>String和StringBuffer比较</p><ul><li><p>String保存的是字符串常量，里面的值不能更改，每次Sting类的更新实际上是创建新对象并更改地址，效率较低</p></li><li><p>StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上是更新内容，不用更新地址，效率较高</p></li></ul></li><li><p>String和StringBuffer的相互转换</p><ul><li><p>String转StringBuffer</p><ul><li><p>使用构造器</p><ul><li>StringBuffer stringBuffer = new StringBuffer(str)；</li></ul></li><li><p>使用append方法</p><ul><li>StringBuffer stringBuffer1 = new StringBuffer();<br>stringBuffer1 = stringBuffer1.append(str)；</li></ul></li></ul></li><li><p>StringBuffer转String</p><ul><li><p>使用StringBuffer类的toString方法</p><ul><li>String s = stringBuffer3.toString；</li></ul></li><li><p>使用构造器</p><ul><li>String s1 = new String(stringBuffer);</li></ul></li></ul></li></ul></li><li><p>常用方法</p><ul><li><p>增</p><ul><li><p>append</p><ul><li>可以追加整数型，布尔型，浮点型，会被转换成字符串</li></ul></li></ul></li><li><p>删</p><ul><li><p>delete</p><ul><li>删除索引为[start, end)范围的字符</li></ul></li></ul></li><li><p>改</p><ul><li><p>replace</p><ul><li>使用字符串&quot;xxx&quot;替换索引[start, end)范围的字符</li></ul></li></ul></li><li><p>插</p><ul><li><p>insert</p><ul><li>在索引x处插入内容，x索引原内容后移</li></ul></li></ul></li></ul></li></ul><h3 id="13-6-StringBuilder类">13.6 StringBuilder类</h3><ul><li><p>基本介绍</p><ul><li><p>StringBuilder是一个可变的字符序列类。此类提供一个与StringBuffer兼容的API，但不保证同步（不是线程安全）。该类被设计用作StringBuffer的一个简易替换，用于字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer还快</p></li><li><p>在StringBuilder对象上的主要操作是append方法和insert方法，可重载这些方法，以接收任意类型的数据</p></li><li><p>类继承关系</p><ul><li>与StringBuffer一样</li></ul></li></ul></li><li><p>常用方法</p><ul><li>与StringBuffer一样</li></ul></li><li><p>String、StringBuffer 和 StringBuilder 的比较</p><ul><li><p>StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样</p></li><li><p>String：不可变字符序列，效率低，但复用率高</p></li><li><p>StringBuffer：可变字符序列，效率较高，线程安全</p></li><li><p>StringBuilder：可变字符序列，效率最高，线程不安全</p></li><li><p>String使用注意说明：<br>String s = “a”;<br>s += “b”;实际上原来的&quot;a&quot;字符串对象已经被丢弃了，现在又产生了一个字符串&quot;ab&quot;，如果多次执行这些改变串内容的操作，会导致大量的副本字符串对象留存在内容中，降低效率，如果这样的操作放到循环中，会极大影响程序的性能<br>于是===》如果有要对字符串内容做大量修改，不要使用String类</p></li></ul></li><li><p>String、StringBuffer 和 StringBuilder 的选择</p><ul><li><p>使用的原则</p><ul><li><p>如果字符串存在大量的修改操作，一般使用StringBuffer和StringBuilder</p></li><li><p>如果字符串存在大量的修改操作，并在单线程的情况，一般使用StringBuilder</p></li><li><p>如果字符串存在大量的修改操作，并在多线程的情况，一般使用StringBuffer</p></li><li><p>如果字符串很少修改，被多个对象引用，使用String，比如配置信息等情况</p></li></ul></li></ul></li></ul><h3 id="13-7-Math类">13.7 Math类</h3><ul><li><p>Math类包含用于执行基本数学运算的方法，比如初等指数，对数，平方根和三角函数</p></li><li><p>基本方法</p><ul><li><p>abs</p><ul><li>绝对值</li></ul></li><li><p>pow</p><ul><li>幂</li></ul></li><li><p>ceil</p><ul><li>向上取整</li></ul></li><li><p>floor</p><ul><li>向下取整</li></ul></li><li><p>round</p><ul><li>四舍五入</li></ul></li><li><p>sqrt</p><ul><li>平方根</li></ul></li><li><p>random</p><ul><li><p>随机[0,1)之间的数</p><ul><li><p>返回[a,b]之间的整数，用random实现</p><ul><li>(int)(a + Math.random() * (b-a +1) )</li></ul></li></ul></li></ul></li><li><p>min, max</p><ul><li>两个数中的最大值和最小值</li></ul></li></ul></li></ul><h3 id="13-8-Arrays类">13.8 Arrays类</h3><ul><li><p>包含一系列静态常用方法</p><ul><li><p>toString</p><ul><li>返回数组的字符串形式</li></ul></li><li><p>sort</p><ul><li><p>自然排序</p><ul><li>从小到大排序数组元素</li></ul></li><li><p>定制排序</p><ul><li><p>可选择是从小到大还是从大到小</p><ul><li><p>Arrays.sort(arr, new Comparator() {<br>@Override<br>public int compare(Object o1, Object o2) {<br>Integer i1 = (Integer) o1;<br>Integer i2 = (Integer) o2;<br>return i2 - i1;<br>}<br>});</p></li><li><p>接口编程</p></li></ul></li></ul></li></ul></li><li><p>binarySearch</p><ul><li>二分搜索法，需要数组是有序的</li></ul></li><li><p>copyOf</p><ul><li><p>从原数组的开头拷贝x个元素到新数组中，返回新数组</p></li><li><p>如果拷贝的长度大于原数组的长度，则在新数组后加null</p></li><li><p>如果拷贝长度小于0，抛异常NegativeArraySizeException</p></li></ul></li><li><p>fill</p><ul><li><p>数组元素填充</p><ul><li>用某个数去填充数组中的所有元素</li></ul></li></ul></li><li><p>equals</p><ul><li>判断两个数组的内容是否完全一致</li></ul></li><li><p>asList</p><ul><li><p>将数组转换成一个List集合</p><ul><li><p>返回的 asList 编译类型是List(接口)</p></li><li><p>asList 运行类型是java.util.Arrays#ArrayList, 是 Arrays 类的<br>静态内部类 private static class ArrayList<E> extends AbstractList<E><br>implements RandomAccess, java.io.Serializable</p></li></ul></li></ul></li></ul></li></ul><h3 id="13-9-System类">13.9 System类</h3><ul><li><p>类常用静态方法</p><ul><li><p>exit</p><ul><li>退出当前程序</li></ul></li><li><p>arraycopy</p><ul><li><p>复制数组元素，适合底层调用，一般不用</p></li><li><p>五个参数</p><ul><li>// src：源数组<br>// srcPos：从源数组的哪个索引位置开始拷贝<br>// dest : 目标数组，即把源数组的数据拷贝到哪个数组<br>// destPos: 把源数组的数据拷贝到 目标数组的哪个索引<br>// length: 从源数组拷贝多少个数据到目标数组</li></ul></li></ul></li><li><p>currentTimeMillens</p><ul><li>返回当前时间距离1970-1-1的毫秒数</li></ul></li><li><p>gc</p><ul><li>运行垃圾回收机制</li></ul></li></ul></li></ul><h3 id="13-10-BigInteger类和BigDecimal类">13.10 BigInteger类和BigDecimal类</h3><ul><li><p>应用场景</p><ul><li><p>BigInteger适合保存很大的整形</p></li><li><p>BigDecimal适合保存精度很高的浮点型</p></li></ul></li><li><p>常用方法</p><ul><li><p>add</p><ul><li>加</li></ul></li><li><p>substract</p><ul><li>减</li></ul></li><li><p>multiply</p><ul><li>乘</li></ul></li><li><p>divide</p><ul><li><p>除</p></li><li><p>System.out.println(bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING));</p><ul><li>在浮点数进行divide方法时，为了避免出现无限循环小数抛异常，常会规定输出精度</li></ul></li></ul></li></ul></li></ul><h3 id="13-11-日期类">13.11 日期类</h3><ul><li><p>第一代日期类Date</p><ul><li><p>介绍</p><ul><li>//1. 获取当前系统时间<br>//2. 这里的 Date 类是在 java.util 包<br>//3. 默认输出的日期格式是国外的方式, 因此通常需要对格式进行转换</li></ul></li><li><p>输出格式转换</p><ul><li>SimpleDateFormat sdf = new SimpleDateFormat(“yyyy 年 MM 月 dd 日 hh:mm:ss E”);<br>String format = sdf.format(d1);<br>// format:将日期转换成指定格式的字符串<br>System.out.println(“当前日期=” + format);</li></ul></li><li><p>可以把一个格式化的String转成对应的Date</p><ul><li><p>String s = “1996 年 01 月 01 日 10:20:30 星期一”;<br>Date parse = sdf.parse(s);</p></li><li><p>得到 Date 仍然在输出时，还是按照国外的形式，如果希望指定格式输出，需要转换</p></li></ul></li></ul></li></ul><p>在把 String -&gt; Date ， 使用的 sdf 格式需要和你给的 String 的格式一样，否则会抛出转换异常</p><ul><li><p>第二代日期类Calendar</p><ul><li><p>介绍</p><ul><li>Calendar 是一个抽象类， 并且构造器是private<br>可以通过 getInstance() 来获取实例<br>提供大量的方法和字段提供给程序员<br>Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)<br>如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=&gt; Calendar.HOUR_OF_DAY<br>Calender 没有专门的格式化方法，所以需要程序员自己来组合显示</li></ul></li></ul></li><li><p>第三代日期类（JDK8加入）LocalTime,LocalDate,LocalDateTime</p><ul><li><p>介绍</p><ul><li><p>使用 now() 返回表示当前日期时间的对象<br>LocalDateTime ldt = LocalDateTime.now(); <a href="//LocalDate.now">//LocalDate.now</a>();<a href="//LocalTime.now">//LocalTime.now</a>()</p></li><li><p>使用 DateTimeFormatter 对象来进行格式化<br>DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”);<br>String format = dateTimeFormatter.format(ldt);</p></li></ul></li><li><p>方法使用时查看API文档</p></li></ul></li><li><p>instant时间戳类</p><ul><li><p>介绍</p><ul><li><p>通过 静态方法 now() 获取表示当前时间戳的对象<br>Instant now = Instant.now();</p></li><li><p>通过 from 可以把 Instant 转成Date<br>Date date = Date.from(now);</p></li><li><p>通过 date 的 toInstant() 可以把 date 转成 Instant 对象<br>Instant instant = date.toInstant();</p></li></ul></li></ul></li></ul><h2 id="第十四章：集合">第十四章：集合</h2><h3 id="14-1-集合的好处">14.1 集合的好处</h3><ul><li><p>可以动态保存任意多个对象，使用比较方便</p></li><li><p>提供了一系列方便的操作对象的方法：add, remove, set, get等</p></li><li><p>使用集合添加或删除新元素的代码简洁明了</p></li></ul><h3 id="14-2-集合的框架体系">14.2 集合的框架体系</h3><ul><li><p>单列集合（即元素是单个个体）</p><ul><li></li></ul></li><li><p>双列集合（即元素通常是键值对的形式）</p><ul><li></li></ul></li></ul><h3 id="14-3-Collection接口和常用方法">14.3 Collection接口和常用方法</h3><ul><li><p>Collection接口实现类的特点</p><ul><li><p>实现类可以存放多个元素，每个元素可以是Object</p></li><li><p>有些实现类可以存放重复的元素（List的实现类），有些不可以（Set的实现类）</p></li><li><p>有些实现类的元素是有序的（List的实现类），有些不是有序的（Set的实现类）</p></li><li><p>Collection接口没有直接的实现子类，子类通过它的子接口List和Set来实现Collection接口</p></li></ul></li><li><p>常用方法</p><ul><li><p>add</p><ul><li>添加单个元素</li></ul></li><li><p>remove</p><ul><li>删除指定元素，可以指定索引或名称</li></ul></li><li><p>contains</p><ul><li>查找某元素是否存在</li></ul></li><li><p>size</p><ul><li>获取元素的个数</li></ul></li><li><p>isEmpty</p><ul><li>判断是否为空</li></ul></li><li><p>clear</p><ul><li>清空，不保留空间</li></ul></li><li><p>addAll</p><ul><li>添加多个元素，通常是添加另一个Collection的实现子类</li></ul></li><li><p>containsAll</p><ul><li>查找多个元素是否都存在，通常查找另一个Collection的实现子类中的元素是否都在</li></ul></li><li><p>removeAll</p><ul><li>删除多个元素，通常从该对象中删除另一个Collection实现子类中的含有的元素</li></ul></li></ul></li><li><p>实现了Collection接口的子类遍历元素的方式</p><ul><li><p>使用迭代器（iterator）</p><ul><li><p>基本介绍</p><ul><li><p>Iterator对象成为迭代器，主要用于遍历Collection集合实现子类中的元素</p></li><li><p>所有实现了Collection接口的子类都有一个iterator()方法，用以返回一个迭代该子类的迭代器</p></li><li><p>Iterator的结构</p><ul><li></li></ul></li><li><p>Iterator仅用于遍历集合，本身并不存放对象</p></li></ul></li><li><p>执行原理</p><ul><li></li></ul></li><li><p>其常用方法</p><ul><li><p>hasNext</p><ul><li><p>检查是否还存在下一个元素可以遍历</p><ul><li>如果不进行判断，可能抛出NoSuchElementException</li></ul></li></ul></li><li><p>next</p><ul><li>返回下一个遍历的元素</li></ul></li></ul></li><li><p>快捷键 itit</p></li></ul></li><li><p>增强for循环</p><ul><li><p>只能用于遍历集合或数组</p></li><li><p>快捷键 I</p></li></ul></li><li><p>普通for循环</p></li></ul></li></ul><h3 id="14-4-List-接口和常用方法">14.4 List 接口和常用方法</h3><ul><li><p>List接口基本介绍</p><ul><li><p>List实现类中元素有序（即添加顺序和取出顺序一致），且可重复</p></li><li><p>List实现类中的每个元素都有其对应的顺序索引，即支持索引（索引从0开始）</p></li><li><p>List实现类中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</p></li><li><p>List接口的实现类常用的有ArrayList, LinkedList和Vector</p></li></ul></li><li><p>List接口常用方法</p><ul><li><p>add</p><ul><li>添加元素，可以不带参数，默认添加到末尾，也可带参数，添加到索引处</li></ul></li><li><p>addAll</p><ul><li>添加另一个List中的元素到该List中，可以选择添加的位置</li></ul></li><li><p>get</p><ul><li>获取指定索引位置的元素</li></ul></li><li><p>indexOf</p><ul><li>返回参数对象在List中首次出现的位置</li></ul></li><li><p>lastIndexOf</p><ul><li>返回参数对象在List中末次出现的位置</li></ul></li><li><p>remove</p><ul><li>移除指定索引位置的元素，并返回该元素</li></ul></li><li><p>set</p><ul><li>设置指定索引位置的元素为参数对象，相当于是替换</li></ul></li><li><p>subList</p><ul><li>返回从第一个参数索引（含）到第二个参数索引（不含）的子List</li></ul></li></ul></li><li><p>List的三种遍历方式</p><ul><li><p>使用迭代器</p></li><li><p>使用增强for</p></li><li><p>使用普通for</p></li></ul></li></ul><h3 id="14-5-ArrayList-底层结构和源码分析">14.5 ArrayList 底层结构和源码分析</h3><ul><li><p>注意事项</p><ul><li><p>permits all elements， including null，ArrayList可以加入null，并且可加入多个。</p></li><li><p>ArrayList是由数组来实现数据存储的</p></li><li><p>ArrayList基本等同于Vector，除了ArrayList是线程不安全（效率高）。在多线程情况下不建议使用</p></li></ul></li><li><p>底层操作机制源码分析</p><ul><li><p>ArrayList中维护了一个Object类型的数组elementData。<br>transient Object[] elementData;<br>transient表示瞬间，短暂的，表示该属性不会被序列化</p></li><li><p>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData含量为0，第1次添加元素时，扩容到10，再需扩容时，扩容至1.5倍</p></li><li><p>如果使用的是指定大小的构造器，则初始elementData容量为构造器中指定大小，如果需要扩容，则直接扩容elementData为1.5倍。</p></li></ul></li></ul><h3 id="14-6-Vector-底层结构和源码剖析">14.6 Vector 底层结构和源码剖析</h3><ul><li><p>基本介绍</p><ul><li><p>定义说明<br>public class Vector<E><br>extends AbstractList<E><br>implements List<E>, RandomAccess, Cloneable, Serializable</p></li><li><p>Vector底层也是一个对象数组，protected Object[] elementData;</p></li><li><p>Vector是线程安全的，操作方法带有synchronized</p></li><li><p>在开放中，需要线程同步安全时，考虑使用Vector</p></li></ul></li><li><p>源码剖析</p><ul><li><p>使用无参构造器创建时，默认给容量10</p></li><li><p>使用有参构造器创建时，容量为指定容量</p></li><li><p>当需要扩容时，两倍扩容</p></li></ul></li><li><p>Vector和ArrayList比较</p><ul><li></li></ul></li></ul><h3 id="14-7-LinkedList-底层结构">14.7 LinkedList 底层结构</h3><ul><li><p>全面说明</p><ul><li><p>LinkedList底层实现了双向链表和双端队列特点</p></li><li><p>可以添加任意元素（可重复），包括null</p></li><li><p>线程不安全，没有实现同步</p></li></ul></li><li><p>底层操作机制</p><ul><li><p>LinkedList底层维护了一个双向链表</p></li><li><p>LinkedList中维护了两个属性first和last，分别指向首节点和尾节点</p></li><li><p>每个节点（Node对象）里面又维护了prev, next, item三个属性，其中通过prev指向前一个，通过next指向后一个节点，最终实现双向链表</p></li><li><p>所以LinkedList的元素的添加和删除不是通过数组来完成的，效率较高</p></li></ul></li></ul><h3 id="14-8-ArrayList-和-LinkedList-比较">14.8 ArrayList 和 LinkedList 比较</h3><ul><li><p>ArrayList和LinkedList比较及如何选择</p><ul><li></li></ul></li></ul><h3 id="14-9-Set-接口和常用方法">14.9 Set 接口和常用方法</h3><ul><li><p>Set接口基本介绍</p><ul><li><p>无序（添加和取出的顺序不一致），没有索引</p></li><li><p>不允许添加重复元素，所以最多包含一个null</p></li><li><p>常用Set实现类有HashSet, LinkedHashSet, TreeSet</p></li></ul></li><li><p>常用方法</p><ul><li>和List接口是一样，Set接口也是Collection的子接口，因此常用方法和Collection接口一样</li></ul></li><li><p>Set接口实现类的遍历方式</p><ul><li><p>使用迭代器</p></li><li><p>使用增强for</p></li></ul></li></ul><h3 id="14-10-Set-接口实现类-HashSet">14.10 Set 接口实现类-HashSet</h3><ul><li><p>全面说明</p><ul><li><p>HashSet实现了Set接口</p></li><li><p>HashSet底层实际上是HashMap，因为底层维护了一个HashMap，只不过将&lt;K, V&gt;对中的value全部都设为了同一个常量</p></li><li><p>可以存放null，但只能有一个null</p></li><li><p>HashSet不保证元素是有序的，取决于被hash后索引的位置</p></li><li><p>不能有重复元素/对象（因为是Set的实现类）</p></li></ul></li><li><p>添加元素底层机制说明</p><ul><li><p>（1）</p><ul><li><p>HashSet的底层是HashMap，HashMap的底层是数组+链表+红黑树</p></li><li><p>HashSet底层是HashMap</p></li><li><p>添加一个元素时，先得到hash值，再转成数组索引值</p></li><li><p>找到存储数据表（数组table，是 HashMap 的一个数组，存储的数据类型是 Node）对应索引位置，看这个位置是否已经存放有元素</p></li><li><p>如果没有，直接加入</p></li><li><p>如果有，调用【equals】依次比较，如果比较结果相同，就放弃添加，如果不相同，则加到最后</p></li><li><p>在Java8中，如果一条链表的元素个数到达8，并且table中（包括链表中）已有元素个数大于64，该条链表就会树化成红黑树来存储数据</p></li></ul></li><li><p>（2）</p><ul><li><p>HashSet底层是HashMap，第一次添加时，数组table扩容到16，临界值是16 * 0.75 = 12</p></li><li><p>如果table数组达到了临界值，就会扩容到32，新的临界值是32 * 0.75 = 24</p></li><li><p>在java8中，如果一条链表的元素个数到达8，并且table数组大小达到64，就会树化，否则继续扩大table数组</p></li></ul></li></ul></li></ul><h3 id="14-11-Set-接口实现类-LinkedHashSet">14.11 Set 接口实现类-LinkedHashSet</h3><ul><li><p>全面说明</p><ul><li><p>LinkedHashSet是HashSet的子类</p></li><li><p>LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表</p></li><li><p>LinkedHashMap根据元素的hash值来决定元素的存储位置，同时用双向链表维护元素的添加顺序，这使得元素看起来是以插入顺序保存的</p></li><li><p>不允许重复元素</p></li></ul></li></ul><h3 id="14-12-Map-接口和常用方法">14.12 Map 接口和常用方法</h3><ul><li><p>Map接口类的实现特点</p><ul><li><p>Map与Collection并列存在，其用于保存具有映射关系的数据：Key-Value</p></li><li><p>Map中的Key和Value可以是任何的引用类型的数据，会封装到HashMap$Node对象中</p></li><li><p>Map中的Key不允许重复，原因和HashSet一样（底层源码的规定）（即此映射关系只能一对一或者一对多，不能多对一）</p></li><li><p>Map中的value可以重复（即一对多）</p></li><li><p>Map中的Key可以为null，value也可以为null，但Key中的null只有一个，value可以有多个</p></li><li><p>常用String类作为Map的Key</p></li><li><p>key和value之间存在单项一对一关系，即通过指定的key总能找到对应的value</p></li><li><p>Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的，又因为Node实现了Map.Entry接口，所以也可以叫做一对k-v就是一个Entry<br>KeySet存放了所有的key，Entry存放了所有的key-value键值对，这样做是为了方便遍历，因为Map接口没有迭代器，要间接通过Collection实现类来遍历</p></li></ul></li><li><p>Map接口常用方法</p><ul><li><p>put</p><ul><li>添加键值对</li></ul></li><li><p>remove</p><ul><li>根据键删除相应键值对</li></ul></li><li><p>get</p><ul><li>根据索引获取value</li></ul></li><li><p>size</p><ul><li>获取元素个数</li></ul></li><li><p>isEmpty</p><ul><li>判断是否为空</li></ul></li><li><p>clear</p><ul><li>清空Map</li></ul></li><li><p>containsKey</p><ul><li>查找键是否存在</li></ul></li></ul></li><li><p>Map接口遍历方法</p><ul><li><p>第一组</p><ul><li>先取出所有的Key，通过key取出所有的Value<br>Set keyset = map.keySet();<br>然后使用迭代器或增强for遍历keySet来遍历值</li></ul></li><li><p>第二组</p><ul><li>把所有的values取出<br>Collection values = map.values();<br>然后使用迭代器或增强for遍历所有值</li></ul></li><li><p>第三组</p><ul><li>使用EntrySet来获取k-v<br>Set entrySet = map.entrySet();<br>然后用迭代器或增强for来遍历每个entry，通过Map.Entry自带的getKey和getValue方法来获得entry中的一对k-v</li></ul></li></ul></li></ul><h3 id="14-13-Map-接口实现类-HashMap">14.13 Map 接口实现类-HashMap</h3><ul><li><p>前述HashMap小结</p><ul><li><p>Map接口的常用实现类：HashMap, Hashtable, Properties</p></li><li><p>HashMap是Map接口使用频率最高的实现类</p></li><li><p>HashMap是以键值对的形式来存储数据（类型为HashMap$Node)</p></li><li><p>key不能重复，但是值可以重复，允许使用null键和null值</p></li><li><p>如果添加相同的key，则会覆盖原来的k-v，等同于替换</p></li><li><p>与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的</p></li><li><p>HashMap没有实现同步，因此是线程不安全的，方法没有做同步互斥的操作，没有synchronized</p></li></ul></li><li><p>底层机制及源码剖析</p><ul><li><p>底层示意</p><ul><li></li></ul></li><li><p>扩容机制</p><ul><li><p>HashMap底层维护了Node类型的数组table，默认为null</p></li><li><p>当创建对象时，将加载因子(loadfactor)初始化为0.75</p></li><li><p>当添加键值对时，通过key的hash值得到在table的索引，然后判断该索引处是有元素，如果没有则直接添加，如果有且相等则直接替换，如果有且不相等则需要判断后面是树结构还是表结构，做出比较判断，看要不要添加或替换。如果添加后发现容量达到临界值，则扩容</p></li><li><p>第一次添加，将table扩容至16，临界值12</p></li><li><p>以后再次扩容，则双倍扩容，临界值也变为原来的两倍</p></li><li><p>在Java8后，如果链表的元素个数超过8且table大小超过64，就会树化</p></li></ul></li></ul></li></ul><h3 id="14-14-Map-接口实现类-Hashtable">14.14 Map 接口实现类-Hashtable</h3><ul><li><p>基本介绍</p><ul><li><p>存放的元素是键值对：即K-V</p></li><li><p>Hashtable的键和值都不能为null，否则会抛出NullPointerException</p></li><li><p>Hashtable使用方法基本上和HashMap一样</p></li><li><p>Hashtable是线程安全的，HashMap是线程不安全的</p></li></ul></li><li><p>Hashtable和HashMap对比</p><ul><li></li></ul></li></ul><h3 id="14-15-Map-接口实现类-Properties">14.15 Map 接口实现类-Properties</h3><ul><li><p>基本介绍</p><ul><li><p>Properties类继承自Hashtable类并且实现了Map接口，也是使用一种键值对的形式来保存数据</p></li><li><p>它的使用特点和Hashtable类似</p></li><li><p>Properties还可以用于从后缀为properties的文件中加载数据到Properties类对象，并进行读取和修改</p></li><li><p>说明：工作时，properties文件通常作为配置文件，在IO流时具体学习</p></li></ul></li></ul><h3 id="14-16-总结-开发中如何选择集合实现类">14.16 总结-开发中如何选择集合实现类</h3><ul><li><p>先判断存储的类型（一组对象【单列】或一组键值对【双列】</p></li><li><p>一组对象【单列】：Collection接口实现类<br>允许重复：List<br>增删多：LinkedList（双向列表）<br>改查多：ArrayList（数组）<br>不允许重复：Set<br>无序：HashSet（HashMap）<br>排序：TreeSet<br>插入和取出顺序一致：LinkedHashSet（数组+双向链表）</p></li><li><p>一组键值对【双列】：Map接口实现类<br>键无序：HashMap<br>键排序：TreeSet<br>插入和取出顺序一致：LinkedHashMap（数组+双向链表）</p></li><li><p>补充</p><ul><li><p>TreeSet和TreeMap</p><ul><li><p>TreeSet底层是TreeMap，在添加元素时，TreeMap会先判断添加顺序，然后再添加元素，所以可以实现键排序</p><ul><li><ol><li>构造器把传入的比较器对象，赋给了 TreeSet 的底层的 TreeMap 的属性 this.comparator<br>public TreeMap(Comparator&lt;? super K&gt; comparator) {<br>this.comparator = comparator;<br>}</li></ol></li></ul></li></ul></li></ul></li></ul><ol start="2"><li><p>在 调用 treeSet.add(“tom”), 在底层会执行到<br>if (cpr != null) {//cpr 就是我们的匿名内部类(对象)<br>do {<br>parent = t;<br>//动态绑定到我们的匿名内部类(对象)compare<br>cmp = cpr.compare(key, t.key);<br>if (cmp &lt; 0)<br>t = t.left;<br>else if (cmp &gt; 0)<br>t = t.right;<br>else //如果相等，即返回 0,这个 Key 就没有加入<br>return t.setValue(value);<br>} while (t != null);<br>}</p><pre><code> - 通过在创建TreeMap对象时调用有参构造器传入匿名内部类Comparator，可以自定义添加键值对时的默认顺序，可以是根据字符串长度、字符串在字母表中顺序等来自定义。同样，如果根据添加规则发现有相同元素，就替换</code></pre></li></ol><h3 id="14-17-Collections-工具类">14.17 Collections 工具类</h3><ul><li><p>介绍</p><ul><li><p>Collections是一个操作Set，List和Map等集合的工具类</p></li><li><p>Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</p></li></ul></li><li><p>排序操作</p><ul><li><p>reverse(List)</p><ul><li>反转List中元素的顺序</li></ul></li><li><p>shuffle(List)</p><ul><li>对List中元素进行随机排序（打乱）</li></ul></li><li><p>sort(List)</p><ul><li>根据元素的自然顺序（字母表顺序）对指定List中元素按升序排序</li></ul></li><li><p>sort(List, Comparator)</p><ul><li>按照指定的Comparator中的compare方法产生的顺序来排序</li></ul></li><li><p>swap(List, int, int)</p><ul><li>将指定List中的i处元素和j处元素交换</li></ul></li></ul></li><li><p>查找、替换操作</p><ul><li><p>max(Collection)</p><ul><li>根据元素的自然顺序，返回给定集合中的最大元素</li></ul></li><li><p>max(Collection, Comparator)</p><ul><li>根据自定义顺序，返回给定集合中的最大元素</li></ul></li><li><p>min(Collection)</p><ul><li>同上</li></ul></li><li><p>min(Collection, Comparator)</p><ul><li>同上</li></ul></li><li><p>frequency(Collection, Object)</p><ul><li>返回Object在集合中出现的次数</li></ul></li><li><p>copy(List dest, List src)</p><ul><li>将src中的内容复制到dest中</li></ul></li><li><p>replace(List, Object oldVal, Object newVal)</p><ul><li>将List中的所有oldVal元素替换为newVal</li></ul></li></ul></li></ul><h2 id="第十五章：泛型">第十五章：泛型</h2><h3 id="15-1-2-泛型的理解和好处">15.1 2 泛型的理解和好处</h3><ul><li><p>传统方法的问题</p><ul><li><p>不能对加入到集合中的数据类型进行约束</p></li><li><p>遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响</p></li></ul></li><li><p>泛型的好处</p><ul><li><p>编译时，检查添加元素的类型，提高了安全性</p></li><li><p>减少了类型转换的次数，提高效率</p></li><li><p>不再提示编译警告</p></li></ul></li></ul><h3 id="15-3-泛型介绍">15.3 泛型介绍</h3><ul><li><p>泛——广泛，泛型——广泛的类型，泛化的类型</p><ul><li><p>泛型又称为参数化类型，是JDK5.0出现的新特性，解决数据类型的安全性问题</p></li><li><p>在类声明或实例化时只要制定好需要的具体的类型即可</p></li><li><p>Java泛型可以保证如果程序在编译时没有发出警告，那么运行时就不会产生</p></li><li><p>泛型的作用是：可以在类声明时通过一个标识表示类中的某个属性的类型，或是某个方法的返回值的类型，或是参数类型</p></li></ul></li></ul><h3 id="15-4-泛型的语法">15.4 泛型的语法</h3><ul><li><p>泛型的声明</p><ul><li><p>interface name<T> {}<br>class name &lt;K,V&gt;{}等</p><ul><li><p>其中，T、K、V不代表值，而是表示类型</p></li><li><p>任意字母都可以。常用T表示，是type的缩写</p></li></ul></li></ul></li><li><p>泛型的实例化</p><ul><li><p>需要在类名或接口名后指定类型参数的值</p><ul><li>List<String> strList = new ArrayList&lt;&gt;();<br>Iterator<Customer> iterator = customers.iterator();</li></ul></li></ul></li><li><p>泛型使用的注意事项和细节</p><ul><li><p>T、V等字母代表的类型只能是引用类型</p></li><li><p>在给泛型指定具体的类型后，可以传入该类型或其子类类型</p></li><li><p>泛型使用形式，推荐写成如下形式：<br>List<Integer> list = new ArrayList&lt;&gt;();<br>如果尖括号内不写内容，默认为Object</p></li></ul></li></ul><h3 id="15-6-自定义泛型">15.6 自定义泛型</h3><ul><li><p>自定义泛型类</p><ul><li><p>基本语法</p><ul><li>class name &lt;T, R…&gt; {<br>成员<br>}</li></ul></li><li><p>注意细节</p><ul><li><p>普通成员可以使用泛型</p></li><li><p>使用泛型的数组，不能初始化（因为编译器不知道该分配多大的空间）</p></li><li><p>静态方法中不能使用类的泛型（因为静态方法是跟类相关的，在类加载时，对象还没创建，泛型还没指定）</p></li><li><p>泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型）</p></li><li><p>如果在创建对象时，没有指定类型，默认为Object</p></li></ul></li></ul></li><li><p>自定义泛型接口</p><ul><li><p>基本语法</p><ul><li>interface name &lt;T, R…&gt; {<br>…<br>}</li></ul></li><li><p>注意细节</p><ul><li><p>接口中，静态成员也不能使用泛型（与泛型类的规定一样）</p></li><li><p>泛型接口的类型，在继承接口或实现接口时确定</p></li><li><p>没有指定类型，默认为Object</p></li></ul></li></ul></li><li><p>自定义泛型方法</p><ul><li><p>基本语法</p><ul><li>修饰符 &lt;T, R…&gt; 返回类型 方法名(参数列表){<br>}</li></ul></li><li><p>注意细节</p><ul><li><p>泛型方法，可以定义在普通类中，也可以定义在泛型类中</p></li><li><p>当泛型方法被调用时，类型会确定</p></li><li><p>注意泛型方法和使用了泛型的方法的区别<br>（泛型方法指调用方法时需要传泛型类型的方法，而使用了泛型的方法仅指返回值或参数类型有泛型的方法，其泛型不是在调用时指定的）</p></li></ul></li></ul></li></ul><h3 id="15-7-泛型的继承和通配符">15.7 泛型的继承和通配符</h3><ul><li><p>说明</p><ul><li><p>泛型不具备继承性，即<br>List<Object> list = new ArrayList<String>();是不正确的</p></li><li><?>：支持任意泛型类型</li><li><? extends A>：支持A类以及A的子类，规定了泛型的上限</li><li><? super A>：支持A类以及A的父类，不限于直接父类，规定了泛型的下限</li></ul></li></ul><h3 id="15-9-JUnit">15.9 JUnit</h3><ul><li><p>为什么需要？</p><ul><li><p>一个类有很多功能代码需要测试，为了测试，就需要写入到main方法中</p></li><li><p>如果有多个功能代码测试，就需要来回注释掉，切换很麻烦</p></li><li><p>如果可以直接运行一个方法，就方便很多，并且可以给出相关信息</p></li></ul></li><li><p>基本介绍</p><ul><li><p>JUnit是一个Java语言的单元测试框架</p></li><li><p>多数Java的开发环境都已经继承了JUnit作为单元测试工具</p></li></ul></li></ul><h2 id="第十七章：多线程基础">第十七章：多线程基础</h2><h3 id="17-1-线程相关概念">17.1 线程相关概念</h3><ul><li><p>程序</p><ul><li>程序就是：为完成特定任务，用某种语言编写的一组指令的集合，简单地说就是我们写的代码</li></ul></li><li><p>进程</p><ul><li><p>进程是指运行中的程序，比如我们点开QQ，就启动了一个进程，操作系统就会为该进程分配内存空间。</p></li><li><p>进程是程序的一次执行过程，或是正在运行的一个程序。是动态过程：有它自身的产生，存在，和消亡的过程。</p></li></ul></li><li><p>线程</p><ul><li><p>线程由进程创建，是进程的一个实体（即进程通过线程来完成工作，线程是进程具体完成工作的实体，而进程是线程的抽象）</p></li><li><p>一个进程可以拥有多个线程（比如一个Java程序中就可以创建多个线程）</p></li></ul></li><li><p>单线程</p><ul><li>同一个时刻，只允许执行一个线程</li></ul></li><li><p>多线程</p><ul><li>同一个时刻，可以执行多个线程</li></ul></li><li><p>并发</p><ul><li>同一个时刻，多个任务交替执行，造成一种“貌似同时”的错觉，简单的说，单核cpu实现的多任务就是并发</li></ul></li><li><p>并行</p><ul><li>同一个时刻，多个任务同时执行，多核cpu可以实现并行</li></ul></li></ul><h3 id="17-2-线程的基本使用">17.2 线程的基本使用</h3><ul><li><p>创建线程的两种方式</p><ul><li><p>继承Thread类，重写run方法</p></li><li><p>实现Runnable接口，重写run方法</p><ul><li><p>Java是单继承的，在某些情况下一个类可能已经继承了某个父类，这时再用继承Thread类的方法来创建线程已经不可能了</p></li><li><p>Java设计者们提供了另外一个方式创建线程，就是通过实现Runnable接口来创建线程</p></li></ul></li></ul></li><li><p>start0，run和start</p><ul><li><p>start0是本地方法，是JVM调用的方法，底层是c/c++实现，是真正实现多线程效果的方法</p><ul><li>start方法调用start0方法后，该线程并不一定会立马执行，只是将线程变成了可运行状态。具体什么时候执行，取决于CPU，由CPU统一调度</li></ul></li><li><p>run，即线程运行时所执行的方法，如果单独调用而不是通过start调用，那就没有多线程效果，只是简单的方法调用</p></li><li><p>start，启动线程，程序不会阻塞，即实现了多线程的效果</p></li></ul></li></ul><h3 id="17-3-继承Thread-vs-实现Runnable">17.3 继承Thread vs 实现Runnable</h3><ul><li><p>从Java设计来看，通过继承Thread和实现Runnable接口来创建线程本质上没有区别，从jdk帮助文档可以看到，Thread类本身就实现了Runnable接口</p></li><li><p>实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制，建议使用Runnable</p></li></ul><h3 id="17-4-线程终止">17.4 线程终止</h3><ul><li><p>基本说明</p><ul><li><p>当线程完成任务后，会自动退出</p></li><li><p>还可以通过使用变量来控制run方法退出的方式来停止线程，这种终止方式叫做通知方式</p></li></ul></li><li><p>步骤</p><ul><li><p>定义标记变量，默认为true</p></li><li><p>将标记变量设为循环条件</p></li><li><p>提供公共的set方法，用于更新loop</p></li></ul></li></ul><h3 id="17-5-线程常用方法">17.5 线程常用方法</h3><ul><li><p>setName</p><ul><li>设置线程名称，与参数name相同</li></ul></li><li><p>getName</p><ul><li>返回该线程的名称</li></ul></li><li><p>start</p><ul><li>使该线程开始执行；Java虚拟机底层调用该线程的start0方法</li></ul></li><li><p>run</p><ul><li>调用线程对象的run方法</li></ul></li><li><p>setPriority</p><ul><li>更改线程的优先级</li></ul></li><li><p>getPriority</p><ul><li>获取线程的优先级</li></ul></li><li><p>sleep</p><ul><li>在指定的毫秒数内让当前正在执行的线程休眠</li></ul></li><li><p>interrupt</p><ul><li>中断线程</li></ul></li><li><p>yield</p><ul><li>线程的礼让。让出cpu，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功</li></ul></li><li><p>join</p><ul><li>线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务，才执行当前线程的任务</li></ul></li><li><p>用户线程和守护线程</p><ul><li><p>用户线程</p><ul><li>也叫工作线程，当线程的任务执行完或以通知方式通知则结束</li></ul></li><li><p>守护线程</p><ul><li>一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束<br>典型例子：垃圾回收机制线程</li></ul></li></ul></li></ul><h3 id="17-6-线程的生命周期">17.6 线程的生命周期</h3><ul><li><p>JDK中用Thread.State枚举表示了线程的几种状态</p><ul><li><p>NEW</p><ul><li>线程尚未启动</li></ul></li><li><p>RUNNABLE</p><ul><li>线程处于执行状态</li></ul></li><li><p>BLOCKED</p><ul><li>线程处于被阻塞状态</li></ul></li><li><p>WAITING</p><ul><li>线程处于等待状态</li></ul></li><li><p>TIMED_WAITING</p><ul><li>线程处于定时等待状态</li></ul></li><li><p>TERMINATED</p><ul><li>线程处于终止状态</li></ul></li></ul></li><li><p>线程状态转换图</p><ul><li></li></ul></li><li><p>查看线程状态</p><ul><li>getState()方法</li></ul></li></ul><h3 id="17-7-线程的同步">17.7 线程的同步</h3><ul><li><p>为什么需要？</p><ul><li>当多个线程同时操作共有资源时，会导致发生不期望的结果，于是需要某一时刻只能有一个线程进行操作，于是需要线程的同步</li></ul></li><li><p>线程的同步，使用Synchronized关键字</p></li></ul><h3 id="17-8-Synchronized">17.8 Synchronized</h3><ul><li><p>线程同步机制</p><ul><li><p>在多线程编程时，一些敏感数据不允许被多个线程同时访问，此时就需要同步访问技术，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性</p></li><li><p>也可以这样理解：线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作</p></li></ul></li><li><p>语法</p><ul><li><p>同步代码块</p><ul><li>synchronized (对象) { // 得到对象的锁，才能                                               操作同步代码<br>}</li></ul></li><li><p>同步方法</p><ul><li>public synchronized void name(…) {<br>}</li></ul></li></ul></li></ul><h3 id="17-9-分析同步原理">17.9 分析同步原理</h3><ul><li></li><li><p>同一时间只能有一个线程拿到锁，并操作同步代码，此时其他线程没有拿到锁，无法操作，直到线程操作完毕把锁归还，所有线程再一起竞争这把锁，再重复</p></li></ul><h3 id="17-10-互斥锁">17.10 互斥锁</h3><ul><li><p>基本介绍</p><ul><li><p>Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性</p></li><li><p>每个对象都对应与一个可称为“互斥锁”的标记，这个标记用来保证在任意时刻，只能有一个线程访问该对象</p></li><li><p>关键字synchronized用来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任意时刻只能由一个线程访问</p></li><li><p>同步的局限性：导致程序的执行效率降低</p></li><li><p>同步方法（非静态）的锁可以是this（当前对象），也可以是其他对象（要求多个线程对应的是同一对象）</p></li><li><p>同步方法（静态）的锁为当前类本身</p></li><li><p>同步代码块的锁是this对象</p></li></ul></li><li><p>注意事项和细节</p><ul><li><p>同步方法如果没有使用static修饰，默认锁对象为this</p></li><li><p>如果方法使用static修饰，默认锁对象为当前类.class</p></li><li><p>如何实现线程同步？</p><ul><li><p>需要先分析上锁的代码</p></li><li><p>选择使用同步代码块或同步方法</p></li><li><p>要求多个线程的锁对象为同一个即可</p></li></ul></li></ul></li></ul><h3 id="17-11-线程的死锁">17.11 线程的死锁</h3><ul><li><p>基本介绍</p><ul><li>多个线程都占用了对方的锁的资源，都需要得到对方的锁才能进行下一步操作，此时就导致了死锁。这是在编程中必须要避免的！</li></ul></li><li><p>举例</p><ul><li>a线程得到了x的锁，正在执行代码，到某个节点执行下一步代码需要得到y的锁；而同时b线程得到了y的锁，下一步执行需要得到x的锁才能继续执行。两者互不相让，导致线程死锁，程序不继续进行，也不退出。</li></ul></li></ul><h3 id="17-12-释放锁">17.12 释放锁</h3><ul><li><p>以下的操作会释放锁</p><ul><li><p>当前线程的同步方法、同步代码块执行结束</p></li><li><p>当前线程在同步代码块、同步方法中遇到break, return</p></li><li><p>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</p></li><li><p>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁</p></li></ul></li><li><p>以下操作不会释放锁</p><ul><li><p>线程执行同步方法、同步代码块时，程序调用Thread.sleep(), Thread.yield()方法暂停当前线程的执行时，不会释放锁</p></li><li><p>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，不会释放锁</p></li></ul></li></ul><h2 id="第十九章：IO流">第十九章：IO流</h2><h3 id="19-1-文件">19.1 文件</h3><ul><li><p>什么是文件？</p><ul><li>文件是保存数据的地方，它既可以是一张图片，也可以是一段视频，一段音频等等</li></ul></li><li><p>文件流</p><ul><li><p>文件在程序中是以流的形式来操作的</p></li><li><p>流</p><ul><li>数据在数据源和程序之间的路径</li></ul></li><li><p>输入流</p><ul><li>数据从数据源到程序的路径</li></ul></li><li><p>输出流</p><ul><li>数据从程序到数据源的路径</li></ul></li></ul></li></ul><h3 id="19-2-常用的文件操作">19.2 常用的文件操作</h3><ul><li><p>创建文件对象的相关构造器的方法</p><ul><li><p>构造器</p><ul><li>new File(String pathname)//根据绝对路径构建一个File对象<br>new File(File parent, String child)//根据父目录文件对象+子路径构建<br>new File(String parent, String child)//根据父目录+子目录贵贱</li></ul></li><li><p>方法</p><ul><li><p>createNewFile</p><ul><li>创建新文件</li></ul></li></ul></li></ul></li><li><p>获取文件的相关信息</p><ul><li><p>getName</p><ul><li>获取文件名</li></ul></li><li><p>getAbsolutePath</p><ul><li>获取文件绝对路径</li></ul></li><li><p>getParent</p><ul><li>获取文件父级目录</li></ul></li><li><p>length</p><ul><li>获取文件大小（字节）</li></ul></li><li><p>exists</p><ul><li>判断文件是否存在</li></ul></li><li><p>isFile</p><ul><li>判断是不是一个文件</li></ul></li><li><p>isDirectory</p><ul><li>判断是不是一个目录</li></ul></li></ul></li><li><p>文件的操作和文件删除</p><ul><li><p>mkdir</p><ul><li>创建一级目录</li></ul></li><li><p>mkdirs</p><ul><li>创建多级目录，指如果文件当前所指位置之前有多个目录需要创建，则用此方法可以一次性创建多个目录，直到文件所指位置</li></ul></li><li><p>delete</p><ul><li>删除空目录或文件，不可删除非空的目录</li></ul></li></ul></li></ul><h3 id="19-3-IO流原理及流的分类">19.3 IO流原理及流的分类</h3><ul><li><p>Java IO流的原理</p><ul><li><p>I/O是Input/Output的缩写，I/O技术是非常实用的技术，用于处理数据传输。如读写文件，网络通讯等</p></li><li><p>Java程序中，对于数据的输入和输出是以“流”的方式进行</p></li><li><p>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过方法输入或输出数据</p></li><li><p>输入：读取外部数据（磁盘、光盘、网络等）到程序（内存）中</p></li><li><p>输出：将程序（内存）中的数据输出到外部源（磁盘，光盘，网络等）中</p></li></ul></li><li><p>流的分类</p><ul><li><p>按操作数据的单位分为</p><ul><li><p>字节流</p><ul><li>适合读写二进制文件</li></ul></li><li><p>字符流</p><ul><li>适合读写文本文件</li></ul></li></ul></li><li><p>按数据流的流向不同分为</p><ul><li><p>输入流</p></li><li><p>输出流</p></li></ul></li><li><p>按流的角色的不同分为</p><ul><li><p>节点流</p></li><li><p>处理流/包装流</p></li></ul></li></ul></li></ul><h3 id="19-4-IO流体系图和常用的类">19.4 IO流体系图和常用的类</h3><ul><li><p>IO流体系图</p><ul><li></li></ul></li><li><p>文件和流的关系</p><ul><li></li></ul></li><li><p>FileInputStream</p><ul><li></li></ul></li><li><p>FileOutputStream</p><ul><li></li></ul></li><li><p>FileReader</p><ul><li></li><li><p>相关方法</p><ul><li><p>new FileReader(File/String)</p><ul><li>构造器，可以用File对象或路径字符串</li></ul></li><li><p>read()</p><ul><li>每次读取单个字符，返回该字符，如果到文件末尾返回-1</li></ul></li><li><p>read(char[])</p><ul><li>批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1</li></ul></li><li><p>new String(char[])</p><ul><li>将char[]转换为String</li></ul></li><li><p>new String(char[], off, len)</p><ul><li>将char[]指定部分转换成String</li></ul></li></ul></li></ul></li><li><p>FileWriter</p><ul><li></li><li><p>相关方法</p><ul><li><p>new FileWriter(File/String)</p><ul><li>构造器，可以用File对象或路径字符串，覆盖模式</li></ul></li><li><p>new FileWriter(File/String, true)</p><ul><li>构造器，可以用File对象或路径字符串，追加模式</li></ul></li><li><p>write(int)</p><ul><li>写入单个字符</li></ul></li><li><p>write(char[])</p><ul><li>写入整个数组</li></ul></li><li><p>write(char[], off, len)</p><ul><li>写入数组的指定部分</li></ul></li><li><p>write(String)</p><ul><li>写入整个字符串</li></ul></li><li><p>write(String, off, len)</p><ul><li>写入字符串的指定部分</li></ul></li><li><p>toCharArray()</p><ul><li>将String转换为char[]</li></ul></li><li><p>注意</p><ul><li>FileWriter使用后，必须要关闭(close)或者刷新(flush)，否则数据还在内存中，没有写入到文件中</li></ul></li></ul></li></ul></li></ul><h3 id="19-5-节点流和处理流">19.5 节点流和处理流</h3><ul><li><p>基本介绍</p><ul><li><p>节点流可以从一个特定的数据源读写数据，如FileWriter, FileWriter</p></li><li><p>处理流（包装流）是“连接”在已存在的流之上，为程序提供更为强大的读写功能，也更加灵活。如BufferedReader, BufferedWriter</p></li></ul></li><li><p>节点流和处理流的区别和联系</p><ul><li><p>节点流是底层流/低级流，直接跟数据源相接</p></li><li><p>处理流（包装流）包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出</p></li><li><p>处理流（包装流）对节点流进行包装，使用了修饰器模式，不会直接与数据源相连</p></li></ul></li><li><p>处理流的功能主要体现在以下两个方面</p><ul><li><p>性能的提高：主要以增加缓冲的方式来提高输入输出的效率</p></li><li><p>操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便</p></li></ul></li><li><p>BufferedReader</p></li><li><p>BufferedWriter</p></li><li><p>BufferedInputStream</p></li><li><p>BufferedOutputStream</p></li><li><p>对象流</p><ul><li><p>为何需要？</p><ul><li><p>有时我们希望保存到文件的数据既有值又有数据类型，这样我们在读取文件时可以直接把读取到的值赋值给对应数据类型的对象，免去了类型转换的步骤</p><ul><li></li></ul></li></ul></li><li><p>序列化和反序列化</p><ul><li><p>序列化就是在保存数据时，保存数据的值和数据类型</p></li><li><p>反序列化就是在恢复数据时，恢复数据的值和数据类型</p></li><li><p>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：</p><ul><li>Serializable // 这是一个标记接口，没有方法</li><li>Externalizable // 该接口有方法需要实现，所以一般实现上面的Serializable接口</li></ul></li></ul></li><li><p>介绍</p><ul><li><p>功能</p><ul><li>提供了对基本类型或对象类型的序列化和反序列化的方法</li></ul></li><li><p>ObjectInputStream</p><ul><li><h2 id="提供反序列化功能">提供反序列化功能</h2></li></ul></li><li><p>ObjectOutputStream</p><ul><li><h2 id="提供序列化功能">提供序列化功能</h2></li></ul></li></ul></li><li><p>注意事项和细节说明</p><ul><li><p>读写顺序要一致</p></li><li><p>要求序列化或反序列化的对象，要实现序列化接口</p></li><li><p>序列化的类中建议添加SerialVersionUID，以提高版本的兼容性</p></li><li><p>序列化对象时，默认将里面所有属性都进行序列化，除了static或transient修饰的成员</p></li><li><p>序列化对象时，要求里面属性的类型也实现了序列化接口</p></li><li><p>序列化具备可继承性，也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化</p></li></ul></li></ul></li><li><p>标准输入输出流</p><ul><li><p>介绍</p><ul><li><p><a href="http://System.in">System.in</a></p><ul><li><p>标准输入，类型为InputStream，默认输入设备为键盘</p></li><li><p>new Scanner(<a href="http://System.in">System.in</a>)</p></li></ul></li><li><p>System.out</p><ul><li><p>标准输出，类型为PrintStream，默认输出设备为显示器</p></li><li><p>System.out.println()</p></li></ul></li></ul></li></ul></li><li><p>转换流</p><ul><li><p>介绍</p><ul><li><p>InputStreamReader</p><ul><li>Reader的子类，可以将InputStream（字节流）包装（转换）成Reader（字符流）</li></ul></li><li><p>OutputStreamWriter</p><ul><li>Writer的子类，可以将OutputStream（字节流）转换成Writer（字符流）</li></ul></li><li><p>当处理纯文本数据时，使用字符流效率更高，并且可以有效解决中文乱码问题，所以建议此时将字节流转换成字符流</p></li><li><p>可以在使用时指定编码格式（utf-8, gbk, gb2312, ISO8859-1）</p></li></ul></li></ul></li></ul><h3 id="19-6-打印流">19.6 打印流</h3><ul><li><p>打印流</p><ul><li><p>PrintStream</p><ul><li></li></ul></li><li><p>PrintWriter</p><ul><li></li></ul></li></ul></li></ul><h3 id="19-7-Properties类">19.7 Properties类</h3><ul><li><p>使用场景</p><ul><li></li></ul></li><li><p>基本介绍</p><ul><li><p>是专门用于读写后缀为properties的配置文件的集合类，配置文件的格式：<br>键=值<br>键=值<br>…</p></li><li><p>注意，键值对中间没有空格，值不需要用引号括起来，默认值都为Sting类型</p></li><li><p>常用方法</p><ul><li><p>load</p><ul><li>加载配置文件的键值对到Properties对象</li></ul></li><li><p>list</p><ul><li>将数据显示到指定设备</li></ul></li><li><p>getProperty(key)</p><ul><li>根据键获取值</li></ul></li><li><p>setProperty(key, value)</p><ul><li>设置（更新）键值对到Properties对象</li></ul></li><li><p>store</p><ul><li>将Properties中的键值对存储到配置文件中，在idea中，保存信息到配置文件时，如果有中文，会存储为Unicode码</li></ul></li></ul></li></ul></li></ul><h2 id="第二十一章：网络编程">第二十一章：网络编程</h2><h3 id="21-1-网络的相关概念">21.1 网络的相关概念</h3><ul><li><p>网络通信</p><ul><li><p>两台设备之间通过网络实现数据传输的过程</p></li><li><p>java.net包下提供了一系列的类或接口供程序员使用，来完成网络通信</p></li></ul></li><li><p>网络</p><ul><li><p>概念</p><ul><li>两台或多台设备通过一定物理设备连接起来构成了网络</li></ul></li><li><p>分类：根据网络的覆盖范围不同，对网络进行分类</p><ul><li><p>局域网</p></li><li><p>城域网</p></li><li><p>广域网</p></li></ul></li></ul></li><li><p>ip地址</p><ul><li><p>概念</p><ul><li>用于唯一表示网络中的每台计算机/主机的标识</li></ul></li><li><p>查看ip地址</p><ul><li>控制台输入ipconfig</li></ul></li><li><p>ip地址的表示形式</p><ul><li><p>点分十进制<br><a href="http://xxx.xxx.xxx.xxx">xxx.xxx.xxx.xxx</a></p></li><li><p>每个十进制数的范围：0~255</p></li></ul></li><li><p>ip地址的组成</p><ul><li>网络地址+主机地址</li></ul></li><li><p>IPv6</p><ul><li><p>IPv6是互联网工程任务组设计的用于替代IPv4的下一代IP协议，其地址数量号称可以为全世界的每一粒沙子编上一个地址</p></li><li><p>由于IPv4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍</p></li></ul></li></ul></li><li><p>IPv4地址分类</p><ul><li></li><li></li></ul></li><li><p>域名</p><ul><li><p>实例：<a href="http://www.baidu.com">www.baidu.com</a></p></li><li><p>好处：可以方便记忆，省去了记IP的麻烦</p></li><li><p>概念：通过HTTP协议，可以将IP地址映射成域名，方便记忆</p></li><li><p>端口号</p><ul><li><p>概念：用于标识计算机上某个特定的网络程序</p></li><li><p>表示形式：以整数形式表示，端口范围0~65535（两个字节表示）</p></li><li><p>0~1024已经被占用，比如ssh22, ftp21, smtp25, http80</p></li><li><p>常见的网络程序端口号</p><ul><li><p>tomcat:8080</p></li><li><p>mysql:3306</p></li><li><p>oracle:1521</p></li><li><p>sqlserver:1433</p></li></ul></li></ul></li></ul></li><li><p>协议(TCP/IP)</p><ul><li><p>TCP/IP是Transmission Control Protocol/Internet Protocol的简写，中文译名为传输控制协议/因特网互联协议，又叫网络通讯协议，是互联网最基本的血祭，是国际互联网的基础。由网络层的IP协议和传输层的TCP协议组成</p><ul><li></li></ul></li></ul></li><li><p>网络通信协议</p><ul><li></li></ul></li><li><p>TCP和UDP</p><ul><li><p>TCP</p><ul><li><p>传输控制协议</p><ul><li><p>使用TCP协议前，需要先建立TCP连接，形成传输数据通道</p></li><li><p>传输前，采用“三次握手”方式，是可靠的</p></li><li><p>TCP协议进行通信的两个应用进程：服务端和客户端</p></li><li><p>在连接中可进行大数据量的传输</p></li><li><p>传输完毕，需要释放已经建立的连接，效率低</p></li></ul></li></ul></li><li><p>UDP</p><ul><li><p>用户数据协议</p><ul><li><p>将数据、源、目的封装成数据包，不需要建立连接</p></li><li><p>每个数据包的大小限制在64KB内，不适合传输大量数据</p></li><li><p>因无需连接，故是不可靠的</p></li><li><p>发送数据结束时无需释放资源（因为不是面向连接的），速度快</p></li></ul></li></ul></li></ul></li></ul><h3 id="21-2-InetAddress类">21.2 InetAddress类</h3><ul><li><p>相关方法</p><ul><li><p>getLocalHost</p><ul><li>获取本机的InetAddress对象</li></ul></li><li><p>getByName</p><ul><li>根据指定主机名/域名获取InetAddress对象</li></ul></li><li><p>getHostName</p><ul><li>获取InetAddress对象的主机名</li></ul></li><li><p>getHostAddress</p><ul><li>获取InetAddress对象的ip地址</li></ul></li></ul></li></ul><h3 id="21-3-Socket">21.3 Socket</h3><ul><li><p>基本介绍</p><ul><li><p>使用套接字（Socket）开发网络应用程序被广泛采用，以至于称为事实上的标准</p></li><li><p>通信的两端都要有Socket，是两台机器间通信的端点</p></li><li><p>网络通信其实就是Socket之间的通信</p></li><li><p>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输</p></li><li><p>一般主动发起通信的应用程序属于客户端，等待通信请求的为服务端</p></li></ul></li><li></li></ul><h3 id="21-4-TCP网络通信编程">21.4 TCP网络通信编程</h3><ul><li><p>基本介绍</p><ul><li><p>基于客服端-服务端的网络通信</p></li><li><p>底层使用的是TCP/IP协议</p></li><li><p>基于Socket的TCP编程</p></li><li><p>应用场景举例：客户端发送数据。服务端接收并显示在控制台上</p></li></ul></li><li><p>举例</p><ul><li><p>案例1</p><ul><li><p>TCPSocket01Client.java</p></li><li><p>TCPSocket01Server.java</p></li></ul></li><li><p>案例2</p><ul><li><p>TCPSocket02Client.java</p></li><li><p>TCPSocket02Server.java</p></li></ul></li><li><p>案例3</p><ul><li><p>TCPSocket03Client.java</p></li><li><p>TCPSocket03Server.java</p></li></ul></li><li><p>案例4</p><ul><li><p>uploadFileClient.java</p></li><li><p>uploadFileServer.java</p></li></ul></li></ul></li><li><p>netstat指令</p><ul><li><p>netstat -an 可以查看当前主机网络情况，包括端口监听情况和网络连接情况</p></li><li><p>netstat -an|more 可以分页显示</p></li><li><p>listening表示某个端口正在监听<br>如果有一个外部程序连接到该端口，就会显示一条连接信息</p></li></ul></li><li><p>TCP网络通讯细节</p><ul><li>当客户端连接到服务端后，实际上客户端也是通过一个端口和服务端进行通讯的，这个端口是TCP/IP来分配的，是不确定的，是随机的。</li></ul></li></ul><h3 id="21-5-UDP网络编程">21.5 UDP网络编程</h3><ul><li><p>基本介绍</p><ul><li><p>类DatagramSocket和DatagramPacket实现了基于UDP协议网络程序</p></li><li><p>UDP数据包DatagramPacket通过数据包套接字DatagramSocket发送和接收，系统不保证UDP数据包一定能够安全送到目的地，也不确定什么时候可以送达</p></li><li><p>DatagramPacket对象封装了UDP数据包，在数据包中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号</p></li><li><p>UDP协议中每个数据包都给出了完整的地址信息，因此无需建立发送方和接收方的连接</p></li></ul></li><li><p>基本流程</p><ul><li><p>核心的两个类/对象：DatagramSocket和DatagramPacket</p></li><li><p>建立发送端，接收端（没有服务端和客户端的概念）</p></li><li><p>发送数据前，建立数据包对象DatagramPacket</p></li><li><p>调用数据包套接字DatagramSocket的发送和接收方法</p></li><li><p>关闭DatagramSocket</p></li></ul></li><li><p>案例</p><ul><li><p>UDPReceiver.java</p></li><li><p>UDPSender.java</p></li></ul></li></ul><h2 id="第二十三章：反射">第二十三章：反射</h2><h3 id="23-1-引出背景">23.1 引出背景</h3><ul><li><p>根据如下配置文件，创建Cat对象并调用方法hi<br>classfullpath=com.hspedu.Cat<br>method=hi</p></li><li><p>利用现有技术，几乎不能完成，于是引入反射机制</p></li><li><p>这样的根据外部文件的配置，在不修改源码的情况下来控制程序用的非常多，也符合设计模式中的开闭原则（不修改源码，可扩展功能）</p></li></ul><h3 id="23-2-反射机制">23.2 反射机制</h3><ul><li><p>基本介绍</p><ul><li><p>反射机制允许程序在执行期间借助于反射相关API取得任何类的内部信息（比如成员变量，构造器，成员方法等等），并能创建对象并操作对象的属性及方法。反射在设计模式和框架底层都会用到</p></li><li><p>加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个Class对象就像一面镜子，透过这个镜子看到类的结构，所以形象地称之为反射</p></li></ul></li><li><p>反射机制原理示意图</p><ul><li></li></ul></li><li><p>通过反射可以做到</p><ul><li><p>在运行时判断任意一个对象所属的类</p></li><li><p>在运行时构造任意一个类的对象</p></li><li><p>在运行时得到任意一个类所具有的成员变量和方法</p></li><li><p>在运行时调用任意一个对象的成员变量和方法</p></li><li><p>生产动态代理</p></li></ul></li><li><p>反射相关主要类</p><ul><li><p>java.lang.Class</p><ul><li>代表一个类，Class对象表示某个类加载后在堆中的对象</li></ul></li><li><p>java.lang.reflect.Method</p><ul><li>代表类的方法，Method对象本身某个类的方法</li></ul></li><li><p>java.lang.reflect.Field</p><ul><li>代表类的成员变量，Field对象表示某个类的成员变量</li></ul></li><li><p>java.lang.reflect.Constructor</p><ul><li>代表类的构造器，Constructor对象本身某个类的构造器</li></ul></li></ul></li><li><p>反射的优点和缺点</p><ul><li><p>优点</p><ul><li>可以动态地创建和使用对象（也是框架底层核心），使用灵活，没有反射机制，框架技术就失去底层支撑</li></ul></li><li><p>缺点</p><ul><li>使用反射基本是解释执行，对执行速度有影响</li></ul></li></ul></li><li><p>反射调用优化——关闭访问检查</p><ul><li><p>Method和Field、Constructor对象都有setAccessible()方法</p></li><li><p>setAccessible作用是启动和禁用访问安全检查的开关</p></li><li><p>参数值为true表示反射的对象在使用时取消访问检查，提高反射的效率。参数值为false则表示反射的对象执行访问检查</p></li></ul></li></ul><h3 id="23-3-Class类">23.3 Class类</h3><ul><li><p>基本介绍</p><ul><li><p>Class类也是类，因此也继承Object类</p></li><li><p>Class类对象不是new出来的，而是系统创建的</p></li><li><p>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</p></li><li><p>每个类的实例都会记得自己是由哪个Class对象所生成的</p></li><li><p>通过Class对象可以通过API完整地得到一个类的完整结构</p></li><li><p>Class对象是存放在堆里的</p></li><li><p>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码，变量名，方法名，访问权限等）</p></li><li></li></ul></li><li><p>常用方法</p><ul><li><p>forName(String name)</p><ul><li>返回指定类名name的Class对象</li></ul></li><li><p>newInstance</p><ul><li>调用无参构造器，返回该Class对象的一个实例</li></ul></li><li><p>getName</p><ul><li>返回此Class对象所表示的实体（类、接口、数组、基本类型等）的全类名</li></ul></li><li><p>getInterfaces</p><ul><li>获取当前Class对象的所有实现接口的Class对象，返回Class数组</li></ul></li><li><p>getClassLoader</p><ul><li>返回该类的类加载器</li></ul></li><li><p>getSuperclass</p><ul><li>返回表示此Class所表示的实体的父类的Class</li></ul></li><li><p>getConstructors</p><ul><li>返回该Class对象的实例的所有公开的构造器</li></ul></li><li><p>getDeclaredFields</p><ul><li>返回该Class对象的实例的所有属性</li></ul></li><li><p>getMethod(String name, paramTypes…)</p><ul><li>根据name和形参类型返回该类的某个方法</li></ul></li><li><p>getPackage</p><ul><li>获得该Class对象的包名</li></ul></li></ul></li></ul><h3 id="23-4-获取Class类对象">23.4 获取Class类对象</h3><ul><li><p>情况1：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName(String fullName)获取，注意，可能抛出ClassNotFoundException</p><ul><li>应用场景：多用于配置文件，读取类的全路径，加载Class对象</li></ul></li><li><p>情况2：已知具体的类，可通过类的class获取，该方式最为安全可靠，程序性能最高。实例：Class cls = Cat.class;</p><ul><li>应用场景：多用于参数传递，比如通过反射得到对应的构造器对象</li></ul></li><li><p>情况3：已知某个类的实例，可调用该实例的getClass()方法获取Class对象</p><ul><li>应用场景：有现成的创建好的对象实例</li></ul></li><li><p>其他方式：<br>ClassLoader cl = 对象.getClass().getClassLoader();<br>class cls = cl.loadClass(String fullName);</p></li><li><p>基本数据类型通过如下方法获取Class对象<br>Class cls = 基本数据类型.class;</p></li><li><p>基本数据类型对应的包装类，可以通过.TYPE得到Class类对象<br>Class cls = 包装类.TYPE;</p></li></ul><h3 id="23-5-哪些类型有Class对象？">23.5 哪些类型有Class对象？</h3><ul><li><p>外部类、成员内部类、静态内部类、局部内部类、匿名内部类</p></li><li><p>接口</p></li><li><p>数组</p></li><li><p>枚举类</p></li><li><p>注解</p></li><li><p>基本数据类型</p></li><li><p>void</p></li></ul><h3 id="23-6-类加载">23.6 类加载</h3><ul><li><p>基本说明</p><ul><li><p>反射机制是Java实现动态语言的关键，也就是通过反射实现类动态加载</p><ul><li><p>静态加载</p><ul><li>编译时加载相关的类，如果没有相关类则会报错，依赖性很强</li></ul></li><li><p>动态加载</p><ul><li>运行时加载需要的类，如果运行时不用该类，即使该类不存在，也不会报错，降低了依赖性</li></ul></li></ul></li></ul></li><li><p>类加载时机</p><ul><li><p>创建对象时（静态加载）</p></li><li><p>当子类被加载时，父类也会加载（静态加载）</p></li><li><p>调用类中的静态成员时（静态加载）</p></li><li><p>通过反射得到类的Class对象时（动态加载）</p></li></ul></li><li><p>类加载过程图</p><ul><li></li></ul></li><li><p>类加载各阶段完成的任务</p><ul><li><p>加载</p><ul><li><p>将类的class文件读入内存，并位置创建一个java.lang.Class对象。此过程由类加载器完成</p><ul><li>主要目的是将字节码从不同的数据源（可能是class文件、也可能是jar包，甚至是网络）转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</li></ul></li></ul></li><li><p>连接</p><ul><li><p>将类的二进制数据合并到JRE中</p><ul><li><p>三个阶段</p><ul><li><p>验证</p><ul><li><p>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p></li><li><p>验证包括：文件格式验证（是否以魔数oxcafebabe开头）、元数据验证、字节码验证和符号引用验证</p></li><li><p>可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，缩短虚拟机加载类的时间</p></li></ul></li><li><p>准备</p><ul><li>JVM会在该阶段对静态变量分配内存并默认初始化（对应数据类型的默认初始值）。这些变量所使用的内存都将在方法区中进行分配</li></ul></li><li><p>解析</p><ul><li>虚拟机将常量池内的符号引用替换为直接引用的过程</li></ul></li></ul></li></ul></li></ul></li><li><p>初始化</p><ul><li><p>JVM负责对类进行初始化，主要是静态成员的初始化</p><ul><li><p>一直到初始化阶段，才真正开始执行类中的Java程序代码，初始化阶段是执行clinit()方法的过程</p></li><li><p>clinit()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并（即最终每个静态变量只会保留最后的赋值语句）</p></li><li><p>虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁同步，不会出现多个线程同时去执行类的clinit()方法，导致初始化错误的情况。</p></li></ul></li></ul></li></ul></li></ul><h3 id="23-7-通过反射获取类的结构信息">23.7 通过反射获取类的结构信息</h3><ul><li><p>通过Class类获取</p><ul><li><p>getName</p><ul><li>获取全类名</li></ul></li><li><p>getSimpleName</p><ul><li>获取简单类名</li></ul></li><li><p>getFields</p><ul><li>获取本类以及父类所有public修饰的属性</li></ul></li><li><p>getDeclaredFields</p><ul><li>获取本类中的所有属性（不限修饰符）</li></ul></li><li><p>getMethods</p><ul><li>获取本类和父类的所有public修饰的方法</li></ul></li><li><p>getDeclaredMethods</p><ul><li>获取本类中的所有方法（不限修饰符）</li></ul></li><li><p>getConstructors</p><ul><li>获取本类所有的public修饰的构造器</li></ul></li><li><p>getDeclaredConstructors</p><ul><li>获取本类中所有构造器（不限修饰符）</li></ul></li><li><p>getPackage</p><ul><li>以Package形式返回包信息</li></ul></li><li><p>getSuperClass</p><ul><li>以Class形式返回父类Class对象</li></ul></li><li><p>getInterfaces</p><ul><li>以Class[]形式返回所有实现接口</li></ul></li><li><p>getAnnotations</p><ul><li>以Annotation[]形式返回注解信息</li></ul></li></ul></li><li><p>通过Feild类获取</p><ul><li><p>getModifiers</p><ul><li><p>以int的形式返回修饰符</p><ul><li>0=默认，1=public，2=private，4=protected，8=static，16=final<br>有多个则相加</li></ul></li></ul></li><li><p>getType</p><ul><li>以Class形式返回类型</li></ul></li><li><p>getName</p><ul><li>返回属性名</li></ul></li></ul></li><li><p>通过Method类获取</p><ul><li><p>getModifiers同上</p></li><li><p>getReturnType</p><ul><li>以Class形式返回 返回类型</li></ul></li><li><p>getName</p></li><li><p>返回方法名</p></li><li><p>getParameterTypes</p><ul><li>以Class[]形式返回参数类型数组</li></ul></li></ul></li><li><p>通过Constructor类获取</p><ul><li><p>getModifiers同上</p></li><li><p>getName</p><ul><li>返回构造器全名</li></ul></li><li><p>getParameterTypes同上</p></li></ul></li></ul><h3 id="23-8-通过反射创建对象">23.8 通过反射创建对象</h3><ul><li><p>方式一</p><ul><li>调用类中的public修饰的无参构造器</li></ul></li><li><p>方式二</p><ul><li>调用类中的指定构造器</li></ul></li><li><p>相关的Class类方法</p><ul><li><p>newInstance</p><ul><li>调用类中的无参构造器，获取对应类的对象</li></ul></li><li><p>getConstructor(class …clazz)</p><ul><li>根据参数列表，获取对应的public构造器对象</li></ul></li><li><p>getDeclaredConstructor(Class …clazz)</p><ul><li>根据参数列表，获取对应的构造器对象（不限修饰符）</li></ul></li></ul></li><li><p>相关的Constructor类方法</p><ul><li><p>setAccessible(true)</p><ul><li>爆破</li></ul></li><li><p>newInstance(Object …obj)</p><ul><li>调用构造器，传入对应实参来初始化</li></ul></li></ul></li></ul><h3 id="23-9-通过反射访问类中的成员">23.9 通过反射访问类中的成员</h3><ul><li><p>访问属性</p><ul><li><p>步骤</p><ul><li><p>根据属性名获取Field对象<br>Field f = clazz.getDeclaredField(属性名)</p></li><li><p>（可选）爆破<br>f.setAccessible(true)</p></li><li><p>访问<br>f.set(对象实例，值)<br>f.get(对象实例)</p></li><li><p>注意</p><ul><li>如果访问的是静态属性，则set和get方法中的对象实例可以写成null</li></ul></li></ul></li></ul></li><li><p>访问方法</p><ul><li><p>步骤</p><ul><li><p>根据方法名和参数列表获取Method对象<br>Method m = clazz.getDeclaredMethod(name, XX.class…)</p></li><li><p>获取对象<br>Object o = clazz.newInstance();</p></li><li><p>爆破（可选）m.setAccessible(true)</p></li><li><p>访问<br>Object returnVal = m.invoke(对象实例，实参)</p></li><li><p>注意</p><ul><li>如果是静态方法，则invoke方法的对象实例可以写成null</li></ul></li></ul></li></ul></li></ul><h2 id="补充：Java8新特性">补充：Java8新特性</h2><h3 id="lambda表达式">lambda表达式</h3><h3 id="函数式接口">函数式接口</h3><h3 id="方法引用">方法引用</h3><h3 id="构造器引用和数组引用">构造器引用和数组引用</h3><h3 id="StreamAPI">StreamAPI</h3><h3 id="Optional类">Optional类</h3><h3 id="新日期API">新日期API</h3><h3 id="JDK底层代码优化">JDK底层代码优化</h3>]]></content>
      
      
      <categories>
          
          <category> Programming Language </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart Programming Language Basic Syntax</title>
      <link href="/2025/03/02/Dart-Programming-Language-Basic-Syntax/"/>
      <url>/2025/03/02/Dart-Programming-Language-Basic-Syntax/</url>
      
        <content type="html"><![CDATA[<h1>Dart</h1><h2 id="概述">概述</h2><h3 id="简介">简介</h3><ul><li>Dart 是谷歌开发的、类型安全的、面向对象的编程语言，被应用与 Web、服务器、移动应用和物联网等领域</li><li>Dart 诞生于 2011 年</li><li>Dart 是类似 TypeScript 的强类型语言</li><li>Dart 的运行方式<ul><li>原生虚拟机（类似 JVM，Dart 代码可以运行在 Windows、Mac、Linux上）</li><li>JavaScrpit 引擎（Dart 代码可以转成 JS 代码，然后运行在浏览器上）</li></ul></li></ul><h3 id="Dart-与-JavaScript">Dart 与 JavaScript</h3><p>以下是 Dart 各方面与 JavaScript 的比较</p><img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/Dart%E4%B8%8EJavaScript.png" class=""><!-- ![image-20240406170813634](./assets/Dart与JavaScript.png) --><h2 id="Dart-基础语法">Dart 基础语法</h2><h3 id="引例">引例</h3><p>以下入门程序告诉了我们 Dart 的基本语法内容</p><ul><li><p>用 <code>//</code> 来注释语句</p></li><li><p>声明函数不需要关键字</p></li><li><p>函数和参数前面都有类型声明</p></li><li><p>打印使用 <code>print</code></p></li><li><p>每行代码结束时，必须以分号结束</p></li><li><p>字符串通过引号包起来，支持模板字符串（$+变量名）</p></li><li><p><code>main</code> 是入口函数，Dart 应用程序总是从 <code>main</code> 函数开始执行</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="keyword">void</span> printInteger(<span class="built_in">int</span> aNumber) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;The number is <span class="subst">$aNumber</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口文件-应用从这里开始执行</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">42</span>;</span><br><span class="line">  printInteger(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="运行">运行</h3><p>在命令行中输入 <code>dart xxx.dart</code> 来运行 Dart 程序</p><h3 id="注释">注释</h3><ul><li>单行注释 —— // xxx</li><li>多行注释 —— /*xxx*/</li><li>文档注释 —— ///<ul><li>可通过 dartdoc 命令将文档注释转成文档（文档注释支持 markdown 语法）</li></ul></li></ul><h3 id="变量">变量</h3><ul><li>变量是一个引用，Dart 中万物皆对象，变量存储的是对象的引用</li><li>声明变量的方式<ul><li>明确指定类型声明</li><li>自动类型推断 <code>var</code></li><li>动态类型 <code>dynamic</code></li></ul></li><li>变量名大小写敏感</li><li>变量默认值是 <code>null</code></li><li>Dart 变量的值不会进行隐式转换（null 不会转成 false，0 不会转成 false 等等）</li></ul><h3 id="常量">常量</h3><ul><li><p>常量就是值不可变的变量（一旦声明，其值不能修改）</p></li><li><p>声明常量方式</p><ul><li>使用 <code>const</code> 关键字</li><li>使用 <code>final</code> 关键字</li></ul></li><li><p>const 和 final 的区别</p><ul><li><p><code>const</code> 是编译期不可变</p></li><li><p><code>final</code> 是运行时不可变</p></li></ul><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="built_in">DateTime</span>.now(); <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">final</span> time = <span class="built_in">DateTime</span>.now()l <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="数据类型">数据类型</h2><h3 id="Number">Number</h3><h4 id="Dart-中的数字由三个关键字描述">Dart 中的数字由三个关键字描述</h4><ul><li><code>num</code> 数字类型（既可以是整数，也可以是小数）<ul><li><code>int</code> 整数</li><li><code>double</code> 浮点数</li></ul></li><li><code>num</code> 可以在赋值的时候进行类型推断，推断为 <code>int</code> 或 <code>double</code></li><li><code>int</code> 和 <code>double</code> 必须在赋值时给定正确的值</li><li>当不确定赋值的值是整数还是小数时，就可以用 <code>num</code></li></ul><h4 id="常用-API：在官方文档中查阅">常用 API：在官方文档中查阅</h4><p>常用：</p><ul><li>类型转换：toxxx()</li><li>四舍五入：round()</li><li>返回余数：remainder()</li><li>数字比较：compareTo()</li><li>返回最大公因数：gcd()</li><li>科学计数法：toStringAsExponential()</li></ul><h3 id="String">String</h3><h4 id="使用-String-声明字符串">使用 String 声明字符串</h4><ul><li>单引号，双引号均可</li><li>三个引号可以声明包含换行符的字符串（多行字符串）</li></ul><h4 id="常用-API：官方文档查阅">常用 API：官方文档查阅</h4><p>常用：</p><ul><li>字符串分割：split()</li><li>字符串拼接： + 运算符</li><li>字符串裁切：trim()</li><li>判断字符串是否为空：isEmpty（是属性，不要括号）</li><li>字符串替换：replaceAll() （支持正则替换）</li><li>字符串匹配：hasMatch()</li><li>查找子串：contains()</li><li>定位子串：indexOf()</li></ul><h4 id="正则表达式">正则表达式</h4><ul><li>语法：<code>RegExp(r'正则表达式')</code></li><li>例子：匹配一到多个数字：<code>RegExp(r'\d+')</code></li></ul><h3 id="Boolean">Boolean</h3><ul><li>Dart 通过 <code>bool</code> 关键字来表示布尔类型</li><li>布尔类型只有两个值：<code>true</code> 和 <code>false</code></li><li>对变量进行判断时，要显式地检查布尔值，即写表达式来判断</li><li>一些特殊的判断<ul><li>字符串：isEmpty, isNotEmpty</li><li>数字：isNaN, isFinite …</li></ul></li></ul><h3 id="List">List</h3><h4 id="Dart-中的数组，由-List-对象表示。List-有两种声明方式">Dart 中的数组，由 List 对象表示。List 有两种声明方式</h4><ul><li><p>字面量方式</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span> list = []; <span class="comment">// 不限定元素的数据类型</span></span><br><span class="line"><span class="built_in">List</span> list = &lt;<span class="built_in">int</span>&gt;[]; <span class="comment">// 限定元素的类型为int，&lt;&gt;内的称为泛型</span></span><br></pre></td></tr></table></figure></li><li><p>构造函数方式</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span> list = <span class="keyword">new</span> <span class="built_in">List</span>.empty(growable: <span class="keyword">true</span>); <span class="comment">// 不限制长度的空列表</span></span><br><span class="line"><span class="built_in">List</span> list = <span class="keyword">new</span> <span class="built_in">List</span>.filled(<span class="number">3</span>, <span class="number">0</span>); <span class="comment">// 声明指定长度的填充列表</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="扩展操作符（…）">扩展操作符（…）</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> list2 = [<span class="number">0</span>, ...list1]; <span class="comment">// [0, 1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list3;</span><br><span class="line"><span class="keyword">var</span> list4 = [<span class="number">0</span>, ...?list3]; <span class="comment">// 空安全的扩展运算符，list3为null时不会报错，list4为[0]</span></span><br></pre></td></tr></table></figure><h4 id="常用-API：查阅官方文档">常用 API：查阅官方文档</h4><p>常用：</p><ul><li>列表长度：length（属性）</li><li>列表翻转：reversed（属性，且得到的是一个可迭代对象，不是List）</li><li>转为列表：toList()</li><li>添加元素：add(), addAll()</li><li>删除元素：remove(), removeAt()</li><li>在指定位置添加元素：insert()</li><li>清空：clear()</li><li>合并列表中的元素：join()（返回字符串）</li></ul><h4 id="遍历列表">遍历列表</h4><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>forEach()</td><td>遍历列表</td></tr><tr><td>map()</td><td>遍历并处理元素，然后生成新的列表</td></tr><tr><td>where()</td><td>返回满足条件的数据，传布尔函数</td></tr><tr><td>any()</td><td>只要有一项满足条件，即返回 true，传布尔函数</td></tr><tr><td>every()</td><td>判断是否每一项都满足条件，都满足才返回 true，传布尔函数</td></tr><tr><td>expand()</td><td>将二维数组降维为一维数组</td></tr><tr><td>fold()</td><td>对列表中的每一个元素，做一个累计操作（类似于归约）</td></tr></tbody></table><p>同样可以用 for 循环来遍历</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Set">Set</h3><h4 id="简介-2">简介</h4><ul><li>Set 是一个无序的、元素唯一的集合</li><li>Set 有字面量和构造函数两种声明方式（字面量用大括号包裹）<ul><li><code>var set1 = &lt;int&gt;&#123;1, 2, 3&#125;;</code></li><li><code>var set2 = new Set();</code></li></ul></li><li>无法通过下标取值</li><li>具有集合特有的操作<ul><li>如求交并差等</li></ul></li></ul><h4 id="常用-API-查阅官方文档">常用 API 查阅官方文档</h4><p>常用：</p><ul><li>列表转换成集合：toSet()（可以过滤掉列表中重复的元素）</li><li>批量添加：addAll()，参数可以是列表，也可以是集合</li><li>求交集：intersection()</li><li>求并集：union()</li><li>求差集：difference()</li><li>返回第一个元素：first（属性）</li><li>返回最后一个元素：last（属性）</li></ul><h3 id="Map">Map</h3><h4 id="简介-3">简介</h4><ul><li><p>Map 是一个无序的<strong>键值对映射</strong>，通常被称作<strong>哈希</strong>或<strong>字典</strong></p></li><li><p>声明方式</p><ul><li><code>var map = &#123;key1:value1, key2:value2&#125;;</code></li></ul><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map[<span class="string">&#x27;key&#x27;</span>] = value;</span><br></pre></td></tr></table></figure></li></ul><h4 id="常用-API-查阅官方文档-2">常用 API 查阅官方文档</h4><p>常用：</p><ul><li>访问属性：map[‘key’]</li><li>判断 Map 中的 key 是否存在：containsKey(‘key’)</li><li>如果 key 不存在，才赋值：putIfAbsent()</li><li>获取 Map 中所有的 key：keys（属性）</li><li>获取 Map 中所有的 value：values（属性）</li><li>根据条件进行删除：removeWhere()</li></ul><h3 id="其他">其他</h3><h4 id="Runes">Runes</h4><ul><li>Runes 对象是一个 32 位字符对象。它可以把文字转换成符号表情或特定的文字（使用 UTF32编码）</li><li>参考网站：<a href="https://copychar.cc/">https://copychar.cc/</a></li></ul><h4 id="Symbol">Symbol</h4><ul><li>在 Dart 中符号用 # 开头来表示的标识符</li><li>用于反射</li></ul><h4 id="dynamic">dynamic</h4><ul><li>动态数据类型，即弱类型，此类型的变量可以被赋值为任意数据类型</li></ul><h2 id="运算符">运算符</h2><h3 id="地板除（-）">地板除（~/）</h3><p>用于得到除法结果的向下取整的整数</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> ~/ <span class="number">4</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="类型判断运算符（is-和-is-）">类型判断运算符（is 和 is!）</h3><p>判断类型，类似 Java 中的  instanceOf()</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [];</span><br><span class="line">list <span class="keyword">is</span> <span class="built_in">List</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="避空运算符（-和-）">避空运算符（?? 和 ??=）</h3><p>?? 是三元运算符的语法糖，??= 用于赋值语句</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ??前面的不为空，则值为前面的，为空则值为后面的</span></span><br><span class="line"><span class="number">1</span> ?? <span class="number">3</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">null</span> ?? <span class="number">12</span>; <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量为空，则赋值，不为空则不赋值</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a ??= <span class="number">3</span>; <span class="comment">// a为3</span></span><br><span class="line">a ??= <span class="number">5</span>; <span class="comment">// 赋值失败</span></span><br></pre></td></tr></table></figure><h3 id="条件属性访问（-）">条件属性访问（?.）</h3><p>判断属性是否存在，存在才访问，否则不访问，返回 null，避免报错</p><h3 id="级联运算符（…）">级联运算符（…）</h3><p>用于连续调用对象的方法，链式调用，每次方法返回的不是方法返回值，而是当前对象的引用</p><h2 id="函数">函数</h2><h3 id="声明函数">声明函数</h3><h4 id="直接声明">直接声明</h4><ul><li><p>Dart 中声明函数不需要 function 关键字</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> printInfo() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="箭头函数">箭头函数</h4><ul><li><p>Dart 中的箭头函数中，<strong>函数体只能写一行且不能带有结束的分号</strong></p></li><li><p>Dart 中的箭头函数，只是函数的一种简写形式</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">list.forEach((element) =&gt; <span class="built_in">print</span>(element));</span><br></pre></td></tr></table></figure></li></ul><h4 id="匿名函数">匿名函数</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = (value) &#123;</span><br><span class="line">  <span class="built_in">print</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="立即执行函数">立即执行函数</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当语句执行到此时，该函数会立即执行，打印17</span></span><br><span class="line">((<span class="built_in">int</span> n) &#123;</span><br><span class="line">  <span class="built_in">print</span>(n);</span><br><span class="line">&#125;) (<span class="number">17</span>);</span><br></pre></td></tr></table></figure><h3 id="函数参数">函数参数</h3><h4 id="必填参数">必填参数</h4><p>用法：数据类型 参数名称</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> userInfo(<span class="built_in">String</span> name) &#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可选参数">可选参数</h4><p>语法：[数据类型 参数名称, …]</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可选参数如果不给dynamic类型的话，必须赋初值</span></span><br><span class="line"><span class="built_in">String</span> userInfo(<span class="built_in">String</span> name, [<span class="built_in">int</span> age = <span class="number">0</span>]) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;<span class="subst">$name</span>, <span class="subst">$age</span>&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用，可选参数按顺序赋值</span></span><br><span class="line">userInfo(<span class="string">&#x27;tom&#x27;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h4 id="命名参数">命名参数</h4><p>语法：{数据类型 参数名称, …}</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命名参数调用时，需要与声明时的形参名一致</span></span><br><span class="line"><span class="comment">// 同理，命名参数如果不给dynamic类型的话，必须赋初值</span></span><br><span class="line"><span class="built_in">String</span> userInfo(<span class="built_in">String</span> name, &#123;<span class="built_in">int</span> age = <span class="number">0</span>&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;<span class="subst">$name</span>, <span class="subst">$age</span>&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">userInfo(<span class="string">&#x27;tom&#x27;</span>, age: <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h4 id="函数参数-2">函数参数</h4><p>将函数当作参数传递，传参的函数也叫回调函数</p><h3 id="作用域与闭包">作用域与闭包</h3><h4 id="作用域">作用域</h4><p><strong>内层作用域可以访问外层的变量内容</strong>，但外层不能访问内层的变量内容，即 Java 中作用域的内容。</p><h4 id="闭包">闭包</h4><ul><li><p>Dart 中闭包的实现方式与 JavaScript 中完全一致</p></li><li><p>使用时机：<strong>既能重用变量，又保护变量不被全局污染</strong></p></li><li><p>实现原理：外层函数被调用后，外层函数的作用域对象（AO）被内层函数引用着，导致外层函数的作用域对象无法释放，从而形成闭包</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包可以持久化外层函数的变量，避免函数调用后内部变量被清除</span></span><br><span class="line">parent() &#123;</span><br><span class="line">  <span class="keyword">var</span> money = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> () &#123;</span><br><span class="line">    money -= <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">print</span>(money);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = parent();</span><br><span class="line">p(); <span class="comment">// 900</span></span><br><span class="line">p(); <span class="comment">// 800</span></span><br><span class="line">p(); <span class="comment">// 700</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="异步函数">异步函数</h3><h4 id="简介-4">简介</h4><ul><li>Dart 中，异步调用通过 Future 来实现</li><li>async 函数返回一个 Future，await 用于等待 Future</li><li>关于 Future 的详情可到官网文档查看</li></ul><h4 id="接收处理异步结果">接收处理异步结果</h4><h5 id="使用-then">使用 then</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future getIpAddress() &#123;</span><br><span class="line">  <span class="keyword">final</span> url = <span class="string">&#x27;https://httpbin.org/ip&#x27;</span>;</span><br><span class="line">  <span class="comment">// then中的函数需要返回某些值，不然外部调用getIPAddress函数得到的返回值是null</span></span><br><span class="line">  <span class="comment">// then中的函数返回的值会被包装成Future类型</span></span><br><span class="line">  <span class="keyword">return</span> http.<span class="keyword">get</span>(url).then( (response) &#123;</span><br><span class="line">    <span class="built_in">print</span>(response.body);</span><br><span class="line">    <span class="keyword">return</span> response.body</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用-async-和-await">使用 async 和 await</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future getIpAddress() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> url = <span class="string">&#x27;https://httpbin.org/ip&#x27;</span>;</span><br><span class="line">  <span class="keyword">final</span> response = <span class="keyword">await</span> http.<span class="keyword">get</span>(url);</span><br><span class="line">  <span class="built_in">print</span>(response.body);</span><br><span class="line">  <span class="keyword">return</span> response.body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类与对象">类与对象</h2><h3 id="类">类</h3><h4 id="简介-5">简介</h4><ul><li>类是通过 class 声明的代码段，包含属性和方法</li><li>对象是类的实例化结果</li></ul><h4 id="构造器">构造器</h4><h5 id="普通构造函数">普通构造函数</h5><p>默认构造函数，与类同名，在实例化时自动被调用</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  Point (<span class="built_in">num</span> x, <span class="built_in">num</span> y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 上面的构造器可以简写为下面这样</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="命名构造函数">命名构造函数</h5><p>在类中使用命名构造器（类型.函数名）可以实现多个构造器，可以提供额外的<strong>清晰度</strong></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  <span class="comment">// 默认构造函数</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Point.fromJson(&#123;<span class="built_in">num</span> x = <span class="number">0</span>, <span class="built_in">num</span> y = <span class="number">0</span>&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="常量构造函数">常量构造函数</h5><p>如果类生成的对象<strong>不会改变</strong>（类中的属性都为常量），则可以通过常量构造函数使这些对象称为编译时常量，可以提高性能。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>() </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="comment">// 常量构造函数不能有函数体</span></span><br><span class="line">  <span class="keyword">const</span> Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 使用const关键字来通过常量构造函数构造不可变对象</span></span><br><span class="line">  <span class="keyword">var</span> p1 = <span class="keyword">const</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = <span class="keyword">const</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(p1 == p2); <span class="comment">// true</span></span><br><span class="line">  <span class="comment">// 不用const关键字，则使用的是普通构造函数</span></span><br><span class="line">  <span class="comment">// new可省略</span></span><br><span class="line">  <span class="keyword">var</span> p3 = Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> p4 = Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(p3 == p4); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="工厂构造函数">工厂构造函数</h5><p>工厂构造函数<strong>形式上是普通构造函数</strong>，但是通过 <code>factory</code> 声明，调用工厂构造函数不会返回自动实例对象，而是通过代码来决定返回的实例，主要用于配合实现类的<strong>单例模式</strong>，避免多次创建对象造成资源浪费，提高性能。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">static</span> Person instance; <span class="comment">// 单例</span></span><br><span class="line">  <span class="comment">// 工厂构造函数</span></span><br><span class="line">  <span class="keyword">factory</span> Person([<span class="built_in">String</span> name = <span class="string">&#x27;tom&#x27;</span>]) &#123;</span><br><span class="line">    <span class="comment">// 工厂构造函数中，不能使用this关键字</span></span><br><span class="line">    <span class="comment">// print(this.name);</span></span><br><span class="line">    <span class="comment">// 第一次实例化</span></span><br><span class="line">    <span class="keyword">if</span> (Person.name == <span class="keyword">null</span>) &#123;</span><br><span class="line">      Person.instance = <span class="keyword">new</span> Person.newSelf(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非第二次实例化</span></span><br><span class="line">    <span class="keyword">return</span> Person.instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Person.newSelf(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问修饰">访问修饰</h4><ul><li>Dart 与 TypeScript 不同，没有访问修饰符</li><li>Dart 类中，默认的访问修饰符（即不加任何内容）是公开的（public）</li><li>如果属性或方法以 <code>_</code> 开头，则表示为私有（private）</li><li><strong>只有把类单独抽离出去，私有属性和方法才起作用</strong>（即如果类写在主函数所在的文件中，私有属性和方法是不起作用的）（方法为写在另一个文件中，然后在主函数所在的文件中引用）</li></ul><h4 id="Getter-和-Setter">Getter 和 Setter</h4><p>Getter 是通过 <code>get</code> 关键字修饰的方法</p><ul><li>该函数不能有括号，访问时也不用加括号（即<strong>像访问属性一样访问方法</strong>）</li></ul><p>Setter 是通过 <code>set</code> 关键字修饰的方法</p><ul><li><p>访问时，<strong>像设置属性一样给函数传参</strong></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> PI = <span class="number">3.1415</span>;</span><br><span class="line">  <span class="built_in">num</span> r;</span><br><span class="line">  </span><br><span class="line">  Circle(<span class="keyword">this</span>.r);</span><br><span class="line">  <span class="comment">// 使用get声明的方法不能有括号</span></span><br><span class="line">  <span class="comment">// Getter</span></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> area &#123;</span><br><span class="line">    <span class="keyword">return</span> PI * r * r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Setter</span></span><br><span class="line">  <span class="keyword">set</span> setR(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.r = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> c = Circle(<span class="number">10</span>);</span><br><span class="line">  <span class="comment">// getter调用</span></span><br><span class="line">  <span class="built_in">print</span>(c.area);</span><br><span class="line">  <span class="comment">// setter调用</span></span><br><span class="line">  c.setR = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="初始化列表">初始化列表</h4><ul><li><p>作用：在构造函数中设置属性的默认值</p></li><li><p>时机：在构造函数体执行之前执行</p></li><li><p>语法：使用逗号分隔初始化表达式</p></li><li><p>场景：常用于<strong>设置 final 常量的值</strong></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> height;</span><br><span class="line">  <span class="built_in">int</span> width;</span><br><span class="line">  <span class="comment">// 初始化列表</span></span><br><span class="line">  Rect() : height = <span class="number">4</span>, width = <span class="number">12</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表的特殊用法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y, z;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="keyword">this</span>.z);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化列表特殊用法：重定向构造函数</span></span><br><span class="line">  Point.twoDimentionPoint(<span class="built_in">num</span> x, <span class="built_in">num</span> y) : <span class="keyword">this</span>.(x, y, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="static">static</h4><p><strong>与 Java 一致</strong></p><p><code>static</code> 关键字用来指定静态成员</p><ul><li>通过 static 修饰的属性是静态属性</li><li>通过 static 修饰的方法是静态方法</li></ul><p>静态成员可以通过类名直接访问（不需要实例化）</p><ul><li>实例化是比较消耗资源的，声明静态成员，可以提高程序性能</li></ul><p>静态方法不能访问非静态成员，非静态方法可以访问静态成员</p><ul><li>静态方法中不能使用 this 关键字</li><li>不能使用 this 关键字来访问静态属性</li></ul><h4 id="元数据">元数据</h4><p><strong>类似 Java 中的注解</strong></p><p>元数据以 @ 开头，可以给代码标记一些额外的信息</p><ul><li>元数据可以用在库、类、构造器、函数、字段、参数或变量声明的前面</li></ul><p>一些元数据</p><ul><li><code>@override</code>：表示方法重写</li><li><code>@required</code>：指示某个命名参数是必填的</li><li><code>@deprecated</code>：表示方法或类不建议使用</li></ul><h3 id="继承">继承</h3><p>根据类的先后顺序，可以将类分成父类和子类</p><p>子类通过 <code>extends</code> 关键字继承父类</p><ul><li>继承后，子类可以使用父类中可见的属性和方法</li></ul><p>子类中，可以通过 <code>@override</code> 元数据来标记 ”重写“ 的方法</p><ul><li>重写方法：子类中与父类中同名的方法</li></ul><p>子类中，可以通过 <code>super</code> 关键字来引用父类中可见的属性和方法（包括各种构造器）</p><h3 id="抽象类">抽象类</h3><p>抽象类是用 <code>abstract</code> 关键字修饰的类</p><p>抽象类的作用是充当普通类的<strong>模板</strong>，约定一些必要的属性和方法</p><p><strong>抽象方法</strong>是指<strong>没有方法体</strong>的方法</p><ul><li>抽象类中一般都有抽象方法，也可以没有抽象方法，还可以有普通方法</li><li>普通类中，不能有抽象方法</li></ul><p>抽象类不能被实例化</p><p>抽象类可以被普通类继承</p><ul><li>如果普通类继承抽象类，必须实现抽象类中<strong>所有的抽象方法</strong></li></ul><p>抽象类还可以<strong>充当接口被实现</strong></p><ul><li>如果把抽象类当作接口实现的话，普通类必须得实现抽象类里面定义的<strong>所有属性和方法</strong></li></ul><h3 id="接口">接口</h3><p>接口在 Dart 中就是一个类（只是用法不同）</p><ul><li>与 Java 不同，Java 中的接口需要用 interface 关键字声明，Dart 中不需要</li><li>接口可以是任意类，但一般使用抽象类做接口</li></ul><p>一个类可以实现（implements）多个接口，多个接口用逗号分隔</p><ul><li>接口可以看成一个个小零件。类实现接口就相当于组装零件</li></ul><p>普通类实现接口后，必须重写接口中<strong>所有的属性和方法</strong></p><h3 id="混入">混入</h3><p>混入（Mixin）是一段公共代码。混入的声明方式：</p><ul><li>使用 mixin 关键字声明 mixin MixinB {…}</li></ul><p>混入（Mixin）可以提高代码复用的效率，普通类可以通过 <code>with</code> 来使用混入</p><p>使用多个混入时，后引入的混入会覆盖之前混入中的重复的内容</p><p>混入后，可以使用混入的类中的属性和方法（Dart 单继承的补充）</p><h3 id="泛型">泛型</h3><p>泛型是在函数、类、接口中指定<strong>宽泛数据类型</strong>的语法</p><ul><li>泛型函数</li><li>泛型类</li><li>泛型接口</li></ul><p>通常，在尖括号中，使用一个字母来代表类型</p><p>作用：提高代码的复用性，还可以限制集合类的元素数据类型</p><p>除了可以指定单一数据类型外，泛型还可以<strong>限定传入的数据类型必须是某个类的子类或其本身</strong>，语法：<code>class name&lt;T extends xxx&gt; &#123;&#125;</code></p><h3 id="枚举">枚举</h3><p>枚举是数量固定的常量值，通过 <code>enum</code> 关键字声明</p><ul><li><code>enum Color &#123; red, green, blue &#125;</code></li></ul><p>枚举的 values 常量，可以获取所有枚举值列表</p><ul><li><code>List&lt;Color&gt; colors = Color.values;</code></li></ul><p>可以通过 index 获取值的索引（索引的值从 0 开始，与枚举常量声明的顺序有关）</p><ul><li><code>assert(Color.green.index == 1);</code></li></ul><h3 id="扩展（extension）">扩展（extension）</h3><ul><li>extension 关键字在 Dart 2.7 及其以上才支持</li><li>extension 可以扩展对象的内容<ul><li>如：<code>extension StringExtension on String &#123;// 扩展内容&#125;</code></li><li>扩展不仅可以定义方法，还可以定义 setter, getter, operator</li></ul></li><li>使用<ul><li>声明扩展，即上面的 <code>extension ... on ...</code> 语法</li><li>引入扩展，即 dart 引入包的语法，可以用相对路径，也可以用绝对路径</li><li>使用扩展（String.扩展内容）</li></ul></li></ul><h3 id="call-方法">call 方法</h3><p>在类中可以声明 call 方法（方法名不能变）</p><p>当我们将类的实例，当作函数来调用时，会自动调用 call 方法</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOSPhone</span> </span>&#123;</span><br><span class="line">  call(<span class="built_in">String</span> <span class="built_in">num</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;phone number is <span class="subst">$num</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> phone = IOSPhone();</span><br><span class="line">  <span class="comment">// 将类的实例当作函数一样调用</span></span><br><span class="line">  phone(<span class="string">&#x27;911&#x27;</span>); <span class="comment">// phone number is 911</span></span><br><span class="line">  <span class="comment">// 上面的可以简写为下面这样</span></span><br><span class="line">  IOSPhone()(<span class="string">&#x27;911&#x27;</span>); <span class="comment">// phone number is 911</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="noSuchMethod-方法">noSuchMethod 方法</h3><p>当我们调用了一个类的，未定义的方法时，Dart 会自动调用 noSuchMethod 方法</p><p>使用前提</p><ul><li>类中声明了 noSuchMethod （否则会调用默认的 noSuchMethod）</li><li>实例化对象必须用 dynamic 来修饰<ul><li><code>dynamic p = Person();</code></li></ul></li><li>调用的是未定义的方法（<code>p.undefinedMethod()</code>）</li></ul><p>作用</p><ul><li>防止调用不存在的方法时报错</li></ul><h3 id="hashCode-属性">hashCode 属性</h3><p><strong>同 Java 中的 hashCode 方法</strong></p><p>hashCode 是 Dart 对象的唯一标识</p><p>hashCode 表现为一串数字</p><p>Dart 中每个对象都有 hashCode</p><p>我们可以通过 hashCode 来判断两个对象是否相等</p><h3 id="typedef">typedef</h3><p>typedef 可以用来自定义类型（别名），目的是让程序的可读性更强</p><ul><li>我们可以在声明泛型时，使用自定义的类型</li></ul><p>语法</p><ul><li><code>typedef function_name(parameters);</code></li><li><code>typedef variable_name = List&lt;int&gt;;</code></li></ul><p>版本要求</p><ul><li><p>Dart 版本 2.13 之前，typedef 仅限于函数类型</p></li><li><p>2.13 之后，typedef 可以定义非函数类型</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> MathOperation(<span class="built_in">int</span> a, <span class="built_in">int</span> b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法运算</span></span><br><span class="line">add(<span class="built_in">int</span> a, <span class="built_in">int</span> b) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;加法运算：&#x27;</span> + (a+b).toString());</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法运算</span></span><br><span class="line">sub(<span class="built_in">int</span> a, <span class="built_in">int</span> b) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;减法运算：&#x27;</span> + (a-b).toString());</span><br><span class="line">  <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个数加法</span></span><br><span class="line">add3(<span class="built_in">int</span> a, <span class="built_in">int</span> b, <span class="built_in">int</span> c) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;加法运算：&#x27;</span> + (a+b+c).toString());</span><br><span class="line">  <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(add <span class="keyword">is</span> MathOperation); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">print</span>(sub <span class="keyword">is</span> MathOperation); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">print</span>(add3 <span class="keyword">is</span> MathOperation); <span class="comment">// false</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(add <span class="keyword">is</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">print</span>(sub <span class="keyword">is</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">print</span>(add3 <span class="keyword">is</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line">  </span><br><span class="line">  MathOperation op = add;</span><br><span class="line">  op(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> MathOperation(<span class="built_in">int</span> a, <span class="built_in">int</span> b);</span><br><span class="line"></span><br><span class="line">calculator(<span class="built_in">int</span> a, <span class="built_in">int</span> b, MathOperation op) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;计算器&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> op(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  calculator(<span class="number">8</span>, <span class="number">5</span>, add); <span class="comment">// 13</span></span><br><span class="line">  calculator(<span class="number">9</span> ,<span class="number">6</span>, sub); <span class="comment">// 3</span></span><br><span class="line">  calculator(a, b, (a, b) =&gt; <span class="keyword">null</span>); <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="异步编程">异步编程</h2><h3 id="单线程（EventLoop）">单线程（EventLoop）</h3><p>Dart <strong>单线程的核心</strong>包括</p><ul><li>主线程</li><li>微任务</li><li>宏任务</li></ul><p>Dart 中的<strong>同步操作都在主线程中</strong>完成，遇到异步任务时，会将异步任务放到<strong>两个地方</strong>来完成</p><ul><li>微任务队列<ul><li>微任务队列包含微任务，主要通过 scheduleMicrotask 来调度</li></ul></li><li>事件队列<ul><li>事件队列包含外部事件，例如 I/O、Timer、绘制事件等，对应宏任务</li></ul></li></ul><p>同步与异步</p><ul><li>同步是指任务之间有<strong>强依赖关系</strong>，后一个任务依赖于前一个任务的结果，例子：4x100 米</li><li>异步是同步的反义词，任务之间<strong>没有明确的依赖关系</strong>，例子：100 米中有 8 个跑道</li></ul><p>Dart <strong>单线程执行流程</strong>图示：</p><img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/Dart%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" class=""><p>要点：</p><ol><li>异步任务会在同步任务<strong>全部执行完</strong>（主线程结束）之后再执行</li><li><strong>微任务先于宏任务</strong>（事件任务）执行</li><li>宏任务（事件任务）中可能含有微任务（加入到微任务队列中）</li></ol><p>Dart 中的<strong>事件轮询机制</strong></p><ol><li><p><strong>同步任务全部执行完毕之后</strong>，事件轮询机制开始起作用</p></li><li><p>事件轮询机制每次会<strong>先询问微任务队列</strong>是否有任务，有的话就执行队头的微任务，没有的话就询问事件队列</p></li><li><p>事件队列有任务，则执行队头的事件任务，没有的话表明异步任务全部已经执行完毕，此时程序就结束了</p></li><li><p>可以自己对着下图推导一遍任务的执行顺序：</p><img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6.png" class=""></li></ol><h3 id="Isolate-多线程">Isolate 多线程</h3><h4 id="介绍">介绍</h4><p>Isolate 是 Dart 中的现成</p><ul><li>Dart 中的线程是以**隔离（Isolate）**的方式存在的</li><li>每个 Isolate 都有自己独立的私有内存块（<strong>即多个线程不共享内存</strong>）</li><li>没有共享内存，就<strong>不需要竞争资源，就不需要锁</strong>（不用担心死锁问题）</li></ul><p>所有的 Dart 代码，都运行在 Isolate 中</p><ul><li>Isolate 提供了 Dart | Flutter 的运行环境</li><li>微任务队列、事件队列、事件轮询（EventLoop）都在 Isolate 中进行</li></ul><p>多线程经常用来解决耗时较长的异步任务</p><p>Isolate 相对于整体的位置图示：</p><img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/Isolate%E7%9A%84%E4%BD%8D%E7%BD%AE.png" class=""><p>Isolate 中的内容图示：</p><img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/Isolate%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9.png" class=""><p>内容包括：</p><ol><li>各种对象</li><li>微任务队列</li><li>事件队列</li><li>事件轮询</li></ol><h4 id="创建多线程">创建多线程</h4><p><strong>Isolate 类</strong>用来管理（创建、暂停、杀死）线程，常用函数有：</p><ul><li>Isolate.spawn()</li><li>Isolate.spawnUri()</li><li>Isolate.pause()</li><li>Isolate.kill()</li></ul><p>Isolate.spawn()</p><ul><li><p>函数签名：<code>Future&lt;Isolate&gt; Isolate.spawn(entryPoint, message)</code></p></li><li><p>使用：<code>import 'dart:isolate';</code></p></li><li><p><code>entryPoint</code>：进入点，是一个回调函数，必须是一个顶层方法或静态方法，必须能被访问到</p></li><li><p><code>message</code></p><ol><li>Dart 原始数据类型，如 null、bool、int、double、String 等</li><li>SendPort 实例 - ReceivePort().sendPort</li><li>包含 1 和 2 的 list 和 map，也可以嵌套</li></ol></li><li><p>示例程序：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:isolate&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  MultipleThread();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MultipleThread() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;MultiThread start&quot;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;当前线程名：&quot;</span> + Isolate.current.debugName);</span><br><span class="line">  </span><br><span class="line">  Isolate.spawn(newThread, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;MultiThread end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> newThread(<span class="built_in">String</span> message) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;当前线程名：&quot;</span> + Isolate.current.debugName);</span><br><span class="line">  <span class="built_in">print</span>(massage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">MultiThread start</span></span><br><span class="line"><span class="comment">当前线程名：main</span></span><br><span class="line"><span class="comment">MultiThread end</span></span><br><span class="line"><span class="comment">当前线程名：newThread</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程的创建和执行也是一个异步过程，会在同步任务结束后再执行</span></span><br></pre></td></tr></table></figure></li></ul><p>Isolate.spawnUri()</p><ul><li>参数：<ul><li>uri：创建的新的线程的代码逻辑所在的 uri 路径</li><li>args：创建新的线程时要传递的参数</li><li>msg：创建新的线程时要传递的消息，可以是 SendPort</li></ul></li></ul><p>Isolate.compute()</p><ul><li>是对 Isolate.spawn() 的一个封装</li><li>使用：<code>import 'package:flutter/foundation.dart';</code></li></ul><h4 id="多线程之间的通信机制">多线程之间的通信机制</h4><p>Isolate 多线程之间，通信的唯一方式是 Port，有两个类可以用来实现线程间的通信</p><ul><li><strong>ReceivePort 类</strong><ul><li>初始化接收端口，创建发送端口，接收消息，监听消息，关闭端口</li></ul></li><li><strong>SendPort 类</strong><ul><li>将消息发送给 ReceivePort</li></ul></li></ul><p>线程之间的通信方式</p><ul><li><p>单向通信 （A -&gt; B）</p><img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/%E5%8D%95%E5%90%91%E9%80%9A%E4%BF%A1.png" class=""><ol><li>发送端口是通过接收端口的 sendPort getter 方法创建的</li><li>创建新线程时传递的消息为发送端口实例，这样新线程就可以向根线程发送消息了</li></ol></li><li><p>双向通信（A &lt;-&gt; B）</p><img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1.png" class=""><ol><li>创建新线程时传递的消息为发送端口实例，这样新线程就可以向根线程发送消息了</li><li>新线程可以自己实例化一个接收端口，然后创建这个接收端口的发送端口实例，通过根线程提供的发送端口实例<strong>将自己的发送端口实例发送给根线程</strong>，这样就建立了线程之间的双向通信了</li></ol></li></ul><h3 id="Future">Future</h3><h4 id="什么是-Future">什么是 Future</h4><p>Future 是 Dart 中的类，我们可以通过 Future 实例，封装一些异步任务</p><p>Future 的含义是未来，未来要执行的一些任务，我们可以放到 Future 中</p><p>Future 有三种状态</p><ul><li><p>未完成（Uncompleted）</p></li><li><p>已完成，并返回数据（Completed with data）</p></li><li><p>已完成，但返回报错（Completed with error）</p></li><li><p>图示：</p><img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/Future%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81%E5%9B%BE%E7%A4%BA.png" class=""><p><strong>Future 相当于是一个黑盒，打开前状态不确定，打开后才确定</strong></p></li></ul><h4 id="获取-Future-实例">获取 Future 实例</h4><p>自动返回，一些 API 会返回 Future 实例</p><ul><li><code>final myFuture = http.get('https://my.image.url');</code></li><li><code>final myFuture = SharedPreferences.getInstance;</code></li></ul><p>手动创建，调用 Future 的 API</p><ul><li><code>final myFuture = Future( () &#123; return 123; &#125;);</code></li><li><code>final myFuture = Future.error(Exception());</code></li><li><code>final myFuture = Future.delayed(Duration(seconds: 5), () =&gt; 123);</code> 延迟一段时间后才开始执行该异步任务</li></ul><p>与 Future 的方法相关的状态</p><ul><li><p>创建：Uncompleted</p></li><li><p>then()：Completed with data，该方法拿返回数据</p></li><li><p>catchError()：Completed with error，该方法捕获错误</p></li><li><p>whenCompleted()：Completed with data + Completed with error，该方法用于做一些收尾工作</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 创建 Future 实例</span></span><br><span class="line">  <span class="keyword">final</span> f = Future( () &#123;</span><br><span class="line">    <span class="comment">// 创建该异步任务时会执行这个函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Create the future&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(f); <span class="comment">// instance of &#x27;Future&lt;int&gt;&#x27;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 接收异步任务返回的数据</span></span><br><span class="line">  f.then( (value) =&gt; <span class="built_in">print</span>(value)); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Future-执行顺序">Future 执行顺序</h4><p>Future 默认是异步任务，会被丢到事件队列（Event queue）中</p><p>Future.sync()</p><ul><li>同步任务，同步执行（不会被丢到异步队列中）</li></ul><p>Future.microtask()</p><ul><li>异步任务中的微任务，会被丢到微任务队列中，优先级比事件任务高</li></ul><p>Future.value(val)</p><ul><li>适用于可以直接拿到结果的异步操作</li><li>val 是常量，则创建微任务</li><li>val 是异步任务（如一个 Future），如果异步任务是微任务，则丢到微任务队列，如果异步任务是宏任务，则丢到事件队列</li></ul><h4 id="Future-多任务">Future 多任务</h4><p><code>Future.any(futures)</code></p><ul><li>返回最先完成的 Future 结果，futures 是一组 Future 任务</li></ul><p><code>Future.wait(futures)</code></p><ul><li>等待所有 Future 任务执行完成，并收集所有 Future 任务的返回结果</li></ul><p><code>Future.doWhile(action)</code></p><ul><li>按照条件遍历执行多个 Future 任务</li></ul><p><code>Future.forEach(elements, action)</code></p><ul><li><p>遍历一个给定的集合，根据集合元素执行多个 Future</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// doWhile方法将根据传入回调函数的返回值是ture还是false来决定是否要继续下一次循环</span></span><br><span class="line">  Future.doWhile( () &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">return</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>), () &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Future.doWhile() <span class="subst">$i</span>&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> i &lt; <span class="number">6</span>;</span><br><span class="line">    &#125;).then( (value) &#123;</span><br><span class="line">      <span class="comment">// 返回延时Future任务的布尔值，这样doWhile才可以拿到这个值判断是否还要继续</span></span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  Future.forEach([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (element) &#123;</span><br><span class="line">    <span class="keyword">return</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>), () &#123;</span><br><span class="line">      <span class="built_in">print</span>(element);</span><br><span class="line">      <span class="keyword">return</span> element;</span><br><span class="line">    &#125;).then( (value) =&gt; <span class="built_in">print</span>(element));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="FutureBuilder">FutureBuilder</h4><p><code>FutureBuilder</code> 是 Flutter SDK 中提供的异步组件</p><ul><li><code>FutureBuilder</code> 是一个类，可以接收 Future 任务的数据，并将数据渲染成界面</li><li>使用：<code>import 'package:flutter/material.dart';</code></li></ul><p><code>FutureBuilder</code> 中，有三个属性</p><ul><li>future：要完成的任务</li><li>initialData：初始数据</li><li>builder(context, <strong>snapshot</strong>)：构造器<ul><li>snapshot 三种状态：<ul><li><code>snapshot.connectionState</code><ul><li>ConnectionState.none（未连接异步任务）</li><li>ConnectionState.waiting（连接异步任务，等待交互）</li><li>ConnectionState.active（正在交互）</li><li>ConnectionState.done（异步任务完成）</li></ul></li><li><code>snapshot.hasData</code> (Completed with data)<ul><li>snapshot.data 获取数据</li></ul></li><li><code>snapshot.hasError</code> (Completed with error)</li></ul></li></ul></li></ul><h3 id="Stream">Stream</h3><h4 id="什么是-Stream">什么是 Stream</h4><p>Stream 是 Dart 中的异步数据流，可以连续不断地返回多个数据</p><ul><li>Future 是异步，但只能返回一个值</li><li>Stream 也是异步，但可以返回多个值（数据流）</li></ul><p>Stream 相关的 API</p><ul><li>通过 listen 进行数据监听（最常用）</li><li>通过 error 接收失败状态</li><li>通过 done 接收结束状态</li></ul><p>Stream 类型</p><ul><li><p>Single-Subscription（单一订阅）</p><ul><li>数据流只能被 listen 一次（listen 多次会报错）</li><li>StreamController().stream</li><li>Stream stream = Stream.fromIterable(data)</li></ul></li><li><p>Broadcast（广播）</p><ul><li>数据流可以被 listen 多次</li><li>StreamController&lt;int&gt;.broadcast()</li><li>stream.asBroadcastStream()</li></ul><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 单一订阅数据流</span></span><br><span class="line">  <span class="keyword">final</span> StreamController controller = StreamController();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第一次监听</span></span><br><span class="line">  controller.stream.listen( (event) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Data is <span class="subst">$event</span>&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  // 第二次监听 —— 会报错</span></span><br><span class="line"><span class="comment">  controller.stream.listen( (event) &#123;</span></span><br><span class="line"><span class="comment">    print(&quot;Data is $event&quot;);</span></span><br><span class="line"><span class="comment">  &#125;);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送数据</span></span><br><span class="line">  controller.sink.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">  controller.sink.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">Data is 123</span></span><br><span class="line"><span class="comment">Data is abc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 广播数据流</span></span><br><span class="line">  <span class="keyword">final</span> StreamController controller = StreamController.broadcast();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第一次监听</span></span><br><span class="line">  controller.stream.listen( (event) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Data1 is <span class="subst">$event</span>&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送数据</span></span><br><span class="line">  controller.sink.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第二次监听 —— 不会报错</span></span><br><span class="line">  controller.stream.listen( (event) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Data2 is <span class="subst">$event</span>&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送数据</span></span><br><span class="line">  controller.sink.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">Data1 is 123</span></span><br><span class="line"><span class="comment">Data2 is abc</span></span><br><span class="line"><span class="comment">Data1 is abc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="创建-Stream">创建 Stream</h4><p>StreamController 类</p><ul><li>sink：槽，用于添加数据</li><li>stream：流，用于取出数据</li><li><img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/StreamController.png" class=""></li></ul><p>Stream 类</p><ul><li>Stream.fromFuture()，从单个 Future 任务中获取数据并可以读取</li><li>Stream.fromFutures()，从多个 Future 任务中获取数据并可以读取</li><li>Stream.fromIterable()，从一个可迭代的对象中获取数据并可以读取</li><li>Stream.periodic(Duration, computation)，周期性地获取数据并可以读取</li></ul><h4 id="操作-Stream">操作 Stream</h4><p>take() | takeWhile()</p><ul><li>限制获取的数据的数量，或当满足条件时才获取数据</li></ul><p>where()</p><ul><li>只获取满足条件的数据</li></ul><p>distinct()</p><ul><li>去掉数据流中<strong>连续重复</strong>的值</li></ul><p>skip() | skipWhile()</p><ul><li>跳过数据中的前几个数据，或跳过满足条件的数据</li></ul><p>map()</p><ul><li>对数据流中的每一个数据加工</li></ul><p>expand()</p><ul><li>对数据流中的每一个数据扩展为自定义的数组</li></ul><p>toSet() | toList() | toString()</p><p>length | first | last | isEmpty</p><p>firstWhere() | lastWhere()</p><h4 id="StreamBuilder">StreamBuilder</h4><p><code>StreamBuilder</code> 是 Flutter SDK 中提供的异步组件</p><ul><li><code>StreamBuilder</code> 是一个类，接收 Stream 数据，并将数据渲染成界面</li><li>引入：<code>import 'package:flutter/material.dart';</code></li></ul><p><code>StreamBuilder</code> 中，有三个属性，类似于 <code>FutureBuilder</code></p><ul><li>stream</li><li>initialData</li><li>builder(context, <code>snapshot</code>)</li></ul><p>作用图示：</p><img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/StreamBuilder%E4%BD%9C%E7%94%A8.png" class=""><h3 id="总结">总结</h3><img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/Future%E4%B8%8EIsolate%E9%80%89%E6%8B%A9.png" class=""><img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/%E5%BC%82%E6%AD%A5%E4%B8%89%E8%80%85%E6%AF%94%E8%BE%83.png" class=""><h3 id="Async-Await">Async / Await</h3><p>async：标记函数是一个异步函数，其返回值类型是 Future</p><p>await：等待某个异步方法执行完毕</p><ul><li>用来等待耗时操作的返回结果，这个操作会<strong>阻塞到后面的代码</strong></li></ul><p>作用</p><ul><li>await 会等待异步任务执行（相当于<strong>将异步转成同步</strong>）</li><li>async-await 简化代码，防止回调地狱的产生</li></ul><h3 id="Generator（生成器）">Generator（生成器）</h3><p>什么是生成器</p><ul><li>生成器是是一种<strong>特殊的函数</strong>，返回值通过 <code>yield</code> 关键字来指定</li></ul><p>生成器的分类</p><ul><li><p>同步生成器（sync + yield）</p><ul><li><p>使用 sync*，返回的是 Iterable 对象</p></li><li><p>yield 会返回 moveNext 为 true，并等待 moveNext 指令</p></li><li><img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/image-20240407225432130.png" class=""><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> res = getNumber(<span class="number">5</span>).iterator;</span><br><span class="line">  <span class="comment">// 最终moveNext的指针指向-1位置</span></span><br><span class="line">  <span class="keyword">while</span> (res.moveNext()) &#123;</span><br><span class="line">    <span class="built_in">print</span>(res.current);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同步生成器</span></span><br><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; getNumber(<span class="built_in">int</span> n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">start</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>异步生成器（async + yield）</p><ul><li><p>使用 async*，返回的是 Stream 对象</p></li><li><p>yield 不用暂停，数据以流的方式一次性推送</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> Stream&lt;<span class="built_in">int</span>&gt; s = asyncCountDown(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">  s.listen( (event) =&gt; <span class="built_in">print</span>(event))</span><br><span class="line">    .onDone( () =&gt; <span class="built_in">print</span>(<span class="string">&quot;Done&quot;</span>));</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步生成器</span></span><br><span class="line">Stream&lt;<span class="built_in">int</span>&gt; asyncCountDown(<span class="built_in">int</span> n) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> n--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">start</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">Done</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>递归生成器（yield*）</p><ul><li><p>yield* 是指针，指向递归函数</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; s = getRange(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">  s.forEach( (element) =&gt; <span class="built_in">print</span>(element));</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步递归生成器</span></span><br><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; getRange(<span class="built_in">int</span> start, <span class="built_in">int</span> end) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">if</span> (start &lt;= end) &#123;</span><br><span class="line">    <span class="keyword">yield</span> start;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 递归调用</span></span><br><span class="line"><span class="comment">    for (final val in getRange(start + 1, end)) &#123;</span></span><br><span class="line"><span class="comment">      yield val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面的递归调用可以简写为以下形式 </span></span><br><span class="line">    <span class="keyword">yield</span>* getRange(start + <span class="number">1</span>, end);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">start</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="库与生态">库与生态</h2><h3 id="简介-6">简介</h3><p>Dart 中的库就是具有特定功能的模块</p><ul><li>可能包含单个文件，也可能包含多个文件</li></ul><p>按照库的作者进行划分，库可以分成三类</p><ul><li>自定义库（工程师自己写的）</li><li>系统库（Dart 中自带的）</li><li>第三方库（Dart 生态中的）</li></ul><p>Dart 生态</p><ul><li>生态仓库：<a href="https://pub.dev/">https://pub.dev/</a></li><li>使用 pub 命令从仓库中下载包</li></ul><h3 id="自定义库">自定义库</h3><h4 id="通过-library-来声明库">通过 library 来声明库</h4><p>每个 Dart 文件默认都是一个库，只是没有使用 library 来显式声明</p><p>Dart 使用 <code>_</code> 开头的标识符来表示库内访问可见（私有）</p><p>library 关键字声明的库名建议使用：小写字母 + 下划线</p><h4 id="通过-import-来引入库">通过 import 来引入库</h4><p>不同类型的库，引入方式不同</p><ul><li>自定义库：<code>import '库所处目录/库名称.dart'</code></li><li>系统库：<code>import 'dart:库名称'</code></li><li>第三方库：之后单独阐述</li></ul><p>引入部分库（仅引入需要的内容）</p><ul><li>包含引入（show）：跟在 show 后面的是仅引入的内容</li><li>排除引入（hide）：跟在 hide 后面的是不引入的内容</li></ul><p>通过指定库的前缀来避免命名冲突</p><ul><li>当库内的属性、函数名等冲突时，可以通过 <code>as</code> 关键字，给库声明一个前缀</li></ul><p>延迟引入（懒加载）</p><ul><li><p>使用 <code>deferred as</code> 关键字来标识需要延时加载的库</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lib/function.dart&#x27;</span> <span class="keyword">deferred</span> <span class="keyword">as</span> func;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>);</span><br><span class="line">  greet();</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future greet() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> func.loadLibrary()</span><br><span class="line">  func.hello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">hello world</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="通过-part-和-part-of-来组装库">通过 part 和 part of 来组装库</h4><p>图示：</p><img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/part%E5%92%8Cpart%20of.png" class=""><h3 id="系统库">系统库</h3><h4 id="介绍-2">介绍</h4><p>系统库（也叫核心库）是 Dart 提供的常用内置库</p><ul><li>不需要单独下载，就可以直接使用</li></ul><p>引入</p><ul><li><code>import 'dart:库名'</code></li><li><code>dart:core</code> 会自动引入，无需手动引入</li></ul><p>系统库列表</p><ul><li>async</li><li>collection</li><li>convert</li><li>core</li><li>developer</li><li>math</li><li>…</li></ul><h3 id="第三方库">第三方库</h3><p>来源</p><ul><li><a href="https://pub.dev">https://pub.dev</a></li><li><a href="https://pub.flutter-io.cn/packages">https://pub.flutter-io.cn/packages</a></li><li><a href="https://pub.dartlang.org/flutter">https://pub.dartlang.org/flutter</a></li></ul><p>使用</p><ul><li>在项目目录下创建 <code>pubspec.yaml</code></li><li>在 <code>pubspec.yaml</code> 中声明第三方库（依赖）</li><li>在命令行中进入 <code>pubspec.yaml</code> 所在目录，执行 <code>pub get</code> 进行安装</li><li>在项目中引入第三方库 <code>import 'package:xxx/xxx.dart'</code></li></ul><p>第三方库的结构</p><ul><li><p>一个第三方库，必须包含一个 <code>pubspec.yaml</code></p><img src="/2025/03/02/Dart-Programming-Language-Basic-Syntax/dart%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" class=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming Language </category>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> Basic Syntax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSR 380 Java Bean Validation</title>
      <link href="/2025/03/02/JSR-380-Java-Bean-Validation/"/>
      <url>/2025/03/02/JSR-380-Java-Bean-Validation/</url>
      
        <content type="html"><![CDATA[<h1>JSR 380 Java Bean Validation</h1><ul><li><p>该技术规范规定了用于对 Java Bean 中的属性进行验证的 API，从而避免了传参时的大量 if-else 校验。</p></li><li><p>SpringBoot 中提供了相应的 API，可以通过注解的方式来对属性进行约束，在传参时自动校验，并能在参数校验不通过时返回错误信息</p></li></ul><h2 id="引入依赖">引入依赖</h2><p>要在 SpringBoot 中引入该 API 包，添加如下 Maven 依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该依赖中提供了 <code>Hibernate-Validator</code> 的传递依赖，因此不用再引入 <code>Hibernate-Validator</code>。</p><h2 id="常用注解">常用注解</h2><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td><code>@NotNull</code></td><td>该属性不能为空</td></tr><tr><td><code>@AssertTrue</code></td><td>该属性需要为 <code>true</code></td></tr><tr><td><code>@Size</code></td><td>用于字符串、集合或数组，限定该属性的大小（字符串长度、集合数组的元素个数），通过 <code>min</code> 和 <code>max</code> 两个属性来指定区间</td></tr><tr><td><code>@Min</code></td><td>该属性值不能小于该注解的 value 属性的值</td></tr><tr><td><code>@Max</code></td><td>该属性值不能大于该注解的 value 属性的值</td></tr><tr><td><code>@Email</code></td><td>该属性值需要为合法的邮箱地址</td></tr><tr><td><code>@NotEmpty</code></td><td>用于字符串、集合和数组，限定该属性不能为 <code>null</code> 或空</td></tr><tr><td><code>@NotBlank</code></td><td>用于字符串，限定该字符串不能为 <code>null</code>，空或全是空格</td></tr><tr><td><code>@Positive</code></td><td>用于数字量，限定该属性严格大于 0</td></tr><tr><td><code>@PositiveOrZero</code></td><td>用于数字量，限定该属性严格大于等于 0</td></tr><tr><td><code>@Negative</code></td><td>用于数字量，限定该属性严格小于 0</td></tr><tr><td><code>@NegativeOrZero</code></td><td>用于数字量，限定该属性严格小于等于 0</td></tr><tr><td><code>@Past</code></td><td>用于日期类型的属性，限定该属性必须为过去时间</td></tr><tr><td><code>@PastOrPresent</code></td><td>用于日期类型的属性，限定该属性必须为过去或当前时间</td></tr><tr><td><code>@Future</code></td><td>用于日期类型的属性，限定该属性必须为将来时间</td></tr><tr><td><code>@FutureOrPresent</code></td><td>用于日期类型的属性，限定该属性必须为将来或当前时间</td></tr></tbody></table><blockquote><p>这些注解还可以用于集合的元素，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="meta">@NotBlank</span> String&gt; preferences;</span><br></pre></td></tr></table></figure></blockquote><h2 id="在传递参数时进行参数校验">在传递参数时进行参数校验</h2><p>给需要校验的属性设置好约束后，我们就可以在 Controller 层的方法参数列表中校验前端的传参，具体做法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line">    ResponseEntity&lt;String&gt; <span class="title function_">addUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// persisting the user</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;User is valid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// standard constructors / other methods</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 SpringBoot 的 RestController 中，设定哪些参数校验十分简单，只需要在要校验的参数前加上 <code>@Valid</code> 注解即可，此注解会自动启动引导 JSR 380 的实现类—— Hibernate Validator，并验证该参数。</p><p>如果参数未通过校验，SpringBoot 会抛出 <code>MethodArgumentNotValidException</code> 异常</p><h2 id="异常处理">异常处理</h2><p>在验证到参数非法后，SpringBoot 会抛出 <code>MethodArgumentNotValidException</code> 异常，我们需要捕获这个异常并返回错误信息，此时，我们可以新建一个方法专门用于处理参数非法异常，并为这个方法加上 <code>@ExceptionHandler</code> 注解，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line"><span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">handleValidationExceptions</span><span class="params">(</span></span><br><span class="line"><span class="params">  MethodArgumentNotValidException ex)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; errors = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    ex.getBindingResult().getAllErrors().forEach((error) -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> ((FieldError) error).getField();</span><br><span class="line">        <span class="type">String</span> <span class="variable">errorMessage</span> <span class="operator">=</span> error.getDefaultMessage();</span><br><span class="line">        errors.put(fieldName, errorMessage);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> errors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在程序抛出 <code>MethodArgumentNotValidException</code> 异常时，被 <code>@ExceptionHandler(MethodArgumentNotValidException.class)</code> 标注的方法就会自动捕获该异常，并执行方法体中的语句，并将该方法的返回值返回给前端。</p><h2 id="参数交叉验证">参数交叉验证</h2><p>所谓参数交叉验证，就是指传递的多个参数之间有约束联系，而我们需要验证这些约束联系是否被满足，例如：</p><ul><li>传递两个数值参数 <code>a</code> 和 <code>b</code>，其中 <code>a</code> 必须比 <code>b</code> 大</li><li>传递两个日期参数 <code>begin</code> 和 <code>end</code>，其中 <code>begin</code> 的时间必须比 <code>end</code> 的要早</li></ul><p>之前介绍的注解，都只适用于单个参数的值的校验，无法完成参数之间交叉验证的需求，于是，我们引入了自定义注解，来实现这一需求。</p><p>假如我们需要验证传递来的两个日期参数，一个比另一个早，且两个都晚于当前时间，则我们按如下步骤来实现：</p><ol><li><p>在需要交叉验证参数的方法上加上我们的自定义注解，这里为 <code>@ConsistentDateParameters</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConsistentDateParameters</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createReservation</span><span class="params">(LocalDate begin, </span></span><br><span class="line"><span class="params">  LocalDate end, Customer customer)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义我们定义的自定义注解，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Constraint(validatedBy = ConsistentDateParameterValidator.class)</span></span><br><span class="line"><span class="meta">@Target(&#123; METHOD, CONSTRUCTOR &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConsistentDateParameters &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span></span><br><span class="line">      <span class="string">&quot;End date must be after begin date and both must be in the future&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此注解中，有三个必填属性：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>message</code></td><td>返回的错误信息</td></tr><tr><td><code>groups</code></td><td>允许指定约束的分组</td></tr><tr><td><code>payload</code></td><td>Bean Validation API 的客户端可以使用它来将自定义有效负载对象分配给约束</td></tr></tbody></table></li><li><p>定义自定义注解参数验证类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SupportedValidationTarget(ValidationTarget.PARAMETERS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistentDateParameterValidator</span> </span><br><span class="line">  <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;ConsistentDateParameters, Object[]&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(</span></span><br><span class="line"><span class="params">      Object[] value,</span></span><br><span class="line"><span class="params">      ConstraintValidatorContext context)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (value[<span class="number">0</span>] == <span class="literal">null</span> || value[<span class="number">1</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(value[<span class="number">0</span>] <span class="keyword">instanceof</span> LocalDate) </span><br><span class="line">          || !(value[<span class="number">1</span>] <span class="keyword">instanceof</span> LocalDate)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">              <span class="string">&quot;Illegal method signature, expected two parameters of type LocalDate.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ((LocalDate) value[<span class="number">0</span>]).isAfter(LocalDate.now()) </span><br><span class="line">          &amp;&amp; ((LocalDate) value[<span class="number">0</span>]).isBefore((LocalDate) value[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li><p>类名需要与自定义注解元注解 <code>@Constraint</code> 的 <code>validatedBy</code> 的属性值一致</p></li><li><p><code>ConstraintValidator</code> 接口有两个泛型需要指定：</p><ol><li><p>自定义的注解</p></li><li><p>指定该验证类可以验证的数据类型（不确定可以设为 Object[]）</p></li></ol></li><li><p>方法 <code>isvalid</code> 有两个参数：</p><ol><li>传递的需要验证的参数</li><li>默认参数 <code>ConstraintValidatorContext context</code></li></ol></li></ol></blockquote><p><code>isValid</code> 方法中就包含了实际的验证逻辑，返回值为 <code>ture</code> 表示验证通过，返回值为 <code>false</code> 表示验证未通过。</p><p>注意！<code>@SupportedValidationTarget(ValidationTarget.PARAMETERS)</code> 对 <code>ConsistentDateParameterValidator</code> 类的批注是必需的。这样做的原因是 <code>@ConsistentDateParameter</code> 是在方法级别设置的，但约束应应用于方法参数（而不是方法的返回值）</p><blockquote><p>提示：Bean 验证规范建议将 <em>null</em> 值视为有效值。如果 <em>null</em> 不是有效值，则应添加 <em>@NotNull</em> 注释。</p></blockquote></li></ol><h2 id="方法返回值校验">方法返回值校验</h2><p>有时我们需要检验方法的返回值是否合乎要求，这时我们需要进行方法返回值的校验，方法返回值校验有两种途径：</p><ol><li>使用自带注解进行校验</li><li>使用自定义注解进行校验</li></ol><h3 id="使用自带注解进行校验">使用自带注解进行校验</h3><p>这种方式很简单，只需要在方法之上加上对返回值的约束注解即可，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReservationManagement</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(min = 1)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="meta">@NotNull</span> Customer&gt; getAllCustomers() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上注解后，该方法的返回值会：</p><ul><li>返回的列表不能为 <em>null</em>，且列表中至少包含一个元素</li><li>返回的列表中的元素不能为 <em>null</em></li></ul><h3 id="使用自定义注解进行校验">使用自定义注解进行校验</h3><p>与参数交叉验证相似，我们可以按如下步骤来完成对方法返回值的校验：</p><ol><li><p>在需要校验返回值的方法上加上我们的自定义注解，如 <code>@ValidReservation</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReservationManagement</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ValidReservation</span></span><br><span class="line">    <span class="keyword">public</span> Reservation <span class="title function_">getReservationsById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义自定义注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Constraint(validatedBy = ValidReservationValidator.class)</span></span><br><span class="line"><span class="meta">@Target(&#123; METHOD, CONSTRUCTOR &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ValidReservation &#123;</span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;End date must be after begin date &quot;</span></span><br><span class="line">      + <span class="string">&quot;and both must be in the future, room number must be bigger than 0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义验证类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidReservationValidator</span></span><br><span class="line">  <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;ValidReservation, Reservation&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(</span></span><br><span class="line"><span class="params">      Reservation reservation, ConstraintValidatorContext context)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reservation == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(reservation <span class="keyword">instanceof</span> Reservation)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal method signature, &quot;</span></span><br><span class="line">            + <span class="string">&quot;expected parameter of type Reservation.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reservation.getBegin() == <span class="literal">null</span></span><br><span class="line">          || reservation.getEnd() == <span class="literal">null</span></span><br><span class="line">          || reservation.getCustomer() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (reservation.getBegin().isAfter(LocalDate.now())</span><br><span class="line">          &amp;&amp; reservation.getBegin().isBefore(reservation.getEnd())</span><br><span class="line">          &amp;&amp; reservation.getRoom() &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>此注解还可以应用到类的构造器上，来校验实例化的对象是否合乎要求</p></blockquote><h2 id="级联验证">级联验证</h2><p>前面我们介绍的验证，都是验证一个简单对象的属性，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Size(min = 5, max = 200)</span></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Size(min = 5, max = 200)</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor, getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们有一个复杂对象，这个复杂对象的某些属性是其他的自定义对象，当我们要需要验证它时，就需要用到级联验证，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reservation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Positive</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> room;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// further properties, constructor, getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在需要级联验证的属性对象上也加上了 <code>@Valid</code> 注解，这样在验证 <code>Reservation</code> 对象属性时，不仅会验证 <code>room</code> 属性，还会验证该对象的属性 <code>customer</code> 对象下的全部属性是否合法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createNewCustomer</span><span class="params">(<span class="meta">@Valid</span> Reservation reservation)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法同样适合验证方法的返回值是复杂对象时，返回的值是否合法</p><h2 id="使用-Spring-进行自动验证">使用 Spring 进行自动验证</h2><p>前面我们已经自定义了注解并实现了自定义的校验类，现在，我们可以进行校验了，其中一条实现校验的途径就是使用 Spring 进行自动验证</p><blockquote><p><strong>Spring Validation 提供了与 Hibernate Validator 的集成。</strong></p><p>注意：Spring Validation 基于 AOP，并使用 Spring AOP 作为默认实现。因此，<strong>验证仅适用于方法，而不适用于构造函数</strong>。</p></blockquote><p>如果我们想要使用 Spring 进行自动验证，我们需要完成以下两步：</p><ol><li><p>在需要进行参数验证的方法所属的类上加上 <code>@Validated</code> 注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReservationManagement</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createReservation</span><span class="params">(<span class="meta">@NotNull</span> <span class="meta">@Future</span> LocalDate begin, </span></span><br><span class="line"><span class="params">      <span class="meta">@Min(1)</span> <span class="type">int</span> duration, <span class="meta">@NotNull</span> Customer customer)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(min = 1)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="meta">@NotNull</span> Customer&gt; getAllCustomers()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置提供一个 <code>MethodValidationPostProcessor</code> bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123; &quot;org.baeldung.javaxval.methodvalidation.model&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodValidationConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MethodValidationPostProcessor <span class="title function_">methodValidationPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MethodValidationPostProcessor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SpringBoot 应用不需要这一步，IOC 容器会自动为我们注册一个 <code>MethodValidationPostProcessor</code> bean.</p></blockquote></li></ol><p>帮助文档：<a href="https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-defining-group-sequences">Hibernate Validator 8.0.1.Final - Jakarta Bean 验证参考实现：参考指南 (jboss.org)</a></p>]]></content>
      
      
      <categories>
          
          <category> Web Server Framework </category>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Java </tag>
            
            <tag> Bean Validation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Crash Course Computer Science</title>
      <link href="/2025/03/02/Crash-Course-Computer-Science/"/>
      <url>/2025/03/02/Crash-Course-Computer-Science/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="Crash Course Computer Science_compressed.pdf" width="100%" height="550" type="application/pdf"></div><blockquote><p>Tips: 由于 Xmind 的 markdown 导出无法导出相应图片，请以思维导图内容为主，以下文字内容（不含图片）为辅。</p></blockquote><h1>Crash Course Computer Science</h1><h2 id="1、计算机早期历史">1、计算机早期历史</h2><h3 id="发展">发展</h3><ul><li><p>算盘</p></li><li><p>步进计算器</p></li><li><p>差分机</p></li><li><p>分析机</p></li><li><p>打孔卡片制表机</p></li></ul><h2 id="2、电子计算机">2、电子计算机</h2><h3 id="早期：机电计算机">早期：机电计算机</h3><ul><li><p>哈佛马克一号</p><ul><li><p>关键部件：机械继电器</p><ul><li>图示</li></ul></li><li><p>通过电流控制继电器的开关来进行运算，类似于当代的二极管。</p></li><li><p>用齿轮的齿来计数，采用十进制，各个齿轮有十个齿来表示数字。</p></li></ul></li></ul><h3 id="真正的第一台可编程电子计算机">真正的第一台可编程电子计算机</h3><ul><li><p>巨人一号</p><ul><li><p>关键部件：真空管<br>（三级真空管）</p><ul><li><p>图示</p></li><li><p>在热电子管（二级真空管）的基础上加入了控制电极，控制电极加正电允许电子流动，加负电阻止电子流动。</p></li></ul></li></ul></li></ul><h3 id="世界上第一台通用，可编程的电子计算机">世界上第一台通用，可编程的电子计算机</h3><ul><li><p>ENIAC</p></li><li><p>使用电子管</p></li></ul><h3 id="半导体晶体管">半导体晶体管</h3><ul><li><p>原理图示</p><ul><li>中间材料是半导体，由左边的input电流控制，如果左边input on，则半导体导通电流，右边上方电流可以流向下方；如果左边input off，则半导体拦截电流，右边上方电流不能流向下方。因此达到开关的作用。</li></ul></li><li><p>比电子管更小，可靠性更高，速度更快</p></li></ul><h2 id="3、布尔逻辑和逻辑门">3、布尔逻辑和逻辑门</h2><h3 id="布尔代数">布尔代数</h3><h3 id="逻辑门">逻辑门</h3><ul><li><p>非门</p><ul><li></li><li><p>input on时，半导体导通电流，上方电流被下面的接地导线导走，output没有电流；input off时，半导体拦截电流，上方电流不被接地导线导走，output有电流。因此构建出了非门电路。</p></li></ul></li><li><p>与门</p><ul><li></li><li><p>两个晶体管控制，只有当两个晶体管（input）为on时，output才会有电流。</p></li></ul></li><li><p>或门</p><ul><li></li><li><p>两个晶体管控制，当一个晶体管（input）为on时，output就有电流。</p></li></ul></li><li><p>异或门</p><ul><li></li></ul></li></ul><h2 id="4、二进制">4、二进制</h2><h3 id="用二进制表示数字（整数浮点数，有符号数无符号数），加减数字">用二进制表示数字（整数浮点数，有符号数无符号数），加减数字</h3><ul><li><p>整数</p><ul><li>第 1 位：表示正负 1 是负，0 是正（补码）<br>其余 31 位/63 位： 表示实数</li></ul></li><li><p>浮点数</p><ul><li>浮点数=有效位数*指数<br>32 位数字中：第 1 位表示正负，第 2-9 位存指数。剩下 23 位存有效位数</li></ul></li></ul><h3 id="用二进制表示字母符号文字">用二进制表示字母符号文字</h3><ul><li><p>编码</p><ul><li><p>ASCII</p></li><li><p>Unicode</p></li></ul></li></ul><h3 id="用二进制来表示图像、音乐、视频">用二进制来表示图像、音乐、视频</h3><ul><li><p>编码</p><ul><li><p>GIF</p></li><li><p>PNG</p></li><li><p>MP3</p></li><li><p>MP4</p></li></ul></li></ul><h2 id="5、算数逻辑单元">5、算数逻辑单元</h2><h3 id="算数单元">算数单元</h3><ul><li><p>将两个数字相加</p><ul><li><p>两个单独位相加</p><p>结果可能为：<br>0+1=1<br>1+0=1<br>0+0=0<br>1+1=10</p><ul><li><p>采用异或、和运算</p></li><li><p>半加器</p><ul><li></li><li><p>sum是相加后的数，由异或运算得到；carry用于储存进位的数，由与运算得到。</p></li></ul></li></ul></li><li><p>三个单独位相加</p><p>用于处理两个单独位相加时产生的进位与之后两个单独位一起相加的情况。</p><ul><li><p>采用半加器构造</p></li><li><p>全加器</p><ul><li></li></ul></li></ul></li><li><p>综合以上两种加法器</p><ul><li><p>8位行波进位加法器</p><ul><li></li></ul></li></ul></li><li><p>算数单元支持的其他运算</p><ul><li></li></ul></li></ul></li></ul><h3 id="逻辑单元">逻辑单元</h3><ul><li>执行逻辑操作，例如与或非，以及一些简单的数值测试，比如是否为0、是否为负数。</li></ul><h2 id="6、寄存器与内存">6、寄存器与内存</h2><h3 id="记录位1的电路">记录位1的电路</h3><ul><li></li><li><p>一旦A或B中任何一个输入为1，输出将永远为1，既存储了1。</p></li></ul><h3 id="记录位0的电路">记录位0的电路</h3><ul><li></li><li><p>A、B均为1，电路输出为1，一旦A和B中任何一个输入为0，输出将永远为0，既存储了0。</p></li></ul><h3 id="8位寄存器">8位寄存器</h3><ul><li><p>将八个门锁并列放置，就得到可以存储八位的存储</p><ul><li></li><li><p>缺点：当存储位数变多时，需要太多的连接线。</p></li></ul></li></ul><h3 id="16X16门锁矩阵">16X16门锁矩阵</h3><ul><li><p>将256个门锁排列成16x16的矩阵，以节约连接线</p><ul><li></li><li><p>如何启用单个门锁？</p><ul><li></li><li><p>打开相应的行线和列线，用与门来表示只操作这一个门锁，所有门锁共用一条允许写入线和一条数据输入线，允许写入线与行列线共同决定是否能写入这个门锁，要写入数据通过数据输入线写入你选择的门锁，其他门锁因行列线和允许写入线与运算为0而无法写入。</p></li><li><p>多路复用器</p><ul><li></li><li><p>用于通过地址选定特定的列与行来指示要操作的门锁的位置。</p></li></ul></li></ul></li></ul></li></ul><h3 id="256B存储器">256B存储器</h3><ul><li></li><li><p>由八个256位门锁矩阵并排而成，八位的地址对应八块门锁上的同一个地方，实现用八位地址控制八个门锁。一个八位的数将被一位一位地分别存储在八个门锁地同一位置中，最终可存储256字节的数据。</p></li></ul><h3 id="真实例子：1980年代的1MB内存">真实例子：1980年代的1MB内存</h3><ul><li></li></ul><h3 id="其他类型内存">其他类型内存</h3><ul><li><p>SRAM（本节课介绍的）</p><ul><li>使用门锁构建</li></ul></li><li><p>DRAM</p></li><li><p>Flash Memory</p></li><li><p>NVRAM</p></li></ul><h2 id="7、中央处理器CPU">7、中央处理器CPU</h2><h3 id="三个工作阶段">三个工作阶段</h3><ul><li><p>取指令阶段</p><ul><li></li></ul></li><li><p>解码阶段</p><ul><li></li></ul></li><li><p>执行阶段</p><ul><li></li><li><p>最终Instruction address register递增1</p></li></ul></li></ul><h3 id="指令表">指令表</h3><ul><li></li></ul><h3 id="抽象表示">抽象表示</h3><ul><li></li></ul><h3 id="时钟">时钟</h3><ul><li>CPU取指令、解码、执行的指挥</li></ul><h3 id="时钟速度">时钟速度</h3><ul><li>CPU“取指令、接码、执行”的速度</li></ul><h2 id="8、指令和程序">8、指令和程序</h2><h3 id="概念">概念</h3><ul><li><p>指令</p><ul><li><p>指示计算机要做什么的代码（机器码），多条指令共同组成程序。如数学指令，内存指令。</p></li><li><p>注：指令和数据都是存在同一个内存里的。</p></li></ul></li><li><p>指令集</p><ul><li><p>记录指令名称、用法、操作码以及所需 RAM 地址位数的表格。</p></li><li></li></ul></li></ul><h3 id="指令的执行">指令的执行</h3><ul><li><p>原则</p><ul><li><p>RAM 每一个地址中，都存放 0 或 1 个数据。</p></li><li><p>特定的数字组合，就表示为一个指令，否则表示一个值。</p></li></ul></li><li><p>几种指令</p><ul><li><p>LOAD 指令</p><ul><li><p>计算机会按地址的顺序，读取 RAM 中所记录的指令/数据。</p></li><li><p>计算机接受到指令后，如 LOAD_A，则通过数据线将数据传至寄存器 A。</p></li></ul></li><li><p>ADD指令</p><ul><li>ADD B A 指令告诉 ALU，把寄存器 B 和寄存器中的数字加起来，存到寄存器 A 中。</li></ul></li><li><p>JUMP指令</p><ul><li><p>遇到 JUMP 指令，程序会跳转至对应的 RAM 地址读取数据。</p></li><li><p>JUMP 指令可以有条件跳转（如 JUMP-negative），也可以无条件跳转。</p></li></ul></li></ul></li></ul><h3 id="计算机指令长度">计算机指令长度</h3><ul><li><p>由于早期计算机每个字只有 8 位，指令只占 4 位，意味着只能有 16 个指令，这远远不够。现代计算机有两种方式解决指令不够用的问题</p><ul><li><p>1、更多位来表示指令，如 32 位或 64 位。</p></li><li><p>2、采用“可变指令长度”，令不同的指令的长度不同，尽量节约位数。</p><p>假设 1 个字为 16 位，如果某指令不需要操作内存，则可以省去寻址的位数。<br>该情况下，部分指令后面需要跟数据，如 JUMP，称为立即值。</p></li></ul></li></ul><h2 id="9、高级CPU设计、">9、高级CPU设计、</h2><h3 id="概念-2">概念</h3><ul><li><p>缓存</p><p>为了不让 CPU 空等数据，在 CPU 内部设置了一小块内存，称为缓存，让 RAM 可以一次传输一批数据到 CPU 中。（不加缓存，CPU 没位置放大量数据）</p><p>缓存也可以当临时空间，存一些中间值，适合长/复杂的运算</p><p>脏位：储存在缓存中与 RAM 不一致的数据</p><p>空等原因：从 RAM 到 CPU 的数据传输有延迟（要通过总线，RAM 还要时间找地址、取数据、配置、输出数据）。</p><p>缓存同步：缓存同步一般发生在 CPU 缓存已满，但 CPU 仍需往缓存内输入数据。此时，被标记为脏位的数据会优先传输回 RAM,腾出位置以防被覆盖，导致计算结果有误。</p><ul><li><p>在 CPU 中的小块 RAM，用于存储批量指令。</p><ul><li><p>缓存命中：想要的数据已经在缓存里</p></li><li><p>缓存未命中：想要的数据不在缓存里</p></li><li><p>脏位：缓存里每块空间，有个特殊标记，叫脏位，用于检测缓存内的数据是否与 RAM 一致。</p></li></ul></li></ul></li><li><p>多核处理器</p><ul><li>一个 CPU 芯片中，有多个独立处理单元。</li></ul></li></ul><h3 id="现代CPU如何提升性能">现代CPU如何提升性能</h3><ul><li><p>早期通过加快晶体管速度，来提升 CPU 速度。但很快该方法到达了极限。</p></li><li><p>后来给 CPU 设计了专门除法电路+其他电路来做复杂操作：如游戏，视频解码</p></li><li><p>指令流水线</p><ul><li><p>作用</p><ul><li><p>让取址→解码→执行三个步骤同时进行。并行执行指令，提升CPU性能。<br>原本需要 3 个时钟周期执行 1 个指令，现在只需要 1 个时钟周期。</p><ul><li></li></ul></li></ul></li><li><p>设计难点</p><ul><li><p>数据具有依赖性</p><ul><li>数据依赖性解决方法：动态排序那些有依赖关系的指令（乱序执行）</li></ul></li><li><p>条件跳转程序</p><ul><li>条件跳转程序解决办法：推测执行、分支预测</li></ul></li></ul></li><li><p>超标量处理器</p><ul><li><p>一个时钟周期内完成多个指令</p><ul><li></li></ul></li></ul></li></ul></li><li><p>同时执行多个指令流</p><ul><li><p>多核处理器</p><ul><li></li><li><p>一个 CPU 芯片中，有多个独立处理单元。但因为它们整合紧密，可以共享一些资源。</p></li></ul></li></ul></li><li><p>使用更多CPU</p></li></ul><h2 id="10、早期编程方式">10、早期编程方式</h2><h3 id="早期，程序如何进入计算机">早期，程序如何进入计算机</h3><ul><li>程序必须人为地输入计算机。早期，电脑无内存的概念，人们通过打孔纸卡等物理手段，输入数据（数字），进入计算机。</li></ul><h3 id="早期计算机的编程">早期计算机的编程</h3><ul><li><p>打孔纸卡/纸带</p><ul><li>在纸卡上打孔，用读卡器读取连通电路，进行编程。原因，穿孔纸卡便宜、可靠也易懂。</li></ul></li><li><p>插线板</p><ul><li>通过插拔线路的方式，改变器件之间的连接方式，进行编程。</li></ul></li><li><p>面板开关</p><ul><li>通过拨动面板上的开关，进行编程。输入二进制操作码，按存储按钮，推进至下一个内存位，直至操作完内存，按运行键执行程序。（内存式电脑）</li></ul></li></ul><h3 id="现代计算机基础结构——冯诺依曼计算机">现代计算机基础结构——冯诺依曼计算机</h3><ul><li><p>程序和数据都存在一个地方</p></li><li><p>冯诺依曼计算机的标志是，一个处理器(有算术逻辑单元)+数据寄存器+指令寄存器+指令地址寄存器+内存</p></li></ul><h2 id="11、编程语言发展史">11、编程语言发展史</h2><h3 id="概念-3">概念</h3><ul><li><p>伪代码</p><ul><li>用自然语言（中文、英语等）对程序的高层次描述，称为“伪代码”</li></ul></li><li><p>汇编器</p><ul><li>用于将汇编语言装换成机器语言。一条汇编语句对应一条机器指令。</li></ul></li><li><p>助记符</p><ul><li>机器操作码的语言表述</li></ul></li></ul><h3 id="早期二进制写代码">早期二进制写代码</h3><ul><li>早期，人们先在纸上写伪代码，用&quot;操作码表&quot;把伪代码转成二进制机器码，翻译完成后，程序可以喂入计算机并运行。</li></ul><h3 id="最早高级编程语言“A-0”">最早高级编程语言“A-0”</h3><ul><li><p>出现背景</p><ul><li>汇编只是修饰了一下机器码，一般来说，一条汇编指令对应一条机器指令，所以汇编码和底层硬件的连接很紧密，汇编器仍然强迫程序员思考底层逻辑。</li></ul></li><li><p>发明历程</p><ul><li>1950s，为释放计算机潜力，葛丽丝·霍普博士，设计了一个高级编程语言，叫 “Arithmetic Language Version 0”，一行高级编程语言  可以转成几十条二进制指令。但由于当时人们认为，计算机只能做计算，而不能做程序，A-0 未被广泛使用。</li></ul></li></ul><h3 id="开始广泛应用的高级编程语言-FORTRAN">开始广泛应用的高级编程语言 FORTRAN</h3><ul><li>1957 年由 IBM1957 年发布，平均来说，FORTRAN 写的程序，比等同的手写汇编代码短 20 倍。FORTRAN 编译器会把代码转成机器码。但它只能运行于一款电脑中，不通用。</li></ul><h3 id="通用编程语言——COBOL">通用编程语言——COBOL</h3><ul><li>1959 年，研发可以在不同机器上通用编程语言。最后研发出一门高级语言：“普通面向商业语言”，简称 COBOL。<br>每个计算架构需要一个 COBOL 编译器，不管是什么电脑都可以运行相同的代码，得到相同结果。</li></ul><h3 id="现代编程语言-1960s-2000">现代编程语言:1960s-2000</h3><ul><li>1960s 起，编程语言设计进入黄金时代。<br>1960：LGOL, LISP 和 BASIC 等语言<br>70 年代有：Pascal，C 和 Smalltalk<br>80 年代有：C++，Objective-C 和 Perl<br>90 年代有：Python，Ruby 和 Java</li></ul><h3 id="安全漏洞-补丁由来">*安全漏洞&amp;补丁由来</h3><ul><li>在 1940 年代，程序是由打孔纸带制成的，纸带破损例如出现了漏洞，程序就无法运行，为了节约时间，只能贴上胶带也就是打补丁来填补漏洞，漏洞和补丁因此得名。</li></ul><h2 id="12、编程原理——语句和函数">12、编程原理——语句和函数</h2><h3 id="变量、赋值语句">变量、赋值语句</h3><ul><li>如a=5 ，其中a为可赋值的量，叫做变量。把数字 5 放a里面.这叫&quot;赋值语句&quot;，即把一个值赋给一个变量</li></ul><h3 id="if判断">if判断</h3><ul><li>可以想成是 “如果 X 为真，那么执行 Y，反之，则不执行Y”，if语句就像岔路口，走哪条路取决于条件的真假。</li></ul><h3 id="while循环">while循环</h3><ul><li>当满足条件时进入循环，进入循环后，当条件不满足时，跳出循环。</li></ul><h3 id="for循环">for循环</h3><ul><li>for循环不判断条件，判断次数，会循环特定次数，不判断条件。for 的特点是，每次结束， i 会 +1</li></ul><h3 id="函数">函数</h3><ul><li>当一个代码很常用的时候，我们把它包装成一个函数（也叫方法或者子程序），其他地方想用这个代码，只需要写函数名即可。</li></ul><h2 id="13、算法入门">13、算法入门</h2><h3 id="基本概念">基本概念</h3><ul><li><p>算法</p><ul><li>解决问题的基本步骤</li></ul></li><li><p>大O表示法</p><ul><li>大O表示法（算法）的复杂度：算法的输入大小和运行步骤之间的关系，来表示运行速度的量级</li></ul></li></ul><h3 id="选择排序">选择排序</h3><ul><li>选择排序的复杂度为O(n²)</li></ul><h3 id="归并排序">归并排序</h3><ul><li>归并排序的算法复杂度为O（n*log n），n是需要比较+合并的次数，和数组大小成正比，log n是合并步骤所需要的的次数，归并排序比选择排序更有效率</li></ul><h3 id="Dijkstra算法">Dijkstra算法</h3><ul><li>一开始复杂度为O(n²)，优化后复杂度为O（nlog n +I），在（图）中，n表示节点数，I表示有多少条线。</li></ul><h2 id="14、数据结构">14、数据结构</h2><h3 id="数组">数组</h3><ul><li>数组（Array），也叫列表（list）或向量（Vector），是一种数据结构。为了拿出数组中某个值，我们要指定一个下标（index），大多数编程语言里，数组下标都从 0 开始，用方括号 [ ] 代表访问数组。</li></ul><h3 id="字符串">字符串</h3><ul><li>即字母、数字、标点等组成的数组，字符串在内存里以NULL结尾。</li></ul><h3 id="矩阵">矩阵</h3><ul><li>数组的数组<br>例如：二维矩阵就是两个数组组合，三维矩阵就是三个数组组合。</li></ul><h3 id="结构体">结构体</h3><ul><li><p>多个数据类型打包在一起组成的新的数据类型</p><ul><li></li></ul></li></ul><h3 id="指针">指针</h3><ul><li>指针是一种特殊变量，指向一个内存地址，因此得名。</li></ul><h3 id="节点">节点</h3><ul><li><p>有一个指针数据类型和一个其他数据类型的结构体叫做节点。</p><ul><li></li></ul></li></ul><h3 id="链表">链表</h3><ul><li><p>用节点可以做链表，链表是一种灵活数据结构，能存很多个节点 (node)，灵活性是通过每个节点指向下一个节点实现的。链表可以是循环的也可以是非循环的，非循环的最后一个指针指向NULL。</p><ul><li></li></ul></li><li><p>优点</p><ul><li><p>1、不像数组一旦创建大小就固定，链表大小可以动态增减，只需改变节点中的指针变量的值即可。</p></li><li><p>2、链表也很容易重新排序、两端缩减、分割、倒序、插入新元素等。</p></li></ul></li></ul><h3 id="队列">队列</h3><ul><li><p>“队列” 就像邮局排队，谁先来就排前面，这叫“先进先出”(FIFO)</p><ul><li></li></ul></li></ul><h3 id="栈">栈</h3><ul><li>与队列类似，但是遵循先进后出(LIFO)原则</li></ul><h3 id="树">树</h3><ul><li><p>为每个节点添加一个指针变量，就构成了树的基本组成元素，每个节点指向后两个分支，结束处的节点指向NULL。</p><ul><li></li></ul></li><li><p>重要特征</p><ul><li>根（起始节点）到叶（结束节点）是单向的</li></ul></li></ul><h3 id="图">图</h3><ul><li><p>节点随意连接，区别于树，不存在母节点和子节点。</p><ul><li></li></ul></li></ul><h3 id="红黑树">红黑树</h3><h3 id="堆">堆</h3><h2 id="15、阿兰·图灵">15、阿兰·图灵</h2><h3 id="可判定性问题">可判定性问题</h3><ul><li>是否存在一种算法，输入正式逻辑语句，输出准确的&quot;是&quot;或&quot;否&quot;答案？</li></ul><h3 id="阿隆佐邱奇，Lambda算子">阿隆佐邱奇，Lambda算子</h3><ul><li>美国数学家 阿隆佐·丘奇，开发了一个叫&quot;Lambda 算子&quot;的数学表达系统，证明其不存在。</li></ul><h3 id="图灵机">图灵机</h3><ul><li>只要有足够的规则，状态和纸带，图灵机可以解决一切计算问题。能和图灵机达成相同功能的，叫做图灵完备。</li></ul><h3 id="停机问题">停机问题</h3><ul><li>证明图灵机（计算）不能解决所有问题。</li></ul><h3 id="图灵测试">图灵测试</h3><ul><li>向人和机器同时发信息，收到的回答无法判断哪个是人，哪个是计算机，则计算机达到了智能程度。</li></ul><h2 id="16、软件工程">16、软件工程</h2><h3 id="对象">对象</h3><ul><li><p>当任务庞大，函数太多，我们需要把函数打包成层级，把相关代码都放一起，打包成对象。对象可以包括其他对象，函数和变量。</p><ul><li></li><li></li></ul></li></ul><h3 id="面向对象编程">面向对象编程</h3><ul><li><p>把函数打包成对象的思想叫做“面向对象编程”</p></li><li><p>面向对象的核心是隐藏复杂度，选择性的公布功能。</p></li></ul><h3 id="API">API</h3><ul><li><p>当团队接收到另一团队编写的对象时，需要文档和程序编程接口（API）来帮助合作。API控制哪些函数和数据让外部访问，哪些仅供内部。</p></li><li><p>API帮助不同的程序员合作，不用知道具体细节，只要知道怎么使用就行了</p></li></ul><h3 id="public和private">public和private</h3><ul><li><p>public表示此函数其他对象也可以调用，不局限于其所属对象。</p></li><li><p>private表示此函数只能被其所属对象内的其他函数调用，其他对象无法调用。</p></li></ul><h3 id="集成开发环境IDE">集成开发环境IDE</h3><ul><li>集成了很多有用的功能帮助程序员写代码，整理，编译和测试代码。</li></ul><h3 id="文档和注释">文档和注释</h3><ul><li>文档一般放在一个叫做README的文件里，文档也可以直接写成“注释”，放在源代码里，注释是标记过的一段文字，编译代码时，注释会被忽略。注释和文档的唯一作用是帮助开发者理解代码。</li></ul><h3 id="版本控制（源代码管理）">版本控制（源代码管理）</h3><ul><li>版本控制，又称源代码管理。<br>大型软件公司会把代码放到一个中心服务器上，叫&quot;代码仓库&quot;，程序员可以把想修改的代码借出，修改后再提交回代码仓库。<br>版本控制可以跟踪所有变化，如果发现bug，全部或部分代码，可以&quot;回滚&quot;到之前的稳定版。</li></ul><h3 id="质量测试QA">质量测试QA</h3><ul><li>测试可以统称“质量保证测试”（QA），作用是找bug</li></ul><h3 id="beta和alpha">beta和alpha</h3><ul><li>beta版软件，即是软件接近完成，但没有完全被测试过，公司有时会向公众发布beta版，以帮助发现问题。alpha是beta前的版本，一般很粗糙，只在内部测试</li></ul><h2 id="17、集成电路和摩尔定律">17、集成电路和摩尔定律</h2><h3 id="分立元件与数字暴政">分立元件与数字暴政</h3><ul><li>一开始，计算机都有独立组件构成，叫&quot;分立元件&quot; ， 然后不同组件再用线连在一起，这会导致计算机的构成很复杂，这个问题叫做数字暴政。</li></ul><h3 id="集成电路与仙童半导体">集成电路与仙童半导体</h3><ul><li><p>封装复杂性：与其把多个独立部件用电线连起来，拼装出计算机，不如把多个组件包在一起，变成一个新的独立组件。这种新的独立组件就叫集成电路（IC），仙童半导体（用硅做成）让集成电路变成了现实。</p></li><li><p>为了不用焊接或用一大堆线，发明了印刷电路板（PCB），他通过蚀刻金属线的方式把零件连接到一起</p></li></ul><h3 id="光刻">光刻</h3><ul><li><p>光刻单个晶体管过程示意</p></li><li><p>成品示意</p></li></ul><h3 id="摩尔定律">摩尔定律</h3><ul><li>每两年左右，得益于材料和制造技术的发展 ，同样大小的空间，能塞进两倍数量的晶体管。</li></ul><h3 id="进一步小型化会碰到的问题">进一步小型化会碰到的问题</h3><ul><li><p>1、由于光的波长限制，精度已到极限。</p></li><li><p>2、量子隧穿效应：当晶体管非常小，电极之间可能只距离几个原子，电子会跳过间隙，发生电子隧穿效应，会产生漏电问题。</p></li></ul><h2 id="18、操作系统">18、操作系统</h2><h3 id="概念-4">概念</h3><ul><li>操作系统也是一种程序，不过它有操作硬件的特殊权限，可以运行和管理其他程序。</li></ul><h3 id="批处理">批处理</h3><ul><li>一个程序运行后会自动运行下一个程序。</li></ul><h3 id="外部设备">外部设备</h3><ul><li>和计算机连着的其他设备，如打印机。</li></ul><h3 id="设备驱动程序">设备驱动程序</h3><ul><li>为了使所写程序和不同类型的外部设备兼容，我们需要操作系统充当软件和硬件之间的媒介，更具体地说，操作系统提供程序编程接口(API)来抽象硬件,叫“设备驱动程序”。程序员可以用标准化机制，和输入输出硬件（I/O）交互，</li></ul><h3 id="多任务处理">多任务处理</h3><ul><li><p>操作系统能使多个程序在单个CPU上同时进行的能力，叫做“多任务处理”</p></li><li><p>原理是让CPU先搁置打印、显示等需要外部设备的程序，转而执行那些此刻需要CPU的程序，等打印、显示等操作完成后，再回到原程序。</p></li></ul><h3 id="动态内存分配">动态内存分配</h3><ul><li>动态内存分配机制使程序的内存大小可以灵活增减，叫做“动态内存分配”。</li></ul><h3 id="虚拟内存">虚拟内存</h3><ul><li><p>动态内存分配带来了程序所占用内存可能不连续的问题，导致程序员难以追踪一个程序，为了解决这个问题操作系统会把内存地址虚拟化，这叫“虚拟内存”。</p><ul><li></li></ul></li></ul><h3 id="内存保护">内存保护</h3><ul><li>给每个程序分配单独的内存，那当这个程序出现混乱时，它不会影响到其他程序的内存，同时也能有效地防止恶意程序篡改其他程序，这叫做内存保护。</li></ul><h3 id="多用户分时操作系统（Multics）">多用户分时操作系统（Multics）</h3><ul><li>用来处理多用户同时使用一台计算机的情况，即每个用户只能用一小部分处理器，内存等，</li></ul><h3 id="Unix">Unix</h3><ul><li>Unix把操作系统分成两个部分，一个是操作系统的核心部分，如内存管理，多任务和输入/输出处理，这叫做“内核”（kernel），第二部分是一堆有用的工具，比如程序和运行库。</li></ul><h2 id="19、内存和存储介质">19、内存和存储介质</h2><h3 id="纸卡">纸卡</h3><ul><li><p>图示</p><ul><li>80列，12行，一张卡能存960位数据</li></ul></li><li><p>优点</p><ul><li>不用电并且便宜耐用</li></ul></li><li><p>缺点</p><ul><li>读取慢 难修改 难存临时值</li></ul></li></ul><h3 id="延迟线存储器">延迟线存储器</h3><ul><li><p>通过麦克风有无接收压力波来表示0和1<br>将输入作为输入，创建出一个存储数据的循环</p></li><li><p>缺点</p><ul><li><p>每一个时刻只能读一位数据，想要读一个完整的程序要花挺长时间</p></li><li><p>存储密度无法很大，否则压力波会混淆在一起无法分别</p></li></ul></li></ul><h3 id="磁芯存储器">磁芯存储器</h3><ul><li><p>存储单元</p><ul><li>电流导致磁芯磁化，根据磁化的方向来存储0和1，且断电后磁化仍能保持，意味着能永久存储数据</li></ul></li><li><p>一个实体例子</p><ul><li></li><li></li></ul></li><li><p>优点</p><ul><li>可以随机访问任何一位数据</li></ul></li></ul><h3 id="磁带">磁带</h3><ul><li><p>存储原理</p><ul><li>电流使磁带上的一小部分磁化，磁化方向表示0和1，读头用于非破坏地检测极性</li></ul></li><li><p>例子</p><ul><li></li></ul></li><li><p>优点</p><ul><li>便宜且小</li></ul></li><li><p>缺点</p><ul><li>访问速度慢</li></ul></li></ul><h3 id="磁鼓">磁鼓</h3><ul><li><p>与磁带类似，只是由带变成了圆柱</p></li><li><p>例子</p><ul><li></li></ul></li></ul><h3 id="硬盘">硬盘</h3><ul><li>与磁带类似，只是改用了盘状</li></ul><h3 id="内存层次结构">内存层次结构</h3><ul><li></li></ul><h3 id="软盘">软盘</h3><ul><li>除了磁盘是软的，其他都和硬盘一样，好处是便携</li></ul><h3 id="光盘">光盘</h3><ul><li><p>原理：光盘表面有很多小坑，造成光的不同反射，光学传感器会捕获到，并解码为 1 和 0</p></li><li></li></ul><h3 id="固态硬盘">固态硬盘</h3><ul><li>用集成电路来存储数据</li></ul><h2 id="20、文件系统">20、文件系统</h2><h3 id="为什么要采用文件格式">为什么要采用文件格式</h3><ul><li>可以随便存文件数据，但按格式存会更方便，也更统一，可移植性好</li></ul><h3 id="TXT-文本文件">TXT 文本文件</h3><ul><li>将一大串二进制数用ASCII解码，得出所存储的文本</li></ul><h3 id="WAV-音频文件">WAV 音频文件</h3><ul><li><p>元数据</p><ul><li><p>关于数据的数据</p></li><li><p>例子</p><ul><li>元数据也叫文件头</li></ul></li></ul></li><li><p>记录的是振幅</p><ul><li>采样率：每秒采样多少次</li></ul></li></ul><h3 id="BMP-图像文件">BMP 图像文件</h3><ul><li>记录每个像素的红绿蓝 RGB 值</li></ul><h3 id="目录文件">目录文件</h3><ul><li><p>用来解决多文件问题，存文件的信息，比如开头，结尾，创建时间等</p><ul><li></li></ul></li></ul><h3 id="平面文件系统-Flat-File-System">平面文件系统 - Flat File System</h3><ul><li>文件都在同一个层次，没有子文件夹。早期空间小，只有十几个文件，平面系统够用</li></ul><h3 id="解决文件紧密的排序造成的问题">解决文件紧密的排序造成的问题</h3><ul><li><ol><li>把空间划分成一块块</li></ol></li><li><ol start="2"><li>文件拆分存在多个块里</li></ol></li></ul><h3 id="碎片整理">碎片整理</h3><ul><li>文件的增删改查会不可避免的造成文件散落在各个块里，如果是磁带这样的存储介质就会造成读写问题，所以需要碎片整理——计算机把文件内容调换位置。</li></ul><h2 id="21、压缩">21、压缩</h2><h3 id="压缩的好处">压缩的好处</h3><ul><li>能使文件大小降低，能存更多文件，传输也更快</li></ul><h3 id="无损压缩-Lossless-compression">无损压缩 Lossless compression</h3><ul><li><p>游程编码 Run-Length Encoding</p><ul><li><p>适合经常出现相同值的文件</p></li><li><p>以吃动人图像为例</p><ul><li></li></ul></li></ul></li><li><p>字典编码 Dictionary coders</p><ul><li><p>霍夫曼树 Huffman Tree</p><ul><li></li></ul></li></ul></li></ul><h3 id="有损压缩">有损压缩</h3><ul><li><p>感知编码 Perceptual coding</p><ul><li>删掉人类无法感知的数据的有损压缩方法，叫做“感知编码”，如音频文件，人类听不到超声波，所以可以舍去，MP3就是音频的一种压缩形式。</li></ul></li></ul><h3 id="时间冗余-Temporal-redundancy">时间冗余 Temporal redundancy</h3><ul><li>一个视频由很多图片构成，其中很多图片的背景一样，这就构成了时间冗余，很多视频编码格式，只存变化的部分。进阶的视频压缩模式会找到帧与帧的相似性，然后打补丁，MPEG-4 是视频压缩的常见标准。</li></ul><h2 id="22、命令行界面">22、命令行界面</h2><h3 id="人机交互-（Human-Computer-Interaction）发展史">人机交互 （Human-Computer Interaction）发展史</h3><ul><li><p>计算机早期同时输入程序和数据（用纸卡/纸带）运行开始直到结束，中间没有人类进行操作，原因是计算机很贵，不能等人类慢慢输入，执行完结果打印到纸上</p></li><li><p>到1950年代，计算机足够便宜+快，人类和计算机交互式操作变得可行，为了让人类输入到计算机，改造之前就有的打字机，变成电传打字机</p></li><li><p>到1970年代末，屏幕成本足够低，屏幕代替电传打字机，屏幕成为标配</p></li></ul><h3 id="人机交互工具的变化">人机交互工具的变化</h3><ul><li><p>1、早期输出数据是打印到纸上，而输入是用纸卡/纸带一次性把程序和数据都给进去</p></li><li><p>2、QWERTY 打字机的发展</p></li><li><p>3、电传打字机 Teletype machine</p><ul><li>作用：用于发电报，使两人可以远距离沟通</li></ul></li></ul><h3 id="命令行界面-Command-line-interface">命令行界面 Command line interface</h3><ul><li>输入命令，计算机会给予回应</li></ul><h2 id="23、屏幕与2D图形显示">23、屏幕与2D图形显示</h2><h3 id="PDP-1-计算机、键盘和显示器分开，屏幕显示临时值">PDP-1 计算机、键盘和显示器分开，屏幕显示临时值</h3><h3 id="阴极射线管-Cathode-Ray-Tube-CRT">阴极射线管 Cathode Ray Tube (CRT)</h3><ul><li><p>CRT 有两种绘图方式</p><ul><li><p>矢量扫描 Vector Scanning</p><ul><li>通过控制电子枪发射电子位置来绘制图形</li></ul></li><li><p>光栅扫描 Raster Scanning</p><ul><li>通过逐行扫描发射电子来绘制图形</li></ul></li></ul></li></ul><h3 id="液晶显示器-Liquid-Crystal-Displays-LCD-，像素-Pixel">液晶显示器 Liquid Crystal Displays (LCD)，像素 (Pixel)</h3><ul><li>液晶显示器 Liquid Crystal Displays (LCD)，像素 (Pixel)</li></ul><h3 id="字符生成器-Character-generator">字符生成器 Character generator</h3><ul><li>相比于像素，为了减少内存占用，人们更喜欢使用字符。计算机需要额外硬件，来从内存读取字符，转换成光栅图形，这样才能显示到屏幕上，这个硬件叫 “字符生成器”，基本算是第一代显卡。它内部有一小块只读存储器，简称 ROM，存着每个字符的图形，叫&quot;点阵图案&quot;。</li></ul><h3 id="屏幕缓冲区-Screen-buffer">屏幕缓冲区 Screen buffer</h3><ul><li>为了显示，“字符生成器” 会访问内存中一块特殊区域，这块区域专为图形保留，叫 屏幕缓冲区，程序想显示文字时，修改这块区域里的值就行。</li></ul><h3 id="矢量命令画图">矢量命令画图</h3><ul><li>概念非常简单：所有东西都由线组成,矢量指令可以画出线，把许多矢量指令存在硬盘上，就能画出很多由线组成的复杂图形。</li></ul><h3 id="Sketchpad-光笔-Light-pen-，位图显示和画矩形">Sketchpad, 光笔 (Light pen)，位图显示和画矩形</h3><ul><li>Sketchpad ，一个交互式图形界面，用途是计算机辅助设计 (CAD)。<br>光笔，就是一个有线连着电脑的触控笔，有了它们，用户可以画出很完美的线条并进行缩放等操作。<br>位图显示，内存中的位对应着屏幕上显示的像素。<br>想画更复杂的图形，如画矩形，我们需要四个值，起点的x y坐标，高度和宽度。</li></ul><h2 id="24、冷战和消费主义">24、冷战和消费主义</h2><h3 id="概括：政府和消费者推动了计算机的发展">概括：政府和消费者推动了计算机的发展</h3><p>早期靠政府资金，让技术发展到足够商用，然后消费者购买商用产品继续推动产品发展</p><h3 id="计算机发展历程">计算机发展历程</h3><ul><li><p>冷战导致美国往计算机领域投入大量资源</p></li><li><p>范内瓦·布什 预见了计算机的潜力，提出假想机器 Memex帮助建立 国家科学基金会，给科学研究提供资金</p></li><li><p>1950 年代消费者开始买晶体管设备，收音机大卖日本取得晶体管授权后，索尼做了晶体管收音机，为日本半导体行业崛起埋下种子</p></li><li><p>苏联 1961 年把宇航员加加林送上太空，导致美国提出登月NASA 预算大大增加，用集成电路来制作登月计算机</p></li><li><p>集成电路的发展实际上是由军事应用大大推进的，阿波罗登月毕竟只有 17 次美国造超级计算机进一步推进集成电路</p></li><li><p>美国半导体行业一开始靠政府高利润合同活着，忽略消费者市场，1970年代冷战渐消，行业开始衰败很多公司倒闭，英特尔转型处理器 。</p></li></ul><h2 id="25、个人计算机革命">25、个人计算机革命</h2><h3 id="1970年代初成本下降，个人计算机变得可行-RAM：random-access-memory-随机访问存储器-ROM：read-only-memory-只读存储器">1970年代初成本下降，个人计算机变得可行           RAM：random-access memory 随机访问存储器   ROM：read-only memory 只读存储器</h3><h3 id="Altair-8800-第一台取得商业成功的个人计算机">Altair 8800 第一台取得商业成功的个人计算机</h3><h3 id="比尔·盖茨-和-保罗·艾伦-写-BASIC-解释器，解释器和编译器类似，区别是解释器运行时转换，而编译器提前转换。">比尔·盖茨 和 保罗·艾伦 写 BASIC 解释器，解释器和编译器类似，区别是解释器运行时转换，而编译器提前转换。</h3><h3 id="乔布斯提议卖组装好的计算机，Apple-I-诞生。">乔布斯提议卖组装好的计算机，Apple-I 诞生。</h3><h3 id="1977年出现3款开箱即用计算机：">1977年出现3款开箱即用计算机：</h3><p>“Apple-II”，“TRS-80 Model I”，“Commodore PET 2001”</p><h3 id="IBM-意识到个人计算机市场IBM-PC-发布，采用开放架构，兼容的机器都叫-IBM-Compatible-IBM-兼容-。">IBM 意识到个人计算机市场IBM PC 发布，采用开放架构，兼容的机器都叫 IBM Compatible (IBM 兼容)。</h3><p>生态系统产生雪球效应：因为用户多，软硬件开发人员更愿意花精力在这个平台因为软硬件多，用户也更乐意买 “IBM 兼容” 的计算机。</p><h3 id="苹果选封闭架构，一切都自己来，只有苹果在非-“IBM-兼容”-下保持了足够市场份额">苹果选封闭架构，一切都自己来，只有苹果在非 “IBM 兼容” 下保持了足够市场份额</h3><h2 id="26、用户图形界面（GUI）">26、用户图形界面（GUI）</h2><h3 id="GUI是“事件驱动编程”，代码可以在任意时间执行以响应事件，而不像传统代码一样自上而下。">GUI是“事件驱动编程”，代码可以在任意时间执行以响应事件，而不像传统代码一样自上而下。</h3><h3 id="图形界面先驱：道格拉斯·恩格尔巴特（Douglas-Engelbart）——设想计算机成为未来知识性员工应对问题的工具，并发明了鼠标。">图形界面先驱：道格拉斯·恩格尔巴特（Douglas Engelbart）——设想计算机成为未来知识性员工应对问题的工具，并发明了鼠标。</h3><h3 id="1970年成立-帕洛阿尔托研究中心（Palo-Alto-Research-Center）">1970年成立 帕洛阿尔托研究中心（Palo Alto Research Center）</h3><h3 id="1973年完成-Xerox-Alto-施乐奥托-计算机——创立了桌面，窗口等计算机概念">1973年完成 Xerox Alto(施乐奥托) 计算机——创立了桌面，窗口等计算机概念</h3><h3 id="1981年的-Xerox-Star-system（施乐之星系统）创建了文档概念">1981年的 Xerox Star system（施乐之星系统）创建了文档概念</h3><h3 id="所见即所得-WYSIWYG——施乐打印出来的东西和计算机上一样，并发明了剪切-复制-黏贴等计算机概念">所见即所得 WYSIWYG——施乐打印出来的东西和计算机上一样，并发明了剪切 复制 黏贴等计算机概念</h3><h3 id="史蒂夫·乔布斯去施乐参观，并被GUI启发">史蒂夫·乔布斯去施乐参观，并被GUI启发</h3><h3 id="1983年推出-Apple-Lisa">1983年推出 Apple Lisa</h3><h3 id="1984年推出-Macintosh-成功">1984年推出 Macintosh 成功</h3><h3 id="1985年推出-Windows-1-0，之后出到-3-1，但此时的Windows的图形界面还是基于DOS的，并不是真正的图形界面。">1985年推出 Windows 1.0，之后出到 3.1，但此时的Windows的图形界面还是基于DOS的，并不是真正的图形界面。</h3><h3 id="1995年推出-Windows-95-提供新的图形界面，并有Mac没有的新功能，如多任务和受保护内存。">1995年推出 Windows 95 提供新的图形界面，并有Mac没有的新功能，如多任务和受保护内存。</h3><h3 id="1995年微软做失败的-Microsoft-Bob——类似于房子的设计">1995年微软做失败的 Microsoft Bob——类似于房子的设计</h3><h2 id="27、3D图形">27、3D图形</h2><h3 id="线框渲染-Wireframe-Rendering">线框渲染 Wireframe Rendering</h3><ul><li>有图形算法 负责把3D坐标&quot;拍平&quot;显示到2D屏幕上，这叫3D投影(包括正交投影和透视投影)，所有的点都从3D转成2D后，就可以用画2D线段的函数来连接这些点，这叫线框渲染。</li></ul><h3 id="网格-Mesh">网格 Mesh</h3><ul><li><p>如果我们需要画比立方体复杂的图形，三角形比线段更好，在3D图形学中我们叫三角形&quot;多边形&quot;(Polygons)，一堆多边形的集合叫 网格，网格越密，表面越光滑，细节越多，</p></li><li><p>三角形更常用因为能定义唯一的平面</p></li></ul><h3 id="图形颜色填充">图形颜色填充</h3><ul><li><p>扫描线渲染 Scanline Rendering——填充图形的经典算法</p><ul><li><p>填充的速度叫做填充速率</p></li><li><p>抗锯齿——边缘羽化，如果像素在多边形内部，就直接涂颜色，如果多边形划过像素，颜色就浅一些</p><ul><li></li></ul></li></ul></li></ul><h3 id="如何处理远近关系">如何处理远近关系</h3><ul><li><p>遮挡 Occlusion</p><ul><li>用排序算法，从远到近排列，然后从远到近渲染，这叫画家算法</li></ul></li><li><p>深度缓冲 Z-Buffering</p><ul><li><p>另一种画遮挡的方法，简而言之，Z-buffering 算法会记录场景中每个像素和摄像机的距离，在内存里存一个数字矩阵，首先，每个像素的距离被初始化为&quot;无限大&quot;，然后 Z-buffering 从列表里第一个多边形开始处理，也就是A，它和扫描线算法逻辑相同，但不是给像素填充颜色，而是把多边形的距离和 Z-Buffer 里的距离进行对比，它总是记录更低的值，因为没对多边形排序，所以后处理的多边形并不总会覆盖前面的。</p><ul><li></li></ul></li><li><p>Z-Fighting 错误</p><ul><li>采用深度缓冲算法，哪个图形在前将会变化</li></ul></li></ul></li></ul><h3 id="背面剔除-Back-Face-Culling">背面剔除 Back Face Culling</h3><ul><li>由于游戏角色的头部或地面，只能看到朝外的一面，所以为了节省处理时间，会忽略多边形背面，这很好,但有个bug是 如果进入模型内部往外看，头部和地面会消失</li></ul><h3 id="光照阴影">光照阴影</h3><ul><li><p>表面法线 Surface Normal</p><ul><li>在3D图形上任取一小个区域，它面对的方向叫“表面法线”</li></ul></li><li><p>平面着色 Flat Shading</p><ul><li>基本的照明算法，缺点是使多边形边界明显，看上去不光滑</li></ul></li><li><p>高洛德着色 Gouraud shading, 冯氏着色 Phong Shading</p><ul><li>不只用一种颜色上色，可以让边界过度平滑，效果佳</li></ul></li></ul><h3 id="纹理">纹理</h3><ul><li><p>纹理映射 Texture Mapping</p><ul><li><p>纹理在图形学中指外观，纹理有多种算法来达到花哨效果，最经典的是纹理映射。</p><ul><li></li></ul></li></ul></li></ul><h3 id="图形处理单元-GPU-Graphics-Processing-Unit">图形处理单元 GPU, Graphics Processing Unit</h3><ul><li>方便并行处理多个图形，并把图形分成一个个小块来处理。</li></ul><h2 id="28、计算机网络">28、计算机网络</h2><h3 id="网络术语">网络术语</h3><ul><li><p>局域网 Local Area Networks - LAN</p><ul><li>计算机近距离构成的小型网络，叫局域网（LAN），以太网是经典的局域网</li></ul></li><li><p>媒体访问控制地址 Media Access Control address - MAC</p><ul><li>用于确认局域网和WiFi传输的对象</li></ul></li><li><p>载波侦听多路访问 Carrier Sense Multiple Access - CSMA</p><ul><li>多台电脑共享一个传输媒介，叫做载波侦听多路访问，共享媒介又称载体，如WiFi的载体是空气，以太网的载体是电线。载体传输数据的速度叫带宽。</li></ul></li><li><p>指数退避 Exponential Backoff</p><ul><li>当多台计算机同时想要传输数据时，就会发生冲突，当计算机检测到冲突 就会在重传之前等待一小段时间，，这一段时间包括固定时间+随机时间，再次堵塞时固定时间将会指数级增加，这叫做指数退避。</li></ul></li><li><p>冲突域 Collision Domain</p><ul><li>载体和其中的设备总称为“冲突域”，为了避免冲突，可以用交换器</li></ul></li></ul><h3 id="传输方式">传输方式</h3><ul><li><p>电路交换 Circuit Switching</p><ul><li>缺点：不灵活且数量昂贵</li></ul></li><li><p>报文交换 Message Switching</p><ul><li><p>报文的具体格式简称IP，每一个电脑都会有一个IP地址好处，可以用不同路由，通信更可靠也更能容错。坏处，当报文比较大的时候，会堵塞线路。解决方法是 将大报文分成很多小块，叫&quot;数据包&quot;，来进行运输，这叫“分组交换”。路由器会平衡与其他路由器之间的负载  以确保传输可以快速可靠，这叫&quot;阻塞控制&quot;</p></li><li><p>消息沿着路由跳转的次数 叫&quot;跳数&quot;(hop count)，看到哪条线路的跳数很高，说明出了故障，这叫跳数限制。</p></li></ul></li></ul><h2 id="29、互联网">29、互联网</h2><h3 id="电脑连接互联网的过程">电脑连接互联网的过程</h3><ul><li>你所用的电脑首先要连接到局域网，家里WiFi路由器连着的所有设备，组成了局域网，局域网再连到广域网（WAN），广域网的路由器一般属于你的互联网服务提供商（ISP），再连更大的WAN，往复几次，最后连到互联网主干。</li></ul><h3 id="校验和-Checksum">校验和 - Checksum</h3><ul><li>UDP校验和只有16位，超过这个数，弃高位。</li></ul><h3 id="数据传输协议">数据传输协议</h3><ul><li><p>IP - 互联网协议 - Internet Protocol</p><ul><li>IP负责把数据包送到正确的计算机</li></ul></li><li><p>UDP - 用户数据报协议 - User Datagram Protocol</p><ul><li>UDP负责把数据包传送到正确的程序，有端口号（哪个程序），校验和（数据是否损坏）</li></ul></li><li><p>TCP - 传输控制协议 - Transmission Control Protocol</p><ul><li><p>如果要控制所有数据必须到达，就用传输控制协议</p></li><li><p>TCP的特点</p><ul><li>1、控制发送的数据包按顺序到达，既对接收到的数据包排序以确保顺序正确<br>2、要求接收方确认无误后发送确认码（ACK），确认码的成功率和来回时间可以用来推测网络的拥堵程度，TCP可以根据这个调整传输率。由于这个特点，TCP对时间要求高的程序不适用。</li></ul></li></ul></li></ul><h3 id="DNS-域名系统-Domain-Name-System">DNS - 域名系统 - Domain Name System</h3><ul><li>计算机访问网站时需要两样，IP地址和端口号，但记数字很难，所以互联网通过域名系统把域名和IP地址一一对应。域名系统是树状结构。（一级域名、二级域名、三级域名…）</li></ul><h3 id="OSI-开放式系统互联通信参考模型-Open-System-Interconnection">OSI - 开放式系统互联通信参考模型 - Open System Interconnection</h3><ul><li></li></ul><h2 id="30、万维网（WWW）">30、万维网（WWW）</h2><h3 id="注：互联网和万维网完全不是一个东西，请勿混淆。">注：互联网和万维网完全不是一个东西，请勿混淆。</h3><h3 id="基本单位">基本单位</h3><ul><li>万维网在互联网上运行，它的基本单位是页面</li></ul><h3 id="超链接-Hyperlinks">超链接 Hyperlinks</h3><ul><li>点超链接可以去到另一个页面，文字超链接又叫超文本</li></ul><h3 id="状态码">状态码</h3><ul><li>状态码代表所访问网页的状态</li></ul><h3 id="URL-统一资源定位器-Uniform-Resource-Locator">URL - 统一资源定位器 - Uniform Resource Locator</h3><ul><li>网页的唯一网址</li></ul><h3 id="HTTP-超文本传输协议-HyperText-Transfer-Protocol">HTTP - 超文本传输协议 - HyperText Transfer Protocol</h3><h3 id="HTML-超文本标记语言-HyperText-Markup-Language">HTML - 超文本标记语言 - HyperText Markup Language</h3><h3 id="万维网发展史">万维网发展史</h3><ul><li>1、第一个浏览器和服务器是 Tim Berners-Lee 花了 2 个月在 CERN 写的<br>2、1991年万维网就此诞生<br>3 、Jerry 和 David 的万维网指南 后来改名成 Yahoo<br>4、搜索引擎 JumpStation（包括爬虫 索引 用法）<br>5、搜索引擎 Google   改进排序方法，按照链接指向的多少来排序</li></ul><h3 id="网络中立性">网络中立性</h3><ul><li>平等地对待每个数据包</li></ul><h2 id="31、计算机安全">31、计算机安全</h2><h3 id="保密性-完整性-可用性-Secrecy-Integrity-Availability">保密性, 完整性, 可用性 Secrecy, Integrity, Availability</h3><ul><li>计算机为了安全，要实现三性：<br>保密性：只有有权限的人，才能读取计算机系统和数据。<br>完整性：只有有权限的人，才能使用和修改系统和数据。<br>可用性：有权限的人，可以随时访问计算机系统和数据。</li></ul><h3 id="Threat-Model-威胁模型">Threat Model 威胁模型</h3><ul><li>为了实现这三个目标，安全专家会从抽象层面想象&quot;敌人&quot;可能是谁，这叫&quot;威胁模型分析&quot;，模型会对攻击者有个大致描述：<br>能力如何，目标可能是什么，可能用什么手段，攻击手段又叫 “攻击矢量” ， “威胁模型分析” 让你能为特定情境做准备，不被可能的攻击手段数量所淹没。</li></ul><h3 id="很多安全问题可以总结成两个">很多安全问题可以总结成两个</h3><ul><li><p>你是谁？</p><ul><li><p>身份验证 (Authentication) 的三种方式</p><ul><li>What you know, 你知道什么 比如用户名和密码What you have, 你有什么，比如实体钥匙<br>What you are, 你是什么，比如指纹和虹膜</li></ul></li></ul></li><li><p>你能访问什么？</p><ul><li><p>访问控制 Access Control</p><ul><li>Bell LaPadula model 不能向上读取，不能向下写入</li></ul></li></ul></li></ul><h3 id="安全内核">安全内核</h3><ul><li>安全内核应该有一组尽可能少的操作系统软件，和尽量少的代码。</li></ul><h3 id="独立安全检查和质量验证">独立安全检查和质量验证</h3><ul><li>最有效的验证手段</li></ul><h3 id="隔离-Isolation-沙盒-Sandbox">隔离 Isolation, 沙盒 Sandbox</h3><ul><li>优秀的开发人员，应该计划当程序被攻破后，如何限制损害，控制损害的最大程度，并且不让它危害到计算机上其他东西，这叫&quot;隔离&quot;。<br>要实现隔离，我们可以&quot;沙盒&quot;程序，这好比把生气的小孩放在沙箱里，他们只能摧毁自己的沙堡，不会影响到其他孩子，方法是给每个程序独有的内存块，其他程序不能动。<br>一台计算机可以运行多个虚拟机，如果一个程序出错，最糟糕的情况是它自己崩溃，或者搞坏它处于的虚拟机。</li></ul><h2 id="32、黑客与攻击">32、黑客与攻击</h2><h3 id="社会工程学-Social-Engineering">社会工程学 Social Engineering</h3><ul><li>欺骗别人获得信息，或让人安装易于攻击的系统</li></ul><h3 id="几种攻击方法">几种攻击方法</h3><ul><li><p>钓鱼 Phishing</p></li><li><p>假托 Pretexting</p></li><li><p>木马 Trojan Horses</p></li><li><p>NAND镜像 NAND Mirroring</p></li><li><p>漏洞利用 Exploit</p></li><li><p>缓冲区溢出 Buffer Overflow</p><ul><li><p>一种常见的漏洞利用</p></li><li><p>边界检查 Bounds Checking和金丝雀</p><ul><li>防止缓冲区溢出的手段。<br>金丝雀，留出一些不用的内存空间，当空间变少或内存空间的值发生改变时，说明有攻击者乱来。</li></ul></li></ul></li><li><p>代码注入 Code Injection</p><ul><li>把代码注入到程序中，造成混乱</li></ul></li></ul><h3 id="零日漏洞-Zero-Day-Vulnerability">零日漏洞 Zero Day Vulnerability</h3><ul><li>当软件制造者不知道软件有新漏洞被发现了，这个漏洞被称为“零日漏洞”</li></ul><h3 id="计算机蠕虫-Worms">计算机蠕虫 Worms</h3><ul><li>如果有足够多的电脑有漏洞，让恶意程序可以在电脑间互相传播，这种恶意程序叫做蠕虫。</li></ul><h3 id="僵尸网络-Botnet">僵尸网络 Botnet</h3><ul><li>如果黑客掌握足够多电脑，那他们可以组成“僵尸网络”。</li></ul><h2 id="33、加密">33、加密</h2><h3 id="对称加密">对称加密</h3><ul><li><p>双方用一样的秘钥加密和解密信息，叫对称解密</p><ul><li><p>硬件加密</p><ul><li><p>替换加密</p><ul><li><p>凯撒加密 Caesar cipher——一种替换加密  Substitution cipher，把字母替换成其他字母</p></li><li><p>移位加密 Permutation cipher</p></li><li><p>德国 Enigma 加密机 一种进阶的替换加密，每一次的映射都不同。</p></li></ul></li></ul></li><li><p>软件加密</p><ul><li><p>1977年&quot;数据加密标准&quot; - Data Encryption Standard (DES)</p></li><li><p>2001年&quot;高级加密标准&quot; - Advanced Encryption Standard (AES)</p></li></ul></li></ul></li></ul><h3 id="非对称加密">非对称加密</h3><ul><li>人们用公钥加密信息，只有有私钥的人能解密，或者反过来，这叫非对称解密。最有名的非对称加密算法是RSA</li></ul><h3 id="密钥交换">密钥交换</h3><ul><li>迪菲-赫尔曼密钥交换 - Diffie-Hellman Key Exchange用模幂计算来得到秘钥</li></ul><h2 id="34、机器学习与人工智能">34、机器学习与人工智能</h2><h3 id="机器学习-Machine-Learning">机器学习 Machine Learning</h3><ul><li><p>分类器 Classifier</p><ul><li><p>运用统计学知识来学习</p><ul><li><p>特征 Feature</p></li><li><p>特征值+种类叫做标记数据 Labeled data</p></li><li><p>决策边界 Decision boundaries</p></li><li><p>混淆矩阵 Confusion matrix</p></li><li><p>决策树 Decision tree</p></li></ul></li></ul></li><li><p>支持向量机 Support Vector Machines</p><ul><li>本质上是用任意线段来切分决策空间，不一定是直线。</li></ul></li></ul><h3 id="深度学习-Deep-Learning">深度学习 Deep Learning</h3><ul><li><p>人工神经网络 Artificial Neural Network</p><ul><li>不用统计学的算法。模拟人类学习的过程，将数据进行加权求和修正等一系列处理。</li></ul></li></ul><h3 id="强化学习-Reinforcement-Learning">强化学习 Reinforcement Learning</h3><ul><li><p>学习什么管用，什么不管用，自己发现成功的策略，这叫强化学习。</p></li><li><p>比如alpha GO</p></li></ul><h2 id="35、计算机视觉">35、计算机视觉</h2><h3 id="颜色跟踪算法——跟踪一个像素">颜色跟踪算法——跟踪一个像素</h3><h3 id="检测垂直边缘的算法">检测垂直边缘的算法</h3><ul><li><p>物体的边缘有多个色素，不适合颜色跟踪算法。要识别边缘，可以判断其两边像素的颜色差异程度</p></li><li><p>核/过滤器 kernel or filter</p><ul><li><p>用来检测垂直边缘的算法的数学符号，如下绿色的图。</p><ul><li></li><li></li></ul></li><li><p>Prewitt 算子 Prewitt Operators</p><ul><li>水平和垂直边缘增强的核叫Prewitt 算子</li></ul></li></ul></li><li><p>卷积 convolution</p><ul><li>把核应用于像素块</li></ul></li></ul><h3 id="维奥拉·琼斯-人脸检测-Viola-Jones-Face-Detection">维奥拉·琼斯 人脸检测 Viola-Jones Face Detection</h3><h3 id="卷积神经网络-Convolutional-Neural-Networks">卷积神经网络 Convolutional Neural Networks</h3><ul><li>用一层层不同的核来识别复杂场景，用脸来举例，先识别边缘，然后形状，器官…直至某一层把所有特征堆积在一起，识别出脸之后，可以进一步用其他算法定位面部标志，如眼睛和眉毛具体位置，从而判断心情等信息</li></ul><h2 id="36、自然语言处理">36、自然语言处理</h2><h3 id="过程">过程</h3><ul><li>通过词性 Parts of speech和短语结构规则 Phrase structure rules构建分析树 Parse tree，并结合语言模型 Language Model来实现语音识别 Speech recognition</li></ul><h3 id="实现原理">实现原理</h3><ul><li>快速傅立叶变换 Fast Fourier Transform，把波形转换成频率</li></ul><h3 id="音素-Phonemes">音素 Phonemes</h3><ul><li>构成单词的声音片段</li></ul><h3 id="语音合成-Speech-Synthesis">语音合成 Speech Synthesis</h3><h2 id="37、机器人">37、机器人</h2><h3 id="发展简单历程">发展简单历程</h3><ul><li><p>机械机器人</p><ul><li><p>法国吃饭鸭 - Digesting Duck, Canard Digerateur</p></li><li><p>土耳其行棋傀儡, 下国际象棋(假的，有人控制)</p></li></ul></li><li><p>数字机器人</p><ul><li><p>第一台计算机控制的机器出现在1940年代晚期，叫数控机器, Computer Numerical Control(CNC)</p></li><li><p>1960年 Unimate，第一个商业贩卖的 可编程工业机器人</p></li></ul></li></ul><h3 id="机器人控制的回路">机器人控制的回路</h3><ul><li><p>负反馈回路 negative feedback loop</p></li><li><p>比例-积分-导数控制器 Proportional–Integral–Derivative controller PID 控制器</p><ul><li>通过控制三个值，比例值——实际值和理想值差多少，积分值——一段时间误差的总和，前两者用来修正错误：导数值（微分值）——期望值和实际值之间的变化率，用来避免未来的错误，这也叫预期控制，来控制进程。</li></ul></li></ul><h3 id="机器人三定律-Three-Laws-of-Robotics">机器人三定律 Three Laws of Robotics</h3><p>机器人伦理讨论</p><h2 id="38、计算机心理学">38、计算机心理学</h2><h3 id="计算机中用到的心理学原理">计算机中用到的心理学原理</h3><ul><li>社会心理学 认知心理学 行为心理学 感知信息学</li></ul><h3 id="易用度">易用度</h3><ul><li>指人造物体，比如软件，达到目的的效率有多高</li></ul><h3 id="颜色强度排序和颜色排序">颜色强度排序和颜色排序</h3><ul><li>人类擅长给颜色强度排序，所以颜色强度很适合现实连续值；而人类不擅长给颜色排序，所以如果数据没有顺序，用不同颜色就很合适，如分类数据。</li></ul><h3 id="分组更好记">分组更好记</h3><ul><li>信息分块会更好记。分块是指把信息分成更小，更有意义的块，如电话号码分块，界面设计分块。</li></ul><h3 id="直观功能">直观功能</h3><ul><li>直观功能为如何操作物体提供线索，如平板用于推，旋钮用来转，直观功能做得好，用户只需要看一眼就知道怎么搞，而不需要其他东西来说明。例如：门把手让人想拉开门，但如果门需要推开，那这就是个不好的直观功能，不如直接采用平板门来的好。</li></ul><h3 id="认出VS回想">认出VS回想</h3><ul><li>和直观功能相关的一个心理学概念是认出和回想，这就是选择题比填空题简单的原因。一般来说，用感觉触发记忆会容易得多，比如文字、图片和声音，所以我们用图标表示功能，如垃圾桶表示回收站。但是，让所有菜单选项好找好记，有时候意味着用的时候会慢一些。这与另一个心理学概念冲突：&quot;专业知识”，当你用界面熟悉之后，速度会更快一些，所以 好的界面应该提供多种方法来实现目标，一个好例子是复制粘贴，可以在&quot;编辑&quot;的下拉菜单中找到，也可以用快捷键，两者都不耽误，鱼与熊掌兼得。</li></ul><h3 id="让机器有一定的情商以及Facebook的研究">让机器有一定的情商以及Facebook的研究</h3><ul><li>我们也希望电脑能有一点情商，能根据用户的状态做出合适地反应，让使用电脑更加愉快。因为情绪会影响日常活动，比如学习，沟通和决策，情感系统会用传感器，录声音，录像（你的脸）以及生物指标，比如出汗和心率，得到的数据和计算模型结合使用，模型会估算用户的情绪，给最好的回应用户。</li></ul><h3 id="用软件修正注视位置">用软件修正注视位置</h3><ul><li>心理学研究也表明，如果想说服，讲课，或引起注意 ，眼神注视非常重要。为此，研究人员开发了计算机视觉和图形软件  来纠正头部和眼睛，看视频的人会觉得对方在直视他们</li></ul><h3 id="把机器人做得像人">把机器人做得像人</h3><ul><li>人也喜欢像人的机器人。人机交互，简称HRI，是一个研究人类和计算机交互的领域。</li></ul><h3 id="开放性问题">开放性问题</h3><ul><li>计算机该不该对人类说谎等</li></ul><h2 id="39、教育科技">39、教育科技</h2><h3 id="通过调速，暂停等技巧，加强学习效率">通过调速，暂停等技巧，加强学习效率</h3><h3 id="大型开放式在线课程-Massive-Open-Online-Courses-MOOC">大型开放式在线课程 - Massive Open Online Courses (MOOC)</h3><h3 id="智能辅导系统-Intelligent-Tutoring-Systems">智能辅导系统 - Intelligent Tutoring Systems</h3><h3 id="判断规则-Production-rule">判断规则 - Production rule</h3><h3 id="域模型-Domain-Model">域模型 - Domain Model</h3><ul><li>判断规则和选择算法，组合在一起成为域模型</li></ul><h3 id="贝叶斯知识追踪-Bayesian-knowledge-tracing">贝叶斯知识追踪 Bayesian knowledge tracing</h3><ul><li><p>基于四种概率来判断学生是否学会</p><ul><li><p>学生已经学会的概率</p></li><li><p>瞎猜的概率</p></li><li><p>失误的概率</p></li><li><p>做题过程中学会的概率</p></li></ul></li><li><p>把学生的知识掌握当成隐藏变量，根据学生答题的正确度，更新学生掌握程度的估算值。具体而言，贝叶斯知识追踪有一组方程，会用这四个概率，更新学生模型，评估其掌握程度。</p></li></ul><h3 id="自适应性程序">自适应性程序</h3><ul><li>一种算法，选择适合学生的问题，让学生学。</li></ul><h3 id="教育数据挖掘-Educational-Data-Mining">教育数据挖掘 Educational Data Mining</h3><ul><li>看学生答题时停顿的时间，观察学生停顿和加速视频的时间段，看论坛问题，来评估学生的程度。</li></ul><h2 id="40、奇点，天网，计算机的未来">40、奇点，天网，计算机的未来</h2><h3 id="普适计算-Ubiquitous-Computing">普适计算 Ubiquitous Computing</h3><ul><li>计算机融入生活的方方面面</li></ul><h3 id="奇点-Singularity">奇点 Singularity</h3><ul><li>智能科技的失控性发展</li></ul><h3 id="把工作分为4个象限，讨论自动化带来的影响">把工作分为4个象限，讨论自动化带来的影响</h3><ul><li></li></ul><h3 id="机器人的存在时间可能长过人类，可以长时间探索宇宙。">机器人的存在时间可能长过人类，可以长时间探索宇宙。</h3>]]></content>
      
      
      <categories>
          
          <category> Computer System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crash Course Computer Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数学模型 姜启源] 第五章：微分方程模型</title>
      <link href="/2025/03/02/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B-%E5%A7%9C%E5%90%AF%E6%BA%90-%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/03/02/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B-%E5%A7%9C%E5%90%AF%E6%BA%90-%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1>第五章：微分方程模型</h1><h2 id="要点摘录">要点摘录</h2><ul><li>两个人口增长模型<ul><li>指数增长模型<ul><li>增长率 r 为常数</li><li>增长率 r 为时间 t 的函数</li></ul></li><li>logistic 模型<ul><li>增长率 r 为线性函数，参数由内禀增长率和人口容量决定</li></ul></li></ul></li><li>微分方程参数估计的几种方法<ul><li>求解结果化为线性函数，使用最小二乘法拟合数据</li><li>数值微分，得出微分方程含微分那一项的估计值或与另一自变量的关系，使用最小二乘法估计</li><li>求解结果用非线性最小二乘法拟合数据</li></ul></li><li>微分方程的平衡点和平衡性</li><li>传染病模型<ul><li>SI</li><li>SIS</li><li>SIR</li><li>SEIR</li><li>SVEIR</li><li>SVEIRD</li></ul></li><li>相轨线</li><li>香烟过滤嘴</li><li>火箭发射升空</li><li>Volterra 食饵 - 捕食者模型</li><li>Keller 赛跑模型</li><li>扩散方程和热传导方程</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mathematical Modeling </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学模型 </tag>
            
            <tag> 姜启源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数学模型 姜启源] 第四章：数学规划模型</title>
      <link href="/2025/03/02/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B-%E5%A7%9C%E5%90%AF%E6%BA%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/03/02/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B-%E5%A7%9C%E5%90%AF%E6%BA%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1>第四章：数学规划模型</h1><h2 id="要点摘录">要点摘录</h2><ul><li>线性规划模型<ul><li>使用 <code>LINGO</code> 来求解</li><li>紧约束</li><li>影子价格</li><li>对目标函数系数的敏感性分析</li><li>对资源约束右端项的敏感性分析</li></ul></li><li>整数规划求解</li><li>处理模型中的分段函数<ul><li>为每个区间设一个决策变量，通过决策变量间的数量关系来表示分段函数，可能化为非线性规划</li><li>引入 0-1 变量，为每个区间设一个决策变量，通过决策变量间的数量关系来表示分段函数，化为线性规划</li><li>直接处理分段线性函数，原理未理解，记住如何使用（P111）</li></ul></li><li>题干中的对象之间有先后关系 =&gt; 将中间物也看作一个对象，为其设置相关决策变量，以此来连接两端的对象之间的关系</li><li>指派问题（引入 0-1 变量来建模）</li><li>单目标规划与多目标规划（解决方法是：通过加权组合形成一个新的单一目标）</li><li>生产批量问题（还是引入 0-1 变量，0-1 变量有强大的表达力：表示选择）</li><li>生产下料问题</li><li>目标规划</li><li>现代投资组合理论</li><li>均值-方差模型</li><li>分离定理</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mathematical Modeling </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学模型 </tag>
            
            <tag> 姜启源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数学模型 姜启源] 第三章：简单的优化模型</title>
      <link href="/2025/03/02/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B-%E5%A7%9C%E5%90%AF%E6%BA%90-%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/03/02/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B-%E5%A7%9C%E5%90%AF%E6%BA%90-%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1>第三章：简单的优化模型</h1><h2 id="要点摘录">要点摘录</h2><ul><li>允许缺货的存贮模型和不允许缺货的存贮模型</li><li>不允许缺货的生产销售存贮模型</li><li>多个物体组合成的物体的质心的计算（通过力矩平衡关系）</li><li>敏感性分析的一般表示</li><li>效用函数和边际效用</li><li>效用函数和边际效用的两个性质</li><li>效用最大化模型和效用最大化原理（不买贵的，只买对的）</li><li>流体力学关于黏性流体在刚性管道中流动时能量消耗定律</li><li>最优化的值一定是在各变量的偏导值为0时取得</li><li>篮球罚球模型（由理想模型（质点）到逐步考虑实际状况，由浅入深）</li><li>数值方法求解最优解</li><li>结合实际观察，一些对全部考虑对象的限制可能可以归结到对单个考虑对象的限制，这样减少了运算量和简化了模型的表达</li><li>拉格朗日乘子法求最优解</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mathematical Modeling </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学模型 </tag>
            
            <tag> 姜启源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数学模型 姜启源] 第二章：初等模型</title>
      <link href="/2025/03/02/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B-%E5%A7%9C%E5%90%AF%E6%BA%90-%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%88%9D%E7%AD%89%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/03/02/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B-%E5%A7%9C%E5%90%AF%E6%BA%90-%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%88%9D%E7%AD%89%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1>第二章：初等模型</h1><h2 id="要点记录">要点记录</h2><ul><li>热传导公式（及其应用假设）</li><li>热量传播的两种形式</li><li>盯准所求目标，有方向地去消元和 <code>play with equation</code></li><li>无差别曲线</li><li>交换路径</li><li>等价交换曲线</li><li>交通流的描述<ul><li>流量、速度、密度</li><li>流量与速度的数量关系</li><li>流量与密度的数量关系</li></ul></li><li>汽车刹车距离模型</li><li>道路通行能力模型</li><li>五种由样本估计整体的模型<ul><li>平均值估计</li><li>中位数估计</li><li>两端间距对称估计</li><li>平均间距估计</li><li>区间等分估计</li></ul></li><li>数值模拟方法</li><li>比较同一类型不同级别的事物在某方面的性能（表现）的方法</li><li>双方牵制平衡问题</li><li>受力分析问题</li><li>数学建模就是确定有哪些变量，变量之间有什么关系（方程），用变量的关系组合（方程）来表述出对一个实际问题的刻画（经验和直觉）</li><li>当分析一个过程，直接微分积分比较不好弄的时候，可以尝试先 <code>n</code> 等分再求和，之后对 <code>n</code> 取不同值来近似刻画微分后积分的效果，这样每一个小的 <code>n</code> 等分中的变量的值，可以有一些设置为常数，方便建模和列方程</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mathematical Modeling </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学模型 </tag>
            
            <tag> 姜启源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数学模型 姜启源] 第一章：建立数学模型</title>
      <link href="/2025/03/02/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B-%E5%A7%9C%E5%90%AF%E6%BA%90-%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E5%BB%BA%E7%AB%8B%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/03/02/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B-%E5%A7%9C%E5%90%AF%E6%BA%90-%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E5%BB%BA%E7%AB%8B%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1>第一章：建立数学模型</h1><h2 id="要点摘录：">要点摘录：</h2><ul><li>原型和模型的概念与区别</li><li>构造模型的目的性</li><li>模型的分类<ul><li>形象模型<ul><li>直观模型</li><li>物理模型</li></ul></li><li>抽象模型<ul><li>思维模型</li><li>符号模型</li><li>数学模型</li></ul></li></ul></li><li>包饺子案例</li><li>路障间距设计案例</li><li>椅子稳放案例</li><li>数学建模的两种方法和基本步骤</li></ul><h2 id="详细记录">详细记录</h2><h3 id="原型和模型的概念与区别">原型和模型的概念与区别</h3><p><strong>原型</strong>：指人们在现实世界里关心、研究或者从事生产、管理的==实际对象==。可以是一个系统，也可以是一个过程。</p><ul><li>客观存在，是客观因素（变量）的集合，是对一个整体的概括。</li></ul><p><strong>模型</strong>：指为了某个==特定目的==将原型的某一部分简缩、提炼而构造的原型替代物。</p><ul><li>是部分（受关心）的因素（变量）的集合，仅表示感兴趣的一个部分。</li></ul><h3 id="构造模型的目的性">构造模型的目的性</h3><ul><li>模型不是原型原封不动的复制品，原型有各个方面和各种层次的特征，而模型只要求反应与某种目的有关的那些方面和层次。</li><li>一个原型，为了不同的目的可以有许多不同的模型。</li><li>模型的基本特征是由构造模型的目的决定的。</li></ul><h3 id="模型的分类">模型的分类</h3><h4 id="形象模型">形象模型</h4><ul><li><strong>直观模型</strong>：通常是原型尺寸的等比例缩放，主要追求外观上的逼真，效果是一目了然。</li><li><strong>物理模型</strong>：为了一定目的根据与原型相似的原理构造的模型，仿照原型的外形和某些特征，进行模拟实验，用来==间接地==研究原型地某些规律。</li></ul><h4 id="抽象模型">抽象模型</h4><ul><li><p><strong>思维模型</strong>：人脑通过不断试错尝试，总结经验，完成对原型某一部分信息的简缩和提炼，所形成的思维或直觉。</p></li><li><p><strong>符号模型</strong>：在一些约定或假设下借助于专门的符号、线条等，按一定形式组合起来描述原型。如地图、电路图、化学结构式等。</p></li><li><p><strong>数学模型</strong>：由数字、字母或其他数学符号组成的，描述原型==数量规律==的数学公式、图形或算法。</p><blockquote><p>又可以被一般地描述为：对于现实世界的一个<strong>特定对象</strong>，为了一个<strong>特定目的</strong>，根据特有的<strong>内在规律</strong>，做出一些必要的<strong>简化假设</strong>，运用适当的<strong>数学工具</strong>，得到的一个<strong>数学结构</strong>。</p></blockquote></li></ul><h3 id="包饺子案例">包饺子案例</h3><h3 id="路障间距案例">路障间距案例</h3><h3 id="椅子稳放案例">椅子稳放案例</h3><h3 id="数学建模额两种方法和步骤">数学建模额两种方法和步骤</h3><h4 id="两种方法">两种方法</h4><ul><li><p>机理分析</p><p>根据对研究对象特性的认识，找出反应内部机理的<strong>数量规律</strong>，建立的模型常有明确的物理或现实意义。</p></li><li><p>数据驱动</p><p>基于对研究对象收集到的大量数据，通过统计分析、系统辨识、机器学习、人工智能等手段，按照一定的准则找出与数据拟合得最好的模型。</p></li></ul><h4 id="步骤">步骤</h4><ol><li><p>模型准备</p><p>了解实际问题背景，明确目的，搜集与问题有关信息，弄清研究对象的主要特征，由此初步确定使用哪一类模型。</p></li><li><p>模型假设</p><p>根据对象的特征和建模的目的，抓住问题<strong>本质</strong>，忽略次要因素，做出必要、合理的<strong>简化</strong>假设。（重要且困难，是一门 <code>art</code> 的技术活）</p></li><li><p>模型构成</p><p>直观地说，就是列出描述对象内在各方面数量规律的方程组，或者说是用数学的语言、符号描述对象的内在数量规律。</p></li><li><p>模型求解</p><p>在给定的条件下求解方程（解方程、画图、优化方法、数值计算、概率统计等 <code>approach</code>），得到答案</p></li><li><p>模型分析</p><p>对求解结果进行数学上的分析（误差分析、统计分析、灵敏性分析、健壮性分析）</p></li><li><p>模型验证</p><p>将求解和分析的结果翻译回实际问题，检验模型的合理性和适用性。根据检验结果<strong>反馈地修改模型假设</strong>。</p></li><li><p>模型应用</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mathematical Modeling </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学模型 </tag>
            
            <tag> 姜启源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NJU-PA: Works and Thoughts</title>
      <link href="/2025/03/01/NJU-PA-Works-and-Thoughts/"/>
      <url>/2025/03/01/NJU-PA-Works-and-Thoughts/</url>
      
        <content type="html"><![CDATA[<h1>实验心得记录</h1><h2 id="开天辟地的篇章">开天辟地的篇章</h2><p>必做题</p><img src="/2025/03/01/NJU-PA-Works-and-Thoughts/image-20250113222506458.png" class=""><p>解答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(0, x, x) -&gt; (1, 0, x) -&gt; (2, 0, 0) -&gt; (3, 0, 1) -&gt; (4, 1, 1) -&gt; (2, 1, 1) -&gt; (3, 1, 2) -&gt; (4, 3, 2) -&gt; (2, 3, 2) -&gt; (3, 3, 3) -&gt; (4, 6, 3) -&gt; ... -&gt; (2, 4851, 98) -&gt; (3, 4851, 99) -&gt; (4, 4950, 99) -&gt; (2, 4950, 99) -&gt; (3, 4950, 100) -&gt; (4, 5050, 100) -&gt; (5, 5050, 100) -&gt; (5, 5050, 100) -&gt; ... -&gt; HALT</span><br></pre></td></tr></table></figure><h2 id="RTFSC">RTFSC</h2><h3 id="准备第一个客户程序">准备第一个客户程序</h3><blockquote><h5 id="kconfig-生成的宏与条件编译">kconfig 生成的宏与条件编译</h5><p>我们已经在上文提到过, kconfig 会根据配置选项的结果在 <code>nemu/include/generated/autoconf.h</code> 中定义一些形如 <code>CONFIG_xxx</code> 的宏, 我们可以在C代码中通过条件编译的功能对这些宏进行测试, 来判断是否编译某些代码. 例如, 当 <code>CONFIG_DEVICE</code> 这个宏没有定义时, 设备相关的代码就无需进行编译.</p><p>为了编写更紧凑的代码, 我们在 <code>nemu/include/macro.h</code> 中定义了一些专门用来对宏进行测试的宏. 例如 <code>IFDEF(CONFIG_DEVICE, init_device());</code> 表示, 如果定义了<code>CONFIG_DEVICE</code>, 才会调用 <code>init_device()</code> 函数; 而 <code>MUXDEF(CONFIG_TRACE, &quot;ON&quot;, &quot;OFF&quot;)</code> 则表示, 如果定义了 <code>CONFIG_TRACE</code>, 则预处理结果为 <code>&quot;ON&quot;</code>(<code>&quot;OFF&quot;</code> 在预处理后会消失), 否则预处理结果为 <code>&quot;OFF&quot;</code>.</p><p>这些宏的功能非常神奇, 你知道这些宏是如何工作的吗?</p></blockquote><p>初步阅读总结：通过不断展开宏来一步步选择出结果或要执行的函数</p><blockquote><h5 id="为什么全部都是函数">为什么全部都是函数?</h5><p>阅读 <code>init_monitor()</code> 函数的代码, 你会发现里面全部都是函数调用. 按道理, 把相应的函数体在 <code>init_monitor()</code> 中展开也不影响代码的正确性. 相比之下, 在这里使用函数有什么好处呢?</p></blockquote><p>回答：因为 <code>monitor</code> 所承担的功能是初始化系统各部分以准备开始调试，在这里使用函数方便灵活，可以灵活决定是把初始化的实现交给 <code>monitor</code> 还是交给初始化部分自身。也是代码的一种模块化组织方法。</p><blockquote><h5 id="参数的处理过程">参数的处理过程</h5><p>另外的一个问题是, 这些参数是从哪里来的呢?</p></blockquote><p>在启动 <code>nemu</code> 时，会调用 <code>nemu-main.c</code> 文件中的 <code>main</code> 函数，同时会传递命令行参数，在其中调用 <code>init_monitor</code> 函数时，会传递命令行参数。</p><blockquote><h5 id="究竟要执行多久">究竟要执行多久?</h5><p>在 <code>cmd_c()</code> 函数中, 调用 <code>cpu_exec()</code> 的时候传入了参数 <code>-1</code>, 你知道这是什么意思吗?</p></blockquote><p><code>cpu_exec()</code> 的函数签名：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cpu_exec</span><span class="params">(<span class="type">uint64_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p>传入参数 <code>-1</code> 在类型 <code>uint64_t</code> 中表示为最大值（具体为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{64} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">64</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>），再结合 <code>cpu_exec()</code> 中调用的函数 <code>execute()</code> 的函数体内容：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">uint64_t</span> n)</span> &#123;</span><br><span class="line">Decode s;</span><br><span class="line">    <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n --) &#123;</span><br><span class="line">        exec_once(&amp;s, cpu.pc);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可知这是在模拟键入 <code>continue</code> 后，放任程序继续运行直到程序退出或者程序遇到下一个断点或者程序抛出异常，由于最大可运行步数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{64}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">64</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 步（十分大的数），可认为键入 <code>continue</code> 后程序会一直运行。</p><blockquote><h5 id="潜在的威胁-建议二周目思考">潜在的威胁 (建议二周目思考)</h5><p>“调用 <code>cpu_exec()</code> 的时候传入了参数<code>-1</code>”, 这一做法属于未定义行为吗? 请查阅C99手册确认你的想法.</p></blockquote><p>初步思考：这一做法是定义良好的，向类型 <code>uint64_t</code> 传入参数 <code>-1</code> 会使得被赋值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{64} -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">64</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>. 具体来说，任何负数都会被赋值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>g</mi><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>N</mi></msup><mo separator="true">,</mo><mspace width="1em"/><mi>N</mi><mo>=</mo><mn>64</mn></mrow><annotation encoding="application/x-tex">neg / 2^N, \quad N=64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span></span></span></span>.</p><blockquote><h5 id="谁来指示程序的结束">谁来指示程序的结束?</h5><p>在程序设计课上老师告诉你, 当程序执行到 <code>main()</code> 函数返回处的时候, 程序就退出了, 你对此深信不疑. 但你是否怀疑过, 凭什么程序执行到 <code>main()</code> 函数的返回处就结束了? 如果有人告诉你, 程序设计课上老师的说法是错的, 你有办法来证明/反驳吗? 如果你对此感兴趣, 请在互联网上搜索相关内容.</p></blockquote><p>来自 GPT：在大多数常见的 C 程序中，当 <code>main</code> 函数返回后，程序结束是由运行时库调用 <code>exit</code> 进而由操作系统管理完成的；而在没有操作系统的场景中，需要程序员额外编写代码来处理退出后如何停止或复位系统。比如：</p><ul><li>让处理器进入低功耗状态或死循环；</li><li>或者调用硬件相关的复位（reset）机制，重新启动系统；</li><li>甚至设计特定的 “退出” 函数，来执行必要的清理并通知硬件程序已经结束。</li></ul><blockquote><h5 id="有始有终-建议二周目思考">有始有终 (建议二周目思考)</h5><p>对于GNU/Linux上的一个程序, 怎么样才算开始? 怎么样才算是结束? 对于在NEMU中运行的程序, 问题的答案又是什么呢?</p><p>与此相关的问题还有: NEMU中为什么要有 <code>nemu_trap</code> ? 为什么要有monitor?</p></blockquote><p>来自GPT：</p><p>GNU/Linux 程序：</p><p><strong>开始</strong>：内核加载程序、创建进程，到 CRT 的 <code>_start</code> 开始运行，再到 CRT 调用 <code>main</code>。</p><p><strong>结束</strong>：当程序调用退出机制（无论是 <code>main</code> 返回还是显式调用 <code>exit</code>），并由 CRT 通过系统调用告知内核进程退出后，操作系统完成资源回收，程序就算结束了。</p><p>NEMU 环境：</p><p><strong>开始</strong>：从复位向量开始执行启动代码，初始化后进入主程序。</p><p><strong>结束</strong>：没有操作系统来管理退出，程序需要通过特殊的（约定或设计）退出机制（例如特定指令或陷入死循环）来通知模拟器程序结束或进入停机状态。</p><p>为什么要有 <code>nemu_trap</code> ? 为什么要有 monitor?</p><p><code>nemu_trap</code> 就是特殊设计的（或约定的）程序退出机制。monitor 相当于操作系统（当然是及其简易的操作系统），承担了操作系统处理程序退出的功能（捕获 <code>nemu_trap</code> 并退出程序）。</p><p>GPT 对此回答的评论：</p><p>你的回答抓住了核心思想，基本上是正确的。具体来说：</p><ol><li><strong>nemu_trap</strong><ul><li>你的回答指出 <code>nemu_trap</code> 是一种特殊设计或约定的程序退出机制，这是正确的。在 NEMU 环境中，<code>nemu_trap</code> 用来通知 monitor 某些重要事件（如程序结束、断点命中、错误等），从而实现类似于中断或系统调用的功能。</li></ul></li><li><strong>monitor</strong><ul><li>你提到 monitor 类似于一个及其简易的操作系统，承担了捕获 <code>nemu_trap</code> 并处理程序退出的功能。确实，monitor 在 NEMU 中扮演着类似操作系统的角色，不仅用于捕获退出信号，还可能负责调试、资源管理等其他基础功能。</li></ul></li></ol><blockquote><h5 id="优美地退出">优美地退出</h5><p>为了测试大家是否已经理解框架代码, 我们给大家设置一个练习: 如果在运行NEMU之后直接键入<code>q</code>退出, 你会发现终端输出了一些错误信息. 请分析这个错误信息是什么原因造成的, 然后尝试在NEMU中修复它.</p></blockquote><p>报错截图：</p><img src="/2025/03/01/NJU-PA-Works-and-Thoughts/image-20250207000627114.png" class=""><p>修复步骤：查看报错，发现是在 makefile 里报的错，发现是因为 <code>make run</code> 的返回值不为 0，导致 makefile 报错。进一步查看 <code>make run</code> 内执行的指令，发现就是执行 <code>nemu</code> 编译后的可执行文件，所以断定是 <code>nemu</code> 的可执行文件（即 <code>nemu</code> 本体）退出时返回值不为 0。进一步跟踪 <code>nemu</code> 的 <code>main</code> 函数的执行，发现在输入 <code>q</code> 后，<code>sdb_mainloop()</code> 直接返回，然后 <code>main</code> 函数返回函数 <code>is_exit_status_bad()</code> 的返回值。查看该函数，其内容如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_exit_status_bad</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> good = (nemu_state.state == NEMU_END &amp;&amp; nemu_state.halt_ret == <span class="number">0</span>) || (nemu_state.state == NEMU_QUIT);</span><br><span class="line"><span class="keyword">return</span> !good;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>||</code> 的前面表示程序结束且返回值为 0，即程序正常退出，后面表示键入 <code>q</code> 后模拟器退出。这两种情况都视为退出状态是好的。于是我们查看键入 <code>q</code> 后程序的行为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_q</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，键入 <code>q</code> 后，其对应的处理函数只有一条语句：返回 -1，这本身没错，这会导致 <code>sdb_mainloop()</code> 函数返回。但是其因为没有设置 <code>nemu</code> 的状态为 <code>QUIT</code>，所以导致最后函数 <code>is_exit_status_bad()</code> 的返回值为 1，不为 0，导致 makefile 报错。所以解决方案很简单了，就是在 <code>return -1</code> 之前，设置 <code>nemu</code> 的状态为 <code>QUIT</code>。</p><p>通过 gdb 调试 <code>nemu</code> 可执行文件得知，<code>nemu</code> 的状态结构体 类型 <code>NEMUState</code> 是在 <code>utils.h</code> 文件中定义的，并在该文件中声明了一个该类型的全局变量（说是声明，其实不完全是，这个语句的作用仅仅是：告诉编译器：“某个全局变量 <code>nemu_state</code> 存在，但它的定义在别处”，而不会分配内存）： <code>extern NEMUState nemu_state</code>，并在文件 <code>state.c</code> 中定义和初始化了该变量：<code>NEMUState nemu_state = &#123; .state = NEMU_STOP &#125;;</code>。通过询问 GPT 得知，如果要在其他文件中使用这个变量，只需要包含头文件 <code>utils.h</code> 就行，所以要做的改动就很简单了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_q</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">    nemu_state.state = NEMU_QUIT;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译，直接键入 <code>q</code>，发现问题已经解决，没有报错：</p><img src="/2025/03/01/NJU-PA-Works-and-Thoughts/image-20250207002317754.png" class=""><h2 id="表达式求值">表达式求值</h2><h3 id="不兼容的正则表达式">不兼容的正则表达式</h3><p>以下代码遇到奇怪 <code>bug</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *regex;</span><br><span class="line">  <span class="type">int</span> token_type;</span><br><span class="line">&#125; rules[] = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Add more rules.</span></span><br><span class="line"><span class="comment">   * Pay attention to the precedence level of different rules.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  &#123;<span class="string">&quot; +&quot;</span>, TK_NOTYPE&#125;,    <span class="comment">// spaces</span></span><br><span class="line">  &#123;<span class="string">&quot;[0-9]+&quot;</span>, TK_DEC&#125;,     <span class="comment">// decimal number</span></span><br><span class="line">  &#123;<span class="string">&quot;\\(&quot;</span>, TK_LPAR&#125;,     <span class="comment">// left parentheses</span></span><br><span class="line">  &#123;<span class="string">&quot;\\)&quot;</span>, TK_RPAR&#125;,     <span class="comment">// right parentheses</span></span><br><span class="line">  &#123;<span class="string">&quot;\\*&quot;</span>, <span class="string">&#x27;*&#x27;</span>&#125;,         <span class="comment">// times</span></span><br><span class="line">  &#123;<span class="string">&quot;/&quot;</span>, <span class="string">&#x27;/&#x27;</span>&#125;,           <span class="comment">// divide</span></span><br><span class="line">  &#123;<span class="string">&quot;\\+&quot;</span>, <span class="string">&#x27;+&#x27;</span>&#125;,         <span class="comment">// plus</span></span><br><span class="line">  &#123;<span class="string">&quot;-&quot;</span>, <span class="string">&#x27;-&#x27;</span>&#125;,           <span class="comment">// minus</span></span><br><span class="line">  &#123;<span class="string">&quot;==&quot;</span>, TK_EQ&#125;,        <span class="comment">// equal</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将 <code>[0-9]+</code> 替换为 <code>\\d+</code> 将不能正常识别出阿拉伯数字，原因猜想可能与 POSIX 的正则表达式函数有关。</p><blockquote><h5 id="表达式生成器如何获得C程序的打印结果">表达式生成器如何获得C程序的打印结果?</h5><p>代码中这部分的内容没有任何注释, 聪明的你也许马上就反应过来: 竟然是个RTFM的圈套! 阅读手册了解API的具体行为可是程序员的基本功. 如果觉得去年一整年的程序员都白当了, 就从现在开始好好锻炼吧.</p></blockquote><p>使用如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fp = popen(<span class="string">&quot;/tmp/.expr&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">assert(fp != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">ret = <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d&quot;</span>, &amp;result);</span><br><span class="line">pclose(fp);</span><br></pre></td></tr></table></figure><p><code>popen</code> 会打开并执行编译好的文件，并将结果输出，<code>fscanf</code> 从输出流中拿结果并赋值给 <code>result</code>.</p><blockquote><h5 id="为什么要使用无符号类型-建议二周目思考">为什么要使用无符号类型? (建议二周目思考)</h5><p>我们在表达式求值中约定, 所有运算都是无符号运算. 你知道为什么要这样约定吗? 如果进行有符号运算, 有可能会发生什么问题?</p></blockquote><p>有符号运算可能导致运算结果为负数，反应到机器内存地址上造成内存访问出界</p><blockquote><h5 id="除-0-的确切行为">除 0 的确切行为</h5><p>如果生成的表达式有除 0 行为, 你编写的表达式生成器的行为又会怎么样呢?</p></blockquote><p>在进行错误检查之前，会弹出除零警告，该表达式求值失败，但不会影响后续表达式求值。</p><p>进行错误检查后，当发现除零异常时，会跳过该表达式的求值结果打印，直接进行下一个表达式的结果打印。</p><h3 id="小插曲">小插曲</h3><p>改造 <code>nemu</code> 的 <code>main</code> 函数为如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;common.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/home/yl/ics2022/nemu/src/monitor/sdb/sdb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_monitor</span><span class="params">(<span class="type">int</span>, <span class="type">char</span> *[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">am_init_monitor</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">engine_start</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">is_exit_status_bad</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="comment">//  /* Initialize the monitor. */</span></span><br><span class="line"><span class="comment">// #ifdef CONFIG_TARGET_AM</span></span><br><span class="line"><span class="comment">//   am_init_monitor();</span></span><br><span class="line"><span class="comment">// #else</span></span><br><span class="line"><span class="comment">//   init_monitor(argc, argv);</span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   /* Start engine. */</span></span><br><span class="line"><span class="comment">//   engine_start();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   return is_exit_status_bad();</span></span><br><span class="line"></span><br><span class="line">  FILE *fp = fopen(<span class="string">&quot;/home/yl/input&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  assert(fp != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="type">word_t</span> expected = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">65536</span> + <span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">char</span> <span class="built_in">exp</span>[<span class="number">65536</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(buf, <span class="string">&quot;%u %[^\n]&quot;</span>, &amp;expected, <span class="built_in">exp</span>) == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Number: %u, String: %s\n&quot;</span>, expected, <span class="built_in">exp</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">word_t</span> actual = expr(<span class="built_in">exp</span>, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="keyword">if</span> (actual == expected) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Match!! expected is %u, actula is %u\n&quot;</span>, expected, actual);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Don&#x27;t Match. expected is %u, actula is %u\n&quot;</span>, expected, actual);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;evaluation failed at %s\n&quot;</span>, <span class="built_in">exp</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Total match: %d/%d\n&quot;</span>, count, <span class="number">100</span>);</span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现每次程序运行到 <code>make_token</code> 的 <code>regexec</code> 调用时就发生段错误，检查代码，发现正则表达式是在函数 <code>init_monitor</code> 中编译的，因为在 <code>main</code> 中注释掉了，所以导致 <code>regexec</code> 段错误，取消注释，问题解决。</p><img src="/2025/03/01/NJU-PA-Works-and-Thoughts/image-20250218003706612.png" class=""><p>9359 条随机生成表达式（数字局限在 1-9）测试全部正确求值！</p><p>TODO：随机生成 1-3 位数的数字（完成如下，全部正确求值）</p><img src="/2025/03/01/NJU-PA-Works-and-Thoughts/image-20250222235311735.png" class=""><p>至此 <code>PA1.2</code> 圆满完成</p><h2 id="监视点">监视点</h2>]]></content>
      
      
      <categories>
          
          <category> Computer System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> Simulator </tag>
            
            <tag> NEMU </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>link to other blogs</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
